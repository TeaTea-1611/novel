
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model NotificationSettings
 * 
 */
export type NotificationSettings = $Result.DefaultSelection<Prisma.$NotificationSettingsPayload>
/**
 * Model Author
 * 
 */
export type Author = $Result.DefaultSelection<Prisma.$AuthorPayload>
/**
 * Model Novel
 * 
 */
export type Novel = $Result.DefaultSelection<Prisma.$NovelPayload>
/**
 * Model Genre
 * 
 */
export type Genre = $Result.DefaultSelection<Prisma.$GenrePayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model TagGroup
 * 
 */
export type TagGroup = $Result.DefaultSelection<Prisma.$TagGroupPayload>
/**
 * Model NovelTag
 * 
 */
export type NovelTag = $Result.DefaultSelection<Prisma.$NovelTagPayload>
/**
 * Model Chapter
 * 
 */
export type Chapter = $Result.DefaultSelection<Prisma.$ChapterPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model ReplyComment
 * 
 */
export type ReplyComment = $Result.DefaultSelection<Prisma.$ReplyCommentPayload>
/**
 * Model Reading
 * 
 */
export type Reading = $Result.DefaultSelection<Prisma.$ReadingPayload>
/**
 * Model Favorite
 * 
 */
export type Favorite = $Result.DefaultSelection<Prisma.$FavoritePayload>
/**
 * Model NovelStatistic
 * 
 */
export type NovelStatistic = $Result.DefaultSelection<Prisma.$NovelStatisticPayload>
/**
 * Model ChapterStatistic
 * 
 */
export type ChapterStatistic = $Result.DefaultSelection<Prisma.$ChapterStatisticPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  Admin: 'Admin',
  User: 'User'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const Gender: {
  Male: 'Male',
  Female: 'Female',
  Other: 'Other'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const NovelKind: {
  Translation: 'Translation',
  Original: 'Original'
};

export type NovelKind = (typeof NovelKind)[keyof typeof NovelKind]


export const NovelStatus: {
  Ongoing: 'Ongoing',
  Completed: 'Completed',
  Paused: 'Paused'
};

export type NovelStatus = (typeof NovelStatus)[keyof typeof NovelStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type NovelKind = $Enums.NovelKind

export const NovelKind: typeof $Enums.NovelKind

export type NovelStatus = $Enums.NovelStatus

export const NovelStatus: typeof $Enums.NovelStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationSettings`: Exposes CRUD operations for the **NotificationSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationSettings
    * const notificationSettings = await prisma.notificationSettings.findMany()
    * ```
    */
  get notificationSettings(): Prisma.NotificationSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.author`: Exposes CRUD operations for the **Author** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Authors
    * const authors = await prisma.author.findMany()
    * ```
    */
  get author(): Prisma.AuthorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.novel`: Exposes CRUD operations for the **Novel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Novels
    * const novels = await prisma.novel.findMany()
    * ```
    */
  get novel(): Prisma.NovelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.genre`: Exposes CRUD operations for the **Genre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Genres
    * const genres = await prisma.genre.findMany()
    * ```
    */
  get genre(): Prisma.GenreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tagGroup`: Exposes CRUD operations for the **TagGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TagGroups
    * const tagGroups = await prisma.tagGroup.findMany()
    * ```
    */
  get tagGroup(): Prisma.TagGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.novelTag`: Exposes CRUD operations for the **NovelTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NovelTags
    * const novelTags = await prisma.novelTag.findMany()
    * ```
    */
  get novelTag(): Prisma.NovelTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chapter`: Exposes CRUD operations for the **Chapter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chapters
    * const chapters = await prisma.chapter.findMany()
    * ```
    */
  get chapter(): Prisma.ChapterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.replyComment`: Exposes CRUD operations for the **ReplyComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReplyComments
    * const replyComments = await prisma.replyComment.findMany()
    * ```
    */
  get replyComment(): Prisma.ReplyCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reading`: Exposes CRUD operations for the **Reading** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Readings
    * const readings = await prisma.reading.findMany()
    * ```
    */
  get reading(): Prisma.ReadingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.favorite`: Exposes CRUD operations for the **Favorite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Favorites
    * const favorites = await prisma.favorite.findMany()
    * ```
    */
  get favorite(): Prisma.FavoriteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.novelStatistic`: Exposes CRUD operations for the **NovelStatistic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NovelStatistics
    * const novelStatistics = await prisma.novelStatistic.findMany()
    * ```
    */
  get novelStatistic(): Prisma.NovelStatisticDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chapterStatistic`: Exposes CRUD operations for the **ChapterStatistic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChapterStatistics
    * const chapterStatistics = await prisma.chapterStatistic.findMany()
    * ```
    */
  get chapterStatistic(): Prisma.ChapterStatisticDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.3.0
   * Query Engine version: acc0b9dd43eb689cbd20c9470515d719db10d0b0
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    RefreshToken: 'RefreshToken',
    NotificationSettings: 'NotificationSettings',
    Author: 'Author',
    Novel: 'Novel',
    Genre: 'Genre',
    Tag: 'Tag',
    TagGroup: 'TagGroup',
    NovelTag: 'NovelTag',
    Chapter: 'Chapter',
    Review: 'Review',
    Comment: 'Comment',
    ReplyComment: 'ReplyComment',
    Reading: 'Reading',
    Favorite: 'Favorite',
    NovelStatistic: 'NovelStatistic',
    ChapterStatistic: 'ChapterStatistic'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "refreshToken" | "notificationSettings" | "author" | "novel" | "genre" | "tag" | "tagGroup" | "novelTag" | "chapter" | "review" | "comment" | "replyComment" | "reading" | "favorite" | "novelStatistic" | "chapterStatistic"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      NotificationSettings: {
        payload: Prisma.$NotificationSettingsPayload<ExtArgs>
        fields: Prisma.NotificationSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          findFirst: {
            args: Prisma.NotificationSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          findMany: {
            args: Prisma.NotificationSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
          }
          create: {
            args: Prisma.NotificationSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          createMany: {
            args: Prisma.NotificationSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
          }
          delete: {
            args: Prisma.NotificationSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          update: {
            args: Prisma.NotificationSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          deleteMany: {
            args: Prisma.NotificationSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>[]
          }
          upsert: {
            args: Prisma.NotificationSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSettingsPayload>
          }
          aggregate: {
            args: Prisma.NotificationSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationSettings>
          }
          groupBy: {
            args: Prisma.NotificationSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationSettingsCountAggregateOutputType> | number
          }
        }
      }
      Author: {
        payload: Prisma.$AuthorPayload<ExtArgs>
        fields: Prisma.AuthorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          findFirst: {
            args: Prisma.AuthorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          findMany: {
            args: Prisma.AuthorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>[]
          }
          create: {
            args: Prisma.AuthorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          createMany: {
            args: Prisma.AuthorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuthorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>[]
          }
          delete: {
            args: Prisma.AuthorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          update: {
            args: Prisma.AuthorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          deleteMany: {
            args: Prisma.AuthorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuthorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuthorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>[]
          }
          upsert: {
            args: Prisma.AuthorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthorPayload>
          }
          aggregate: {
            args: Prisma.AuthorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthor>
          }
          groupBy: {
            args: Prisma.AuthorGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthorGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuthorCountArgs<ExtArgs>
            result: $Utils.Optional<AuthorCountAggregateOutputType> | number
          }
        }
      }
      Novel: {
        payload: Prisma.$NovelPayload<ExtArgs>
        fields: Prisma.NovelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NovelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NovelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelPayload>
          }
          findFirst: {
            args: Prisma.NovelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NovelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelPayload>
          }
          findMany: {
            args: Prisma.NovelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelPayload>[]
          }
          create: {
            args: Prisma.NovelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelPayload>
          }
          createMany: {
            args: Prisma.NovelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NovelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelPayload>[]
          }
          delete: {
            args: Prisma.NovelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelPayload>
          }
          update: {
            args: Prisma.NovelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelPayload>
          }
          deleteMany: {
            args: Prisma.NovelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NovelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NovelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelPayload>[]
          }
          upsert: {
            args: Prisma.NovelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelPayload>
          }
          aggregate: {
            args: Prisma.NovelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNovel>
          }
          groupBy: {
            args: Prisma.NovelGroupByArgs<ExtArgs>
            result: $Utils.Optional<NovelGroupByOutputType>[]
          }
          count: {
            args: Prisma.NovelCountArgs<ExtArgs>
            result: $Utils.Optional<NovelCountAggregateOutputType> | number
          }
        }
      }
      Genre: {
        payload: Prisma.$GenrePayload<ExtArgs>
        fields: Prisma.GenreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GenreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GenreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          findFirst: {
            args: Prisma.GenreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GenreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          findMany: {
            args: Prisma.GenreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[]
          }
          create: {
            args: Prisma.GenreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          createMany: {
            args: Prisma.GenreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GenreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[]
          }
          delete: {
            args: Prisma.GenreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          update: {
            args: Prisma.GenreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          deleteMany: {
            args: Prisma.GenreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GenreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GenreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>[]
          }
          upsert: {
            args: Prisma.GenreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GenrePayload>
          }
          aggregate: {
            args: Prisma.GenreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGenre>
          }
          groupBy: {
            args: Prisma.GenreGroupByArgs<ExtArgs>
            result: $Utils.Optional<GenreGroupByOutputType>[]
          }
          count: {
            args: Prisma.GenreCountArgs<ExtArgs>
            result: $Utils.Optional<GenreCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      TagGroup: {
        payload: Prisma.$TagGroupPayload<ExtArgs>
        fields: Prisma.TagGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagGroupPayload>
          }
          findFirst: {
            args: Prisma.TagGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagGroupPayload>
          }
          findMany: {
            args: Prisma.TagGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagGroupPayload>[]
          }
          create: {
            args: Prisma.TagGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagGroupPayload>
          }
          createMany: {
            args: Prisma.TagGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagGroupPayload>[]
          }
          delete: {
            args: Prisma.TagGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagGroupPayload>
          }
          update: {
            args: Prisma.TagGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagGroupPayload>
          }
          deleteMany: {
            args: Prisma.TagGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagGroupPayload>[]
          }
          upsert: {
            args: Prisma.TagGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagGroupPayload>
          }
          aggregate: {
            args: Prisma.TagGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTagGroup>
          }
          groupBy: {
            args: Prisma.TagGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagGroupCountArgs<ExtArgs>
            result: $Utils.Optional<TagGroupCountAggregateOutputType> | number
          }
        }
      }
      NovelTag: {
        payload: Prisma.$NovelTagPayload<ExtArgs>
        fields: Prisma.NovelTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NovelTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NovelTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelTagPayload>
          }
          findFirst: {
            args: Prisma.NovelTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NovelTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelTagPayload>
          }
          findMany: {
            args: Prisma.NovelTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelTagPayload>[]
          }
          create: {
            args: Prisma.NovelTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelTagPayload>
          }
          createMany: {
            args: Prisma.NovelTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NovelTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelTagPayload>[]
          }
          delete: {
            args: Prisma.NovelTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelTagPayload>
          }
          update: {
            args: Prisma.NovelTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelTagPayload>
          }
          deleteMany: {
            args: Prisma.NovelTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NovelTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NovelTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelTagPayload>[]
          }
          upsert: {
            args: Prisma.NovelTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelTagPayload>
          }
          aggregate: {
            args: Prisma.NovelTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNovelTag>
          }
          groupBy: {
            args: Prisma.NovelTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<NovelTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.NovelTagCountArgs<ExtArgs>
            result: $Utils.Optional<NovelTagCountAggregateOutputType> | number
          }
        }
      }
      Chapter: {
        payload: Prisma.$ChapterPayload<ExtArgs>
        fields: Prisma.ChapterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChapterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChapterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          findFirst: {
            args: Prisma.ChapterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChapterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          findMany: {
            args: Prisma.ChapterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>[]
          }
          create: {
            args: Prisma.ChapterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          createMany: {
            args: Prisma.ChapterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChapterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>[]
          }
          delete: {
            args: Prisma.ChapterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          update: {
            args: Prisma.ChapterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          deleteMany: {
            args: Prisma.ChapterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChapterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChapterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>[]
          }
          upsert: {
            args: Prisma.ChapterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterPayload>
          }
          aggregate: {
            args: Prisma.ChapterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChapter>
          }
          groupBy: {
            args: Prisma.ChapterGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChapterGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChapterCountArgs<ExtArgs>
            result: $Utils.Optional<ChapterCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      ReplyComment: {
        payload: Prisma.$ReplyCommentPayload<ExtArgs>
        fields: Prisma.ReplyCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReplyCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReplyCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyCommentPayload>
          }
          findFirst: {
            args: Prisma.ReplyCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReplyCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyCommentPayload>
          }
          findMany: {
            args: Prisma.ReplyCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyCommentPayload>[]
          }
          create: {
            args: Prisma.ReplyCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyCommentPayload>
          }
          createMany: {
            args: Prisma.ReplyCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReplyCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyCommentPayload>[]
          }
          delete: {
            args: Prisma.ReplyCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyCommentPayload>
          }
          update: {
            args: Prisma.ReplyCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyCommentPayload>
          }
          deleteMany: {
            args: Prisma.ReplyCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReplyCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReplyCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyCommentPayload>[]
          }
          upsert: {
            args: Prisma.ReplyCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReplyCommentPayload>
          }
          aggregate: {
            args: Prisma.ReplyCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReplyComment>
          }
          groupBy: {
            args: Prisma.ReplyCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReplyCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReplyCommentCountArgs<ExtArgs>
            result: $Utils.Optional<ReplyCommentCountAggregateOutputType> | number
          }
        }
      }
      Reading: {
        payload: Prisma.$ReadingPayload<ExtArgs>
        fields: Prisma.ReadingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReadingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReadingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingPayload>
          }
          findFirst: {
            args: Prisma.ReadingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReadingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingPayload>
          }
          findMany: {
            args: Prisma.ReadingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingPayload>[]
          }
          create: {
            args: Prisma.ReadingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingPayload>
          }
          createMany: {
            args: Prisma.ReadingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReadingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingPayload>[]
          }
          delete: {
            args: Prisma.ReadingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingPayload>
          }
          update: {
            args: Prisma.ReadingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingPayload>
          }
          deleteMany: {
            args: Prisma.ReadingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReadingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReadingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingPayload>[]
          }
          upsert: {
            args: Prisma.ReadingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReadingPayload>
          }
          aggregate: {
            args: Prisma.ReadingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReading>
          }
          groupBy: {
            args: Prisma.ReadingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReadingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReadingCountArgs<ExtArgs>
            result: $Utils.Optional<ReadingCountAggregateOutputType> | number
          }
        }
      }
      Favorite: {
        payload: Prisma.$FavoritePayload<ExtArgs>
        fields: Prisma.FavoriteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FavoriteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FavoriteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          findFirst: {
            args: Prisma.FavoriteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FavoriteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          findMany: {
            args: Prisma.FavoriteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          create: {
            args: Prisma.FavoriteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          createMany: {
            args: Prisma.FavoriteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FavoriteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          delete: {
            args: Prisma.FavoriteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          update: {
            args: Prisma.FavoriteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          deleteMany: {
            args: Prisma.FavoriteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FavoriteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FavoriteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>[]
          }
          upsert: {
            args: Prisma.FavoriteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoritePayload>
          }
          aggregate: {
            args: Prisma.FavoriteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFavorite>
          }
          groupBy: {
            args: Prisma.FavoriteGroupByArgs<ExtArgs>
            result: $Utils.Optional<FavoriteGroupByOutputType>[]
          }
          count: {
            args: Prisma.FavoriteCountArgs<ExtArgs>
            result: $Utils.Optional<FavoriteCountAggregateOutputType> | number
          }
        }
      }
      NovelStatistic: {
        payload: Prisma.$NovelStatisticPayload<ExtArgs>
        fields: Prisma.NovelStatisticFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NovelStatisticFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelStatisticPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NovelStatisticFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelStatisticPayload>
          }
          findFirst: {
            args: Prisma.NovelStatisticFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelStatisticPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NovelStatisticFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelStatisticPayload>
          }
          findMany: {
            args: Prisma.NovelStatisticFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelStatisticPayload>[]
          }
          create: {
            args: Prisma.NovelStatisticCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelStatisticPayload>
          }
          createMany: {
            args: Prisma.NovelStatisticCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NovelStatisticCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelStatisticPayload>[]
          }
          delete: {
            args: Prisma.NovelStatisticDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelStatisticPayload>
          }
          update: {
            args: Prisma.NovelStatisticUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelStatisticPayload>
          }
          deleteMany: {
            args: Prisma.NovelStatisticDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NovelStatisticUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NovelStatisticUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelStatisticPayload>[]
          }
          upsert: {
            args: Prisma.NovelStatisticUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NovelStatisticPayload>
          }
          aggregate: {
            args: Prisma.NovelStatisticAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNovelStatistic>
          }
          groupBy: {
            args: Prisma.NovelStatisticGroupByArgs<ExtArgs>
            result: $Utils.Optional<NovelStatisticGroupByOutputType>[]
          }
          count: {
            args: Prisma.NovelStatisticCountArgs<ExtArgs>
            result: $Utils.Optional<NovelStatisticCountAggregateOutputType> | number
          }
        }
      }
      ChapterStatistic: {
        payload: Prisma.$ChapterStatisticPayload<ExtArgs>
        fields: Prisma.ChapterStatisticFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChapterStatisticFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterStatisticPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChapterStatisticFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterStatisticPayload>
          }
          findFirst: {
            args: Prisma.ChapterStatisticFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterStatisticPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChapterStatisticFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterStatisticPayload>
          }
          findMany: {
            args: Prisma.ChapterStatisticFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterStatisticPayload>[]
          }
          create: {
            args: Prisma.ChapterStatisticCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterStatisticPayload>
          }
          createMany: {
            args: Prisma.ChapterStatisticCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChapterStatisticCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterStatisticPayload>[]
          }
          delete: {
            args: Prisma.ChapterStatisticDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterStatisticPayload>
          }
          update: {
            args: Prisma.ChapterStatisticUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterStatisticPayload>
          }
          deleteMany: {
            args: Prisma.ChapterStatisticDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChapterStatisticUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChapterStatisticUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterStatisticPayload>[]
          }
          upsert: {
            args: Prisma.ChapterStatisticUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChapterStatisticPayload>
          }
          aggregate: {
            args: Prisma.ChapterStatisticAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChapterStatistic>
          }
          groupBy: {
            args: Prisma.ChapterStatisticGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChapterStatisticGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChapterStatisticCountArgs<ExtArgs>
            result: $Utils.Optional<ChapterStatisticCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    refreshToken?: RefreshTokenOmit
    notificationSettings?: NotificationSettingsOmit
    author?: AuthorOmit
    novel?: NovelOmit
    genre?: GenreOmit
    tag?: TagOmit
    tagGroup?: TagGroupOmit
    novelTag?: NovelTagOmit
    chapter?: ChapterOmit
    review?: ReviewOmit
    comment?: CommentOmit
    replyComment?: ReplyCommentOmit
    reading?: ReadingOmit
    favorite?: FavoriteOmit
    novelStatistic?: NovelStatisticOmit
    chapterStatistic?: ChapterStatisticOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    reviews: number
    comments: number
    authoredNovels: number
    sessions: number
    readings: number
    favorites: number
    replies: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    authoredNovels?: boolean | UserCountOutputTypeCountAuthoredNovelsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    readings?: boolean | UserCountOutputTypeCountReadingsArgs
    favorites?: boolean | UserCountOutputTypeCountFavoritesArgs
    replies?: boolean | UserCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuthoredNovelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NovelWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReadingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReadingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReplyCommentWhereInput
  }


  /**
   * Count Type AuthorCountOutputType
   */

  export type AuthorCountOutputType = {
    novels: number
  }

  export type AuthorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    novels?: boolean | AuthorCountOutputTypeCountNovelsArgs
  }

  // Custom InputTypes
  /**
   * AuthorCountOutputType without action
   */
  export type AuthorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorCountOutputType
     */
    select?: AuthorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuthorCountOutputType without action
   */
  export type AuthorCountOutputTypeCountNovelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NovelWhereInput
  }


  /**
   * Count Type NovelCountOutputType
   */

  export type NovelCountOutputType = {
    chapters: number
    novelTags: number
    reviews: number
    statistics: number
    readers: number
    favorites: number
    comments: number
  }

  export type NovelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapters?: boolean | NovelCountOutputTypeCountChaptersArgs
    novelTags?: boolean | NovelCountOutputTypeCountNovelTagsArgs
    reviews?: boolean | NovelCountOutputTypeCountReviewsArgs
    statistics?: boolean | NovelCountOutputTypeCountStatisticsArgs
    readers?: boolean | NovelCountOutputTypeCountReadersArgs
    favorites?: boolean | NovelCountOutputTypeCountFavoritesArgs
    comments?: boolean | NovelCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * NovelCountOutputType without action
   */
  export type NovelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelCountOutputType
     */
    select?: NovelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NovelCountOutputType without action
   */
  export type NovelCountOutputTypeCountChaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterWhereInput
  }

  /**
   * NovelCountOutputType without action
   */
  export type NovelCountOutputTypeCountNovelTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NovelTagWhereInput
  }

  /**
   * NovelCountOutputType without action
   */
  export type NovelCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * NovelCountOutputType without action
   */
  export type NovelCountOutputTypeCountStatisticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NovelStatisticWhereInput
  }

  /**
   * NovelCountOutputType without action
   */
  export type NovelCountOutputTypeCountReadersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReadingWhereInput
  }

  /**
   * NovelCountOutputType without action
   */
  export type NovelCountOutputTypeCountFavoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
  }

  /**
   * NovelCountOutputType without action
   */
  export type NovelCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type GenreCountOutputType
   */

  export type GenreCountOutputType = {
    novels: number
  }

  export type GenreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    novels?: boolean | GenreCountOutputTypeCountNovelsArgs
  }

  // Custom InputTypes
  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GenreCountOutputType
     */
    select?: GenreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GenreCountOutputType without action
   */
  export type GenreCountOutputTypeCountNovelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NovelWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    novels: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    novels?: boolean | TagCountOutputTypeCountNovelsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountNovelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NovelTagWhereInput
  }


  /**
   * Count Type TagGroupCountOutputType
   */

  export type TagGroupCountOutputType = {
    tags: number
  }

  export type TagGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | TagGroupCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * TagGroupCountOutputType without action
   */
  export type TagGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagGroupCountOutputType
     */
    select?: TagGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagGroupCountOutputType without action
   */
  export type TagGroupCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }


  /**
   * Count Type ChapterCountOutputType
   */

  export type ChapterCountOutputType = {
    comments: number
    statistics: number
    reading: number
  }

  export type ChapterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | ChapterCountOutputTypeCountCommentsArgs
    statistics?: boolean | ChapterCountOutputTypeCountStatisticsArgs
    reading?: boolean | ChapterCountOutputTypeCountReadingArgs
  }

  // Custom InputTypes
  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterCountOutputType
     */
    select?: ChapterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeCountStatisticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterStatisticWhereInput
  }

  /**
   * ChapterCountOutputType without action
   */
  export type ChapterCountOutputTypeCountReadingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReadingWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    replies: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | CommentCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReplyCommentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    keys: number | null
    tickets: number | null
    candies: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    keys: number | null
    tickets: number | null
    candies: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    nickname: string | null
    email: string | null
    password: string | null
    phone: string | null
    avatar: string | null
    coverImage: string | null
    role: $Enums.UserRole | null
    gender: $Enums.Gender | null
    bio: string | null
    birthDate: Date | null
    keys: number | null
    tickets: number | null
    candies: number | null
    createdAt: Date | null
    emailVerifiedAt: Date | null
    isTwoFactorAuth: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    nickname: string | null
    email: string | null
    password: string | null
    phone: string | null
    avatar: string | null
    coverImage: string | null
    role: $Enums.UserRole | null
    gender: $Enums.Gender | null
    bio: string | null
    birthDate: Date | null
    keys: number | null
    tickets: number | null
    candies: number | null
    createdAt: Date | null
    emailVerifiedAt: Date | null
    isTwoFactorAuth: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    nickname: number
    email: number
    password: number
    phone: number
    avatar: number
    coverImage: number
    role: number
    gender: number
    bio: number
    birthDate: number
    socialLinks: number
    keys: number
    tickets: number
    candies: number
    createdAt: number
    emailVerifiedAt: number
    isTwoFactorAuth: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    keys?: true
    tickets?: true
    candies?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    keys?: true
    tickets?: true
    candies?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    nickname?: true
    email?: true
    password?: true
    phone?: true
    avatar?: true
    coverImage?: true
    role?: true
    gender?: true
    bio?: true
    birthDate?: true
    keys?: true
    tickets?: true
    candies?: true
    createdAt?: true
    emailVerifiedAt?: true
    isTwoFactorAuth?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    nickname?: true
    email?: true
    password?: true
    phone?: true
    avatar?: true
    coverImage?: true
    role?: true
    gender?: true
    bio?: true
    birthDate?: true
    keys?: true
    tickets?: true
    candies?: true
    createdAt?: true
    emailVerifiedAt?: true
    isTwoFactorAuth?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    nickname?: true
    email?: true
    password?: true
    phone?: true
    avatar?: true
    coverImage?: true
    role?: true
    gender?: true
    bio?: true
    birthDate?: true
    socialLinks?: true
    keys?: true
    tickets?: true
    candies?: true
    createdAt?: true
    emailVerifiedAt?: true
    isTwoFactorAuth?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    nickname: string
    email: string
    password: string | null
    phone: string
    avatar: string
    coverImage: string
    role: $Enums.UserRole
    gender: $Enums.Gender
    bio: string
    birthDate: Date
    socialLinks: string[]
    keys: number
    tickets: number
    candies: number
    createdAt: Date
    emailVerifiedAt: Date | null
    isTwoFactorAuth: boolean
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nickname?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    avatar?: boolean
    coverImage?: boolean
    role?: boolean
    gender?: boolean
    bio?: boolean
    birthDate?: boolean
    socialLinks?: boolean
    keys?: boolean
    tickets?: boolean
    candies?: boolean
    createdAt?: boolean
    emailVerifiedAt?: boolean
    isTwoFactorAuth?: boolean
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    authoredNovels?: boolean | User$authoredNovelsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    readings?: boolean | User$readingsArgs<ExtArgs>
    favorites?: boolean | User$favoritesArgs<ExtArgs>
    replies?: boolean | User$repliesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nickname?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    avatar?: boolean
    coverImage?: boolean
    role?: boolean
    gender?: boolean
    bio?: boolean
    birthDate?: boolean
    socialLinks?: boolean
    keys?: boolean
    tickets?: boolean
    candies?: boolean
    createdAt?: boolean
    emailVerifiedAt?: boolean
    isTwoFactorAuth?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nickname?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    avatar?: boolean
    coverImage?: boolean
    role?: boolean
    gender?: boolean
    bio?: boolean
    birthDate?: boolean
    socialLinks?: boolean
    keys?: boolean
    tickets?: boolean
    candies?: boolean
    createdAt?: boolean
    emailVerifiedAt?: boolean
    isTwoFactorAuth?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    nickname?: boolean
    email?: boolean
    password?: boolean
    phone?: boolean
    avatar?: boolean
    coverImage?: boolean
    role?: boolean
    gender?: boolean
    bio?: boolean
    birthDate?: boolean
    socialLinks?: boolean
    keys?: boolean
    tickets?: boolean
    candies?: boolean
    createdAt?: boolean
    emailVerifiedAt?: boolean
    isTwoFactorAuth?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nickname" | "email" | "password" | "phone" | "avatar" | "coverImage" | "role" | "gender" | "bio" | "birthDate" | "socialLinks" | "keys" | "tickets" | "candies" | "createdAt" | "emailVerifiedAt" | "isTwoFactorAuth", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    authoredNovels?: boolean | User$authoredNovelsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    readings?: boolean | User$readingsArgs<ExtArgs>
    favorites?: boolean | User$favoritesArgs<ExtArgs>
    replies?: boolean | User$repliesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      notifications: Prisma.$NotificationSettingsPayload<ExtArgs> | null
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      authoredNovels: Prisma.$NovelPayload<ExtArgs>[]
      sessions: Prisma.$RefreshTokenPayload<ExtArgs>[]
      readings: Prisma.$ReadingPayload<ExtArgs>[]
      favorites: Prisma.$FavoritePayload<ExtArgs>[]
      replies: Prisma.$ReplyCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nickname: string
      email: string
      password: string | null
      phone: string
      avatar: string
      coverImage: string
      role: $Enums.UserRole
      gender: $Enums.Gender
      bio: string
      birthDate: Date
      socialLinks: string[]
      keys: number
      tickets: number
      candies: number
      createdAt: Date
      emailVerifiedAt: Date | null
      isTwoFactorAuth: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    authoredNovels<T extends User$authoredNovelsArgs<ExtArgs> = {}>(args?: Subset<T, User$authoredNovelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NovelPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    readings<T extends User$readingsArgs<ExtArgs> = {}>(args?: Subset<T, User$readingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReadingPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    favorites<T extends User$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, User$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    replies<T extends User$repliesArgs<ExtArgs> = {}>(args?: Subset<T, User$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReplyCommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly nickname: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly coverImage: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly gender: FieldRef<"User", 'Gender'>
    readonly bio: FieldRef<"User", 'String'>
    readonly birthDate: FieldRef<"User", 'DateTime'>
    readonly socialLinks: FieldRef<"User", 'String[]'>
    readonly keys: FieldRef<"User", 'Int'>
    readonly tickets: FieldRef<"User", 'Int'>
    readonly candies: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly emailVerifiedAt: FieldRef<"User", 'DateTime'>
    readonly isTwoFactorAuth: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    where?: NotificationSettingsWhereInput
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.authoredNovels
   */
  export type User$authoredNovelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Novel
     */
    select?: NovelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Novel
     */
    omit?: NovelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelInclude<ExtArgs> | null
    where?: NovelWhereInput
    orderBy?: NovelOrderByWithRelationInput | NovelOrderByWithRelationInput[]
    cursor?: NovelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NovelScalarFieldEnum | NovelScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.readings
   */
  export type User$readingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading
     */
    select?: ReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading
     */
    omit?: ReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingInclude<ExtArgs> | null
    where?: ReadingWhereInput
    orderBy?: ReadingOrderByWithRelationInput | ReadingOrderByWithRelationInput[]
    cursor?: ReadingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReadingScalarFieldEnum | ReadingScalarFieldEnum[]
  }

  /**
   * User.favorites
   */
  export type User$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    cursor?: FavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * User.replies
   */
  export type User$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReplyComment
     */
    select?: ReplyCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReplyComment
     */
    omit?: ReplyCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyCommentInclude<ExtArgs> | null
    where?: ReplyCommentWhereInput
    orderBy?: ReplyCommentOrderByWithRelationInput | ReplyCommentOrderByWithRelationInput[]
    cursor?: ReplyCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReplyCommentScalarFieldEnum | ReplyCommentScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _avg: RefreshTokenAvgAggregateOutputType | null
    _sum: RefreshTokenSumAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenAvgAggregateOutputType = {
    userId: number | null
  }

  export type RefreshTokenSumAggregateOutputType = {
    userId: number | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    token: string | null
    userId: number | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    token: string | null
    userId: number | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    token: number
    userId: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type RefreshTokenAvgAggregateInputType = {
    userId?: true
  }

  export type RefreshTokenSumAggregateInputType = {
    userId?: true
  }

  export type RefreshTokenMinAggregateInputType = {
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefreshTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefreshTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _avg?: RefreshTokenAvgAggregateInputType
    _sum?: RefreshTokenSumAggregateInputType
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    token: string
    userId: number
    expiresAt: Date
    createdAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _avg: RefreshTokenAvgAggregateOutputType | null
    _sum: RefreshTokenSumAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"token" | "userId" | "expiresAt" | "createdAt", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      token: string
      userId: number
      expiresAt: Date
      createdAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `token`
     * const refreshTokenWithTokenOnly = await prisma.refreshToken.findMany({ select: { token: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `token`
     * const refreshTokenWithTokenOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { token: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `token`
     * const refreshTokenWithTokenOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { token: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */ 
  interface RefreshTokenFieldRefs {
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'Int'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model NotificationSettings
   */

  export type AggregateNotificationSettings = {
    _count: NotificationSettingsCountAggregateOutputType | null
    _avg: NotificationSettingsAvgAggregateOutputType | null
    _sum: NotificationSettingsSumAggregateOutputType | null
    _min: NotificationSettingsMinAggregateOutputType | null
    _max: NotificationSettingsMaxAggregateOutputType | null
  }

  export type NotificationSettingsAvgAggregateOutputType = {
    userId: number | null
  }

  export type NotificationSettingsSumAggregateOutputType = {
    userId: number | null
  }

  export type NotificationSettingsMinAggregateOutputType = {
    userId: number | null
    enableNewChapter: boolean | null
    enableInteractions: boolean | null
  }

  export type NotificationSettingsMaxAggregateOutputType = {
    userId: number | null
    enableNewChapter: boolean | null
    enableInteractions: boolean | null
  }

  export type NotificationSettingsCountAggregateOutputType = {
    userId: number
    enableNewChapter: number
    enableInteractions: number
    _all: number
  }


  export type NotificationSettingsAvgAggregateInputType = {
    userId?: true
  }

  export type NotificationSettingsSumAggregateInputType = {
    userId?: true
  }

  export type NotificationSettingsMinAggregateInputType = {
    userId?: true
    enableNewChapter?: true
    enableInteractions?: true
  }

  export type NotificationSettingsMaxAggregateInputType = {
    userId?: true
    enableNewChapter?: true
    enableInteractions?: true
  }

  export type NotificationSettingsCountAggregateInputType = {
    userId?: true
    enableNewChapter?: true
    enableInteractions?: true
    _all?: true
  }

  export type NotificationSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSettings to aggregate.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationSettings
    **/
    _count?: true | NotificationSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationSettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationSettingsMaxAggregateInputType
  }

  export type GetNotificationSettingsAggregateType<T extends NotificationSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationSettings[P]>
      : GetScalarType<T[P], AggregateNotificationSettings[P]>
  }




  export type NotificationSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationSettingsWhereInput
    orderBy?: NotificationSettingsOrderByWithAggregationInput | NotificationSettingsOrderByWithAggregationInput[]
    by: NotificationSettingsScalarFieldEnum[] | NotificationSettingsScalarFieldEnum
    having?: NotificationSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationSettingsCountAggregateInputType | true
    _avg?: NotificationSettingsAvgAggregateInputType
    _sum?: NotificationSettingsSumAggregateInputType
    _min?: NotificationSettingsMinAggregateInputType
    _max?: NotificationSettingsMaxAggregateInputType
  }

  export type NotificationSettingsGroupByOutputType = {
    userId: number
    enableNewChapter: boolean
    enableInteractions: boolean
    _count: NotificationSettingsCountAggregateOutputType | null
    _avg: NotificationSettingsAvgAggregateOutputType | null
    _sum: NotificationSettingsSumAggregateOutputType | null
    _min: NotificationSettingsMinAggregateOutputType | null
    _max: NotificationSettingsMaxAggregateOutputType | null
  }

  type GetNotificationSettingsGroupByPayload<T extends NotificationSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationSettingsGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    enableNewChapter?: boolean
    enableInteractions?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSettings"]>

  export type NotificationSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    enableNewChapter?: boolean
    enableInteractions?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSettings"]>

  export type NotificationSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    enableNewChapter?: boolean
    enableInteractions?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSettings"]>

  export type NotificationSettingsSelectScalar = {
    userId?: boolean
    enableNewChapter?: boolean
    enableInteractions?: boolean
  }

  export type NotificationSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "enableNewChapter" | "enableInteractions", ExtArgs["result"]["notificationSettings"]>
  export type NotificationSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      enableNewChapter: boolean
      enableInteractions: boolean
    }, ExtArgs["result"]["notificationSettings"]>
    composites: {}
  }

  type NotificationSettingsGetPayload<S extends boolean | null | undefined | NotificationSettingsDefaultArgs> = $Result.GetResult<Prisma.$NotificationSettingsPayload, S>

  type NotificationSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationSettingsCountAggregateInputType | true
    }

  export interface NotificationSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationSettings'], meta: { name: 'NotificationSettings' } }
    /**
     * Find zero or one NotificationSettings that matches the filter.
     * @param {NotificationSettingsFindUniqueArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationSettingsFindUniqueArgs>(args: SelectSubset<T, NotificationSettingsFindUniqueArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one NotificationSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationSettingsFindUniqueOrThrowArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first NotificationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindFirstArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationSettingsFindFirstArgs>(args?: SelectSubset<T, NotificationSettingsFindFirstArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first NotificationSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindFirstOrThrowArgs} args - Arguments to find a NotificationSettings
     * @example
     * // Get one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more NotificationSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findMany()
     * 
     * // Get first 10 NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const notificationSettingsWithUserIdOnly = await prisma.notificationSettings.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends NotificationSettingsFindManyArgs>(args?: SelectSubset<T, NotificationSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a NotificationSettings.
     * @param {NotificationSettingsCreateArgs} args - Arguments to create a NotificationSettings.
     * @example
     * // Create one NotificationSettings
     * const NotificationSettings = await prisma.notificationSettings.create({
     *   data: {
     *     // ... data to create a NotificationSettings
     *   }
     * })
     * 
     */
    create<T extends NotificationSettingsCreateArgs>(args: SelectSubset<T, NotificationSettingsCreateArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many NotificationSettings.
     * @param {NotificationSettingsCreateManyArgs} args - Arguments to create many NotificationSettings.
     * @example
     * // Create many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationSettingsCreateManyArgs>(args?: SelectSubset<T, NotificationSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationSettings and returns the data saved in the database.
     * @param {NotificationSettingsCreateManyAndReturnArgs} args - Arguments to create many NotificationSettings.
     * @example
     * // Create many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationSettings and only return the `userId`
     * const notificationSettingsWithUserIdOnly = await prisma.notificationSettings.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a NotificationSettings.
     * @param {NotificationSettingsDeleteArgs} args - Arguments to delete one NotificationSettings.
     * @example
     * // Delete one NotificationSettings
     * const NotificationSettings = await prisma.notificationSettings.delete({
     *   where: {
     *     // ... filter to delete one NotificationSettings
     *   }
     * })
     * 
     */
    delete<T extends NotificationSettingsDeleteArgs>(args: SelectSubset<T, NotificationSettingsDeleteArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one NotificationSettings.
     * @param {NotificationSettingsUpdateArgs} args - Arguments to update one NotificationSettings.
     * @example
     * // Update one NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationSettingsUpdateArgs>(args: SelectSubset<T, NotificationSettingsUpdateArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more NotificationSettings.
     * @param {NotificationSettingsDeleteManyArgs} args - Arguments to filter NotificationSettings to delete.
     * @example
     * // Delete a few NotificationSettings
     * const { count } = await prisma.notificationSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationSettingsDeleteManyArgs>(args?: SelectSubset<T, NotificationSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationSettingsUpdateManyArgs>(args: SelectSubset<T, NotificationSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationSettings and returns the data updated in the database.
     * @param {NotificationSettingsUpdateManyAndReturnArgs} args - Arguments to update many NotificationSettings.
     * @example
     * // Update many NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationSettings and only return the `userId`
     * const notificationSettingsWithUserIdOnly = await prisma.notificationSettings.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one NotificationSettings.
     * @param {NotificationSettingsUpsertArgs} args - Arguments to update or create a NotificationSettings.
     * @example
     * // Update or create a NotificationSettings
     * const notificationSettings = await prisma.notificationSettings.upsert({
     *   create: {
     *     // ... data to create a NotificationSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationSettings we want to update
     *   }
     * })
     */
    upsert<T extends NotificationSettingsUpsertArgs>(args: SelectSubset<T, NotificationSettingsUpsertArgs<ExtArgs>>): Prisma__NotificationSettingsClient<$Result.GetResult<Prisma.$NotificationSettingsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsCountArgs} args - Arguments to filter NotificationSettings to count.
     * @example
     * // Count the number of NotificationSettings
     * const count = await prisma.notificationSettings.count({
     *   where: {
     *     // ... the filter for the NotificationSettings we want to count
     *   }
     * })
    **/
    count<T extends NotificationSettingsCountArgs>(
      args?: Subset<T, NotificationSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationSettingsAggregateArgs>(args: Subset<T, NotificationSettingsAggregateArgs>): Prisma.PrismaPromise<GetNotificationSettingsAggregateType<T>>

    /**
     * Group by NotificationSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationSettingsGroupByArgs['orderBy'] }
        : { orderBy?: NotificationSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationSettings model
   */
  readonly fields: NotificationSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationSettings model
   */ 
  interface NotificationSettingsFieldRefs {
    readonly userId: FieldRef<"NotificationSettings", 'Int'>
    readonly enableNewChapter: FieldRef<"NotificationSettings", 'Boolean'>
    readonly enableInteractions: FieldRef<"NotificationSettings", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * NotificationSettings findUnique
   */
  export type NotificationSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings findUniqueOrThrow
   */
  export type NotificationSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings findFirst
   */
  export type NotificationSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSettings.
     */
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings findFirstOrThrow
   */
  export type NotificationSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSettings.
     */
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings findMany
   */
  export type NotificationSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSettings to fetch.
     */
    where?: NotificationSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSettings to fetch.
     */
    orderBy?: NotificationSettingsOrderByWithRelationInput | NotificationSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationSettings.
     */
    cursor?: NotificationSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSettings.
     */
    skip?: number
    distinct?: NotificationSettingsScalarFieldEnum | NotificationSettingsScalarFieldEnum[]
  }

  /**
   * NotificationSettings create
   */
  export type NotificationSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationSettings.
     */
    data: XOR<NotificationSettingsCreateInput, NotificationSettingsUncheckedCreateInput>
  }

  /**
   * NotificationSettings createMany
   */
  export type NotificationSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationSettings.
     */
    data: NotificationSettingsCreateManyInput | NotificationSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationSettings createManyAndReturn
   */
  export type NotificationSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationSettings.
     */
    data: NotificationSettingsCreateManyInput | NotificationSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationSettings update
   */
  export type NotificationSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationSettings.
     */
    data: XOR<NotificationSettingsUpdateInput, NotificationSettingsUncheckedUpdateInput>
    /**
     * Choose, which NotificationSettings to update.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings updateMany
   */
  export type NotificationSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationSettings.
     */
    data: XOR<NotificationSettingsUpdateManyMutationInput, NotificationSettingsUncheckedUpdateManyInput>
    /**
     * Filter which NotificationSettings to update
     */
    where?: NotificationSettingsWhereInput
    /**
     * Limit how many NotificationSettings to update.
     */
    limit?: number
  }

  /**
   * NotificationSettings updateManyAndReturn
   */
  export type NotificationSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * The data used to update NotificationSettings.
     */
    data: XOR<NotificationSettingsUpdateManyMutationInput, NotificationSettingsUncheckedUpdateManyInput>
    /**
     * Filter which NotificationSettings to update
     */
    where?: NotificationSettingsWhereInput
    /**
     * Limit how many NotificationSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationSettings upsert
   */
  export type NotificationSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationSettings to update in case it exists.
     */
    where: NotificationSettingsWhereUniqueInput
    /**
     * In case the NotificationSettings found by the `where` argument doesn't exist, create a new NotificationSettings with this data.
     */
    create: XOR<NotificationSettingsCreateInput, NotificationSettingsUncheckedCreateInput>
    /**
     * In case the NotificationSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationSettingsUpdateInput, NotificationSettingsUncheckedUpdateInput>
  }

  /**
   * NotificationSettings delete
   */
  export type NotificationSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
    /**
     * Filter which NotificationSettings to delete.
     */
    where: NotificationSettingsWhereUniqueInput
  }

  /**
   * NotificationSettings deleteMany
   */
  export type NotificationSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSettings to delete
     */
    where?: NotificationSettingsWhereInput
    /**
     * Limit how many NotificationSettings to delete.
     */
    limit?: number
  }

  /**
   * NotificationSettings without action
   */
  export type NotificationSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSettings
     */
    select?: NotificationSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSettings
     */
    omit?: NotificationSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSettingsInclude<ExtArgs> | null
  }


  /**
   * Model Author
   */

  export type AggregateAuthor = {
    _count: AuthorCountAggregateOutputType | null
    _avg: AuthorAvgAggregateOutputType | null
    _sum: AuthorSumAggregateOutputType | null
    _min: AuthorMinAggregateOutputType | null
    _max: AuthorMaxAggregateOutputType | null
  }

  export type AuthorAvgAggregateOutputType = {
    id: number | null
  }

  export type AuthorSumAggregateOutputType = {
    id: number | null
  }

  export type AuthorMinAggregateOutputType = {
    id: number | null
    name: string | null
    originalName: string | null
    country: string | null
  }

  export type AuthorMaxAggregateOutputType = {
    id: number | null
    name: string | null
    originalName: string | null
    country: string | null
  }

  export type AuthorCountAggregateOutputType = {
    id: number
    name: number
    originalName: number
    country: number
    _all: number
  }


  export type AuthorAvgAggregateInputType = {
    id?: true
  }

  export type AuthorSumAggregateInputType = {
    id?: true
  }

  export type AuthorMinAggregateInputType = {
    id?: true
    name?: true
    originalName?: true
    country?: true
  }

  export type AuthorMaxAggregateInputType = {
    id?: true
    name?: true
    originalName?: true
    country?: true
  }

  export type AuthorCountAggregateInputType = {
    id?: true
    name?: true
    originalName?: true
    country?: true
    _all?: true
  }

  export type AuthorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Author to aggregate.
     */
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorOrderByWithRelationInput | AuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Authors
    **/
    _count?: true | AuthorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuthorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuthorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthorMaxAggregateInputType
  }

  export type GetAuthorAggregateType<T extends AuthorAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthor[P]>
      : GetScalarType<T[P], AggregateAuthor[P]>
  }




  export type AuthorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthorWhereInput
    orderBy?: AuthorOrderByWithAggregationInput | AuthorOrderByWithAggregationInput[]
    by: AuthorScalarFieldEnum[] | AuthorScalarFieldEnum
    having?: AuthorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthorCountAggregateInputType | true
    _avg?: AuthorAvgAggregateInputType
    _sum?: AuthorSumAggregateInputType
    _min?: AuthorMinAggregateInputType
    _max?: AuthorMaxAggregateInputType
  }

  export type AuthorGroupByOutputType = {
    id: number
    name: string
    originalName: string
    country: string
    _count: AuthorCountAggregateOutputType | null
    _avg: AuthorAvgAggregateOutputType | null
    _sum: AuthorSumAggregateOutputType | null
    _min: AuthorMinAggregateOutputType | null
    _max: AuthorMaxAggregateOutputType | null
  }

  type GetAuthorGroupByPayload<T extends AuthorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthorGroupByOutputType[P]>
            : GetScalarType<T[P], AuthorGroupByOutputType[P]>
        }
      >
    >


  export type AuthorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    originalName?: boolean
    country?: boolean
    novels?: boolean | Author$novelsArgs<ExtArgs>
    _count?: boolean | AuthorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["author"]>

  export type AuthorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    originalName?: boolean
    country?: boolean
  }, ExtArgs["result"]["author"]>

  export type AuthorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    originalName?: boolean
    country?: boolean
  }, ExtArgs["result"]["author"]>

  export type AuthorSelectScalar = {
    id?: boolean
    name?: boolean
    originalName?: boolean
    country?: boolean
  }

  export type AuthorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "originalName" | "country", ExtArgs["result"]["author"]>
  export type AuthorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    novels?: boolean | Author$novelsArgs<ExtArgs>
    _count?: boolean | AuthorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AuthorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AuthorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AuthorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Author"
    objects: {
      novels: Prisma.$NovelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      originalName: string
      country: string
    }, ExtArgs["result"]["author"]>
    composites: {}
  }

  type AuthorGetPayload<S extends boolean | null | undefined | AuthorDefaultArgs> = $Result.GetResult<Prisma.$AuthorPayload, S>

  type AuthorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuthorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuthorCountAggregateInputType | true
    }

  export interface AuthorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Author'], meta: { name: 'Author' } }
    /**
     * Find zero or one Author that matches the filter.
     * @param {AuthorFindUniqueArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuthorFindUniqueArgs>(args: SelectSubset<T, AuthorFindUniqueArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Author that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuthorFindUniqueOrThrowArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuthorFindUniqueOrThrowArgs>(args: SelectSubset<T, AuthorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Author that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorFindFirstArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuthorFindFirstArgs>(args?: SelectSubset<T, AuthorFindFirstArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Author that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorFindFirstOrThrowArgs} args - Arguments to find a Author
     * @example
     * // Get one Author
     * const author = await prisma.author.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuthorFindFirstOrThrowArgs>(args?: SelectSubset<T, AuthorFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Authors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Authors
     * const authors = await prisma.author.findMany()
     * 
     * // Get first 10 Authors
     * const authors = await prisma.author.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authorWithIdOnly = await prisma.author.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuthorFindManyArgs>(args?: SelectSubset<T, AuthorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Author.
     * @param {AuthorCreateArgs} args - Arguments to create a Author.
     * @example
     * // Create one Author
     * const Author = await prisma.author.create({
     *   data: {
     *     // ... data to create a Author
     *   }
     * })
     * 
     */
    create<T extends AuthorCreateArgs>(args: SelectSubset<T, AuthorCreateArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Authors.
     * @param {AuthorCreateManyArgs} args - Arguments to create many Authors.
     * @example
     * // Create many Authors
     * const author = await prisma.author.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuthorCreateManyArgs>(args?: SelectSubset<T, AuthorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Authors and returns the data saved in the database.
     * @param {AuthorCreateManyAndReturnArgs} args - Arguments to create many Authors.
     * @example
     * // Create many Authors
     * const author = await prisma.author.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Authors and only return the `id`
     * const authorWithIdOnly = await prisma.author.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuthorCreateManyAndReturnArgs>(args?: SelectSubset<T, AuthorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Author.
     * @param {AuthorDeleteArgs} args - Arguments to delete one Author.
     * @example
     * // Delete one Author
     * const Author = await prisma.author.delete({
     *   where: {
     *     // ... filter to delete one Author
     *   }
     * })
     * 
     */
    delete<T extends AuthorDeleteArgs>(args: SelectSubset<T, AuthorDeleteArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Author.
     * @param {AuthorUpdateArgs} args - Arguments to update one Author.
     * @example
     * // Update one Author
     * const author = await prisma.author.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuthorUpdateArgs>(args: SelectSubset<T, AuthorUpdateArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Authors.
     * @param {AuthorDeleteManyArgs} args - Arguments to filter Authors to delete.
     * @example
     * // Delete a few Authors
     * const { count } = await prisma.author.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuthorDeleteManyArgs>(args?: SelectSubset<T, AuthorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Authors
     * const author = await prisma.author.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuthorUpdateManyArgs>(args: SelectSubset<T, AuthorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authors and returns the data updated in the database.
     * @param {AuthorUpdateManyAndReturnArgs} args - Arguments to update many Authors.
     * @example
     * // Update many Authors
     * const author = await prisma.author.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Authors and only return the `id`
     * const authorWithIdOnly = await prisma.author.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuthorUpdateManyAndReturnArgs>(args: SelectSubset<T, AuthorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Author.
     * @param {AuthorUpsertArgs} args - Arguments to update or create a Author.
     * @example
     * // Update or create a Author
     * const author = await prisma.author.upsert({
     *   create: {
     *     // ... data to create a Author
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Author we want to update
     *   }
     * })
     */
    upsert<T extends AuthorUpsertArgs>(args: SelectSubset<T, AuthorUpsertArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorCountArgs} args - Arguments to filter Authors to count.
     * @example
     * // Count the number of Authors
     * const count = await prisma.author.count({
     *   where: {
     *     // ... the filter for the Authors we want to count
     *   }
     * })
    **/
    count<T extends AuthorCountArgs>(
      args?: Subset<T, AuthorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Author.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthorAggregateArgs>(args: Subset<T, AuthorAggregateArgs>): Prisma.PrismaPromise<GetAuthorAggregateType<T>>

    /**
     * Group by Author.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthorGroupByArgs['orderBy'] }
        : { orderBy?: AuthorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Author model
   */
  readonly fields: AuthorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Author.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    novels<T extends Author$novelsArgs<ExtArgs> = {}>(args?: Subset<T, Author$novelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NovelPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Author model
   */ 
  interface AuthorFieldRefs {
    readonly id: FieldRef<"Author", 'Int'>
    readonly name: FieldRef<"Author", 'String'>
    readonly originalName: FieldRef<"Author", 'String'>
    readonly country: FieldRef<"Author", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Author findUnique
   */
  export type AuthorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter, which Author to fetch.
     */
    where: AuthorWhereUniqueInput
  }

  /**
   * Author findUniqueOrThrow
   */
  export type AuthorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter, which Author to fetch.
     */
    where: AuthorWhereUniqueInput
  }

  /**
   * Author findFirst
   */
  export type AuthorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter, which Author to fetch.
     */
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorOrderByWithRelationInput | AuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authors.
     */
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authors.
     */
    distinct?: AuthorScalarFieldEnum | AuthorScalarFieldEnum[]
  }

  /**
   * Author findFirstOrThrow
   */
  export type AuthorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter, which Author to fetch.
     */
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorOrderByWithRelationInput | AuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Authors.
     */
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Authors.
     */
    distinct?: AuthorScalarFieldEnum | AuthorScalarFieldEnum[]
  }

  /**
   * Author findMany
   */
  export type AuthorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter, which Authors to fetch.
     */
    where?: AuthorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Authors to fetch.
     */
    orderBy?: AuthorOrderByWithRelationInput | AuthorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Authors.
     */
    cursor?: AuthorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Authors.
     */
    skip?: number
    distinct?: AuthorScalarFieldEnum | AuthorScalarFieldEnum[]
  }

  /**
   * Author create
   */
  export type AuthorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * The data needed to create a Author.
     */
    data: XOR<AuthorCreateInput, AuthorUncheckedCreateInput>
  }

  /**
   * Author createMany
   */
  export type AuthorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Authors.
     */
    data: AuthorCreateManyInput | AuthorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Author createManyAndReturn
   */
  export type AuthorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * The data used to create many Authors.
     */
    data: AuthorCreateManyInput | AuthorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Author update
   */
  export type AuthorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * The data needed to update a Author.
     */
    data: XOR<AuthorUpdateInput, AuthorUncheckedUpdateInput>
    /**
     * Choose, which Author to update.
     */
    where: AuthorWhereUniqueInput
  }

  /**
   * Author updateMany
   */
  export type AuthorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Authors.
     */
    data: XOR<AuthorUpdateManyMutationInput, AuthorUncheckedUpdateManyInput>
    /**
     * Filter which Authors to update
     */
    where?: AuthorWhereInput
    /**
     * Limit how many Authors to update.
     */
    limit?: number
  }

  /**
   * Author updateManyAndReturn
   */
  export type AuthorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * The data used to update Authors.
     */
    data: XOR<AuthorUpdateManyMutationInput, AuthorUncheckedUpdateManyInput>
    /**
     * Filter which Authors to update
     */
    where?: AuthorWhereInput
    /**
     * Limit how many Authors to update.
     */
    limit?: number
  }

  /**
   * Author upsert
   */
  export type AuthorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * The filter to search for the Author to update in case it exists.
     */
    where: AuthorWhereUniqueInput
    /**
     * In case the Author found by the `where` argument doesn't exist, create a new Author with this data.
     */
    create: XOR<AuthorCreateInput, AuthorUncheckedCreateInput>
    /**
     * In case the Author was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthorUpdateInput, AuthorUncheckedUpdateInput>
  }

  /**
   * Author delete
   */
  export type AuthorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    /**
     * Filter which Author to delete.
     */
    where: AuthorWhereUniqueInput
  }

  /**
   * Author deleteMany
   */
  export type AuthorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Authors to delete
     */
    where?: AuthorWhereInput
    /**
     * Limit how many Authors to delete.
     */
    limit?: number
  }

  /**
   * Author.novels
   */
  export type Author$novelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Novel
     */
    select?: NovelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Novel
     */
    omit?: NovelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelInclude<ExtArgs> | null
    where?: NovelWhereInput
    orderBy?: NovelOrderByWithRelationInput | NovelOrderByWithRelationInput[]
    cursor?: NovelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NovelScalarFieldEnum | NovelScalarFieldEnum[]
  }

  /**
   * Author without action
   */
  export type AuthorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
  }


  /**
   * Model Novel
   */

  export type AggregateNovel = {
    _count: NovelCountAggregateOutputType | null
    _avg: NovelAvgAggregateOutputType | null
    _sum: NovelSumAggregateOutputType | null
    _min: NovelMinAggregateOutputType | null
    _max: NovelMaxAggregateOutputType | null
  }

  export type NovelAvgAggregateOutputType = {
    id: number | null
    authorId: number | null
    createdById: number | null
    genreId: number | null
    wordCount: number | null
    totalChapters: number | null
  }

  export type NovelSumAggregateOutputType = {
    id: number | null
    authorId: number | null
    createdById: number | null
    genreId: number | null
    wordCount: number | null
    totalChapters: number | null
  }

  export type NovelMinAggregateOutputType = {
    id: number | null
    title: string | null
    originalTitle: string | null
    authorId: number | null
    createdById: number | null
    genreId: number | null
    kind: $Enums.NovelKind | null
    gender: $Enums.Gender | null
    status: $Enums.NovelStatus | null
    synopsis: string | null
    coverImage: string | null
    wordCount: number | null
    totalChapters: number | null
    publishedAt: Date | null
    newChapterAt: Date | null
    createdAt: Date | null
  }

  export type NovelMaxAggregateOutputType = {
    id: number | null
    title: string | null
    originalTitle: string | null
    authorId: number | null
    createdById: number | null
    genreId: number | null
    kind: $Enums.NovelKind | null
    gender: $Enums.Gender | null
    status: $Enums.NovelStatus | null
    synopsis: string | null
    coverImage: string | null
    wordCount: number | null
    totalChapters: number | null
    publishedAt: Date | null
    newChapterAt: Date | null
    createdAt: Date | null
  }

  export type NovelCountAggregateOutputType = {
    id: number
    title: number
    originalTitle: number
    authorId: number
    createdById: number
    genreId: number
    kind: number
    gender: number
    status: number
    synopsis: number
    coverImage: number
    wordCount: number
    totalChapters: number
    publishedAt: number
    newChapterAt: number
    createdAt: number
    _all: number
  }


  export type NovelAvgAggregateInputType = {
    id?: true
    authorId?: true
    createdById?: true
    genreId?: true
    wordCount?: true
    totalChapters?: true
  }

  export type NovelSumAggregateInputType = {
    id?: true
    authorId?: true
    createdById?: true
    genreId?: true
    wordCount?: true
    totalChapters?: true
  }

  export type NovelMinAggregateInputType = {
    id?: true
    title?: true
    originalTitle?: true
    authorId?: true
    createdById?: true
    genreId?: true
    kind?: true
    gender?: true
    status?: true
    synopsis?: true
    coverImage?: true
    wordCount?: true
    totalChapters?: true
    publishedAt?: true
    newChapterAt?: true
    createdAt?: true
  }

  export type NovelMaxAggregateInputType = {
    id?: true
    title?: true
    originalTitle?: true
    authorId?: true
    createdById?: true
    genreId?: true
    kind?: true
    gender?: true
    status?: true
    synopsis?: true
    coverImage?: true
    wordCount?: true
    totalChapters?: true
    publishedAt?: true
    newChapterAt?: true
    createdAt?: true
  }

  export type NovelCountAggregateInputType = {
    id?: true
    title?: true
    originalTitle?: true
    authorId?: true
    createdById?: true
    genreId?: true
    kind?: true
    gender?: true
    status?: true
    synopsis?: true
    coverImage?: true
    wordCount?: true
    totalChapters?: true
    publishedAt?: true
    newChapterAt?: true
    createdAt?: true
    _all?: true
  }

  export type NovelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Novel to aggregate.
     */
    where?: NovelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Novels to fetch.
     */
    orderBy?: NovelOrderByWithRelationInput | NovelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NovelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Novels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Novels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Novels
    **/
    _count?: true | NovelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NovelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NovelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NovelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NovelMaxAggregateInputType
  }

  export type GetNovelAggregateType<T extends NovelAggregateArgs> = {
        [P in keyof T & keyof AggregateNovel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNovel[P]>
      : GetScalarType<T[P], AggregateNovel[P]>
  }




  export type NovelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NovelWhereInput
    orderBy?: NovelOrderByWithAggregationInput | NovelOrderByWithAggregationInput[]
    by: NovelScalarFieldEnum[] | NovelScalarFieldEnum
    having?: NovelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NovelCountAggregateInputType | true
    _avg?: NovelAvgAggregateInputType
    _sum?: NovelSumAggregateInputType
    _min?: NovelMinAggregateInputType
    _max?: NovelMaxAggregateInputType
  }

  export type NovelGroupByOutputType = {
    id: number
    title: string
    originalTitle: string | null
    authorId: number | null
    createdById: number
    genreId: number
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount: number
    totalChapters: number
    publishedAt: Date | null
    newChapterAt: Date
    createdAt: Date
    _count: NovelCountAggregateOutputType | null
    _avg: NovelAvgAggregateOutputType | null
    _sum: NovelSumAggregateOutputType | null
    _min: NovelMinAggregateOutputType | null
    _max: NovelMaxAggregateOutputType | null
  }

  type GetNovelGroupByPayload<T extends NovelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NovelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NovelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NovelGroupByOutputType[P]>
            : GetScalarType<T[P], NovelGroupByOutputType[P]>
        }
      >
    >


  export type NovelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    originalTitle?: boolean
    authorId?: boolean
    createdById?: boolean
    genreId?: boolean
    kind?: boolean
    gender?: boolean
    status?: boolean
    synopsis?: boolean
    coverImage?: boolean
    wordCount?: boolean
    totalChapters?: boolean
    publishedAt?: boolean
    newChapterAt?: boolean
    createdAt?: boolean
    author?: boolean | Novel$authorArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
    chapters?: boolean | Novel$chaptersArgs<ExtArgs>
    novelTags?: boolean | Novel$novelTagsArgs<ExtArgs>
    reviews?: boolean | Novel$reviewsArgs<ExtArgs>
    statistics?: boolean | Novel$statisticsArgs<ExtArgs>
    readers?: boolean | Novel$readersArgs<ExtArgs>
    favorites?: boolean | Novel$favoritesArgs<ExtArgs>
    comments?: boolean | Novel$commentsArgs<ExtArgs>
    _count?: boolean | NovelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["novel"]>

  export type NovelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    originalTitle?: boolean
    authorId?: boolean
    createdById?: boolean
    genreId?: boolean
    kind?: boolean
    gender?: boolean
    status?: boolean
    synopsis?: boolean
    coverImage?: boolean
    wordCount?: boolean
    totalChapters?: boolean
    publishedAt?: boolean
    newChapterAt?: boolean
    createdAt?: boolean
    author?: boolean | Novel$authorArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["novel"]>

  export type NovelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    originalTitle?: boolean
    authorId?: boolean
    createdById?: boolean
    genreId?: boolean
    kind?: boolean
    gender?: boolean
    status?: boolean
    synopsis?: boolean
    coverImage?: boolean
    wordCount?: boolean
    totalChapters?: boolean
    publishedAt?: boolean
    newChapterAt?: boolean
    createdAt?: boolean
    author?: boolean | Novel$authorArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["novel"]>

  export type NovelSelectScalar = {
    id?: boolean
    title?: boolean
    originalTitle?: boolean
    authorId?: boolean
    createdById?: boolean
    genreId?: boolean
    kind?: boolean
    gender?: boolean
    status?: boolean
    synopsis?: boolean
    coverImage?: boolean
    wordCount?: boolean
    totalChapters?: boolean
    publishedAt?: boolean
    newChapterAt?: boolean
    createdAt?: boolean
  }

  export type NovelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "originalTitle" | "authorId" | "createdById" | "genreId" | "kind" | "gender" | "status" | "synopsis" | "coverImage" | "wordCount" | "totalChapters" | "publishedAt" | "newChapterAt" | "createdAt", ExtArgs["result"]["novel"]>
  export type NovelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | Novel$authorArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
    chapters?: boolean | Novel$chaptersArgs<ExtArgs>
    novelTags?: boolean | Novel$novelTagsArgs<ExtArgs>
    reviews?: boolean | Novel$reviewsArgs<ExtArgs>
    statistics?: boolean | Novel$statisticsArgs<ExtArgs>
    readers?: boolean | Novel$readersArgs<ExtArgs>
    favorites?: boolean | Novel$favoritesArgs<ExtArgs>
    comments?: boolean | Novel$commentsArgs<ExtArgs>
    _count?: boolean | NovelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NovelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | Novel$authorArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }
  export type NovelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | Novel$authorArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    genre?: boolean | GenreDefaultArgs<ExtArgs>
  }

  export type $NovelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Novel"
    objects: {
      author: Prisma.$AuthorPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
      genre: Prisma.$GenrePayload<ExtArgs>
      chapters: Prisma.$ChapterPayload<ExtArgs>[]
      novelTags: Prisma.$NovelTagPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      statistics: Prisma.$NovelStatisticPayload<ExtArgs>[]
      readers: Prisma.$ReadingPayload<ExtArgs>[]
      favorites: Prisma.$FavoritePayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      originalTitle: string | null
      authorId: number | null
      createdById: number
      genreId: number
      kind: $Enums.NovelKind
      gender: $Enums.Gender
      status: $Enums.NovelStatus
      synopsis: string
      coverImage: string
      wordCount: number
      totalChapters: number
      publishedAt: Date | null
      newChapterAt: Date
      createdAt: Date
    }, ExtArgs["result"]["novel"]>
    composites: {}
  }

  type NovelGetPayload<S extends boolean | null | undefined | NovelDefaultArgs> = $Result.GetResult<Prisma.$NovelPayload, S>

  type NovelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NovelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NovelCountAggregateInputType | true
    }

  export interface NovelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Novel'], meta: { name: 'Novel' } }
    /**
     * Find zero or one Novel that matches the filter.
     * @param {NovelFindUniqueArgs} args - Arguments to find a Novel
     * @example
     * // Get one Novel
     * const novel = await prisma.novel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NovelFindUniqueArgs>(args: SelectSubset<T, NovelFindUniqueArgs<ExtArgs>>): Prisma__NovelClient<$Result.GetResult<Prisma.$NovelPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Novel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NovelFindUniqueOrThrowArgs} args - Arguments to find a Novel
     * @example
     * // Get one Novel
     * const novel = await prisma.novel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NovelFindUniqueOrThrowArgs>(args: SelectSubset<T, NovelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NovelClient<$Result.GetResult<Prisma.$NovelPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Novel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NovelFindFirstArgs} args - Arguments to find a Novel
     * @example
     * // Get one Novel
     * const novel = await prisma.novel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NovelFindFirstArgs>(args?: SelectSubset<T, NovelFindFirstArgs<ExtArgs>>): Prisma__NovelClient<$Result.GetResult<Prisma.$NovelPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Novel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NovelFindFirstOrThrowArgs} args - Arguments to find a Novel
     * @example
     * // Get one Novel
     * const novel = await prisma.novel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NovelFindFirstOrThrowArgs>(args?: SelectSubset<T, NovelFindFirstOrThrowArgs<ExtArgs>>): Prisma__NovelClient<$Result.GetResult<Prisma.$NovelPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Novels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NovelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Novels
     * const novels = await prisma.novel.findMany()
     * 
     * // Get first 10 Novels
     * const novels = await prisma.novel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const novelWithIdOnly = await prisma.novel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NovelFindManyArgs>(args?: SelectSubset<T, NovelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NovelPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Novel.
     * @param {NovelCreateArgs} args - Arguments to create a Novel.
     * @example
     * // Create one Novel
     * const Novel = await prisma.novel.create({
     *   data: {
     *     // ... data to create a Novel
     *   }
     * })
     * 
     */
    create<T extends NovelCreateArgs>(args: SelectSubset<T, NovelCreateArgs<ExtArgs>>): Prisma__NovelClient<$Result.GetResult<Prisma.$NovelPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Novels.
     * @param {NovelCreateManyArgs} args - Arguments to create many Novels.
     * @example
     * // Create many Novels
     * const novel = await prisma.novel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NovelCreateManyArgs>(args?: SelectSubset<T, NovelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Novels and returns the data saved in the database.
     * @param {NovelCreateManyAndReturnArgs} args - Arguments to create many Novels.
     * @example
     * // Create many Novels
     * const novel = await prisma.novel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Novels and only return the `id`
     * const novelWithIdOnly = await prisma.novel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NovelCreateManyAndReturnArgs>(args?: SelectSubset<T, NovelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NovelPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Novel.
     * @param {NovelDeleteArgs} args - Arguments to delete one Novel.
     * @example
     * // Delete one Novel
     * const Novel = await prisma.novel.delete({
     *   where: {
     *     // ... filter to delete one Novel
     *   }
     * })
     * 
     */
    delete<T extends NovelDeleteArgs>(args: SelectSubset<T, NovelDeleteArgs<ExtArgs>>): Prisma__NovelClient<$Result.GetResult<Prisma.$NovelPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Novel.
     * @param {NovelUpdateArgs} args - Arguments to update one Novel.
     * @example
     * // Update one Novel
     * const novel = await prisma.novel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NovelUpdateArgs>(args: SelectSubset<T, NovelUpdateArgs<ExtArgs>>): Prisma__NovelClient<$Result.GetResult<Prisma.$NovelPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Novels.
     * @param {NovelDeleteManyArgs} args - Arguments to filter Novels to delete.
     * @example
     * // Delete a few Novels
     * const { count } = await prisma.novel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NovelDeleteManyArgs>(args?: SelectSubset<T, NovelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Novels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NovelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Novels
     * const novel = await prisma.novel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NovelUpdateManyArgs>(args: SelectSubset<T, NovelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Novels and returns the data updated in the database.
     * @param {NovelUpdateManyAndReturnArgs} args - Arguments to update many Novels.
     * @example
     * // Update many Novels
     * const novel = await prisma.novel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Novels and only return the `id`
     * const novelWithIdOnly = await prisma.novel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NovelUpdateManyAndReturnArgs>(args: SelectSubset<T, NovelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NovelPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Novel.
     * @param {NovelUpsertArgs} args - Arguments to update or create a Novel.
     * @example
     * // Update or create a Novel
     * const novel = await prisma.novel.upsert({
     *   create: {
     *     // ... data to create a Novel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Novel we want to update
     *   }
     * })
     */
    upsert<T extends NovelUpsertArgs>(args: SelectSubset<T, NovelUpsertArgs<ExtArgs>>): Prisma__NovelClient<$Result.GetResult<Prisma.$NovelPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Novels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NovelCountArgs} args - Arguments to filter Novels to count.
     * @example
     * // Count the number of Novels
     * const count = await prisma.novel.count({
     *   where: {
     *     // ... the filter for the Novels we want to count
     *   }
     * })
    **/
    count<T extends NovelCountArgs>(
      args?: Subset<T, NovelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NovelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Novel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NovelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NovelAggregateArgs>(args: Subset<T, NovelAggregateArgs>): Prisma.PrismaPromise<GetNovelAggregateType<T>>

    /**
     * Group by Novel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NovelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NovelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NovelGroupByArgs['orderBy'] }
        : { orderBy?: NovelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NovelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNovelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Novel model
   */
  readonly fields: NovelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Novel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NovelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends Novel$authorArgs<ExtArgs> = {}>(args?: Subset<T, Novel$authorArgs<ExtArgs>>): Prisma__AuthorClient<$Result.GetResult<Prisma.$AuthorPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    genre<T extends GenreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GenreDefaultArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    chapters<T extends Novel$chaptersArgs<ExtArgs> = {}>(args?: Subset<T, Novel$chaptersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    novelTags<T extends Novel$novelTagsArgs<ExtArgs> = {}>(args?: Subset<T, Novel$novelTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NovelTagPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    reviews<T extends Novel$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Novel$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    statistics<T extends Novel$statisticsArgs<ExtArgs> = {}>(args?: Subset<T, Novel$statisticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NovelStatisticPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    readers<T extends Novel$readersArgs<ExtArgs> = {}>(args?: Subset<T, Novel$readersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReadingPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    favorites<T extends Novel$favoritesArgs<ExtArgs> = {}>(args?: Subset<T, Novel$favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    comments<T extends Novel$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Novel$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Novel model
   */ 
  interface NovelFieldRefs {
    readonly id: FieldRef<"Novel", 'Int'>
    readonly title: FieldRef<"Novel", 'String'>
    readonly originalTitle: FieldRef<"Novel", 'String'>
    readonly authorId: FieldRef<"Novel", 'Int'>
    readonly createdById: FieldRef<"Novel", 'Int'>
    readonly genreId: FieldRef<"Novel", 'Int'>
    readonly kind: FieldRef<"Novel", 'NovelKind'>
    readonly gender: FieldRef<"Novel", 'Gender'>
    readonly status: FieldRef<"Novel", 'NovelStatus'>
    readonly synopsis: FieldRef<"Novel", 'String'>
    readonly coverImage: FieldRef<"Novel", 'String'>
    readonly wordCount: FieldRef<"Novel", 'Int'>
    readonly totalChapters: FieldRef<"Novel", 'Int'>
    readonly publishedAt: FieldRef<"Novel", 'DateTime'>
    readonly newChapterAt: FieldRef<"Novel", 'DateTime'>
    readonly createdAt: FieldRef<"Novel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Novel findUnique
   */
  export type NovelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Novel
     */
    select?: NovelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Novel
     */
    omit?: NovelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelInclude<ExtArgs> | null
    /**
     * Filter, which Novel to fetch.
     */
    where: NovelWhereUniqueInput
  }

  /**
   * Novel findUniqueOrThrow
   */
  export type NovelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Novel
     */
    select?: NovelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Novel
     */
    omit?: NovelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelInclude<ExtArgs> | null
    /**
     * Filter, which Novel to fetch.
     */
    where: NovelWhereUniqueInput
  }

  /**
   * Novel findFirst
   */
  export type NovelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Novel
     */
    select?: NovelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Novel
     */
    omit?: NovelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelInclude<ExtArgs> | null
    /**
     * Filter, which Novel to fetch.
     */
    where?: NovelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Novels to fetch.
     */
    orderBy?: NovelOrderByWithRelationInput | NovelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Novels.
     */
    cursor?: NovelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Novels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Novels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Novels.
     */
    distinct?: NovelScalarFieldEnum | NovelScalarFieldEnum[]
  }

  /**
   * Novel findFirstOrThrow
   */
  export type NovelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Novel
     */
    select?: NovelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Novel
     */
    omit?: NovelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelInclude<ExtArgs> | null
    /**
     * Filter, which Novel to fetch.
     */
    where?: NovelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Novels to fetch.
     */
    orderBy?: NovelOrderByWithRelationInput | NovelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Novels.
     */
    cursor?: NovelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Novels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Novels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Novels.
     */
    distinct?: NovelScalarFieldEnum | NovelScalarFieldEnum[]
  }

  /**
   * Novel findMany
   */
  export type NovelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Novel
     */
    select?: NovelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Novel
     */
    omit?: NovelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelInclude<ExtArgs> | null
    /**
     * Filter, which Novels to fetch.
     */
    where?: NovelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Novels to fetch.
     */
    orderBy?: NovelOrderByWithRelationInput | NovelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Novels.
     */
    cursor?: NovelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Novels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Novels.
     */
    skip?: number
    distinct?: NovelScalarFieldEnum | NovelScalarFieldEnum[]
  }

  /**
   * Novel create
   */
  export type NovelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Novel
     */
    select?: NovelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Novel
     */
    omit?: NovelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelInclude<ExtArgs> | null
    /**
     * The data needed to create a Novel.
     */
    data: XOR<NovelCreateInput, NovelUncheckedCreateInput>
  }

  /**
   * Novel createMany
   */
  export type NovelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Novels.
     */
    data: NovelCreateManyInput | NovelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Novel createManyAndReturn
   */
  export type NovelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Novel
     */
    select?: NovelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Novel
     */
    omit?: NovelOmit<ExtArgs> | null
    /**
     * The data used to create many Novels.
     */
    data: NovelCreateManyInput | NovelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Novel update
   */
  export type NovelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Novel
     */
    select?: NovelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Novel
     */
    omit?: NovelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelInclude<ExtArgs> | null
    /**
     * The data needed to update a Novel.
     */
    data: XOR<NovelUpdateInput, NovelUncheckedUpdateInput>
    /**
     * Choose, which Novel to update.
     */
    where: NovelWhereUniqueInput
  }

  /**
   * Novel updateMany
   */
  export type NovelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Novels.
     */
    data: XOR<NovelUpdateManyMutationInput, NovelUncheckedUpdateManyInput>
    /**
     * Filter which Novels to update
     */
    where?: NovelWhereInput
    /**
     * Limit how many Novels to update.
     */
    limit?: number
  }

  /**
   * Novel updateManyAndReturn
   */
  export type NovelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Novel
     */
    select?: NovelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Novel
     */
    omit?: NovelOmit<ExtArgs> | null
    /**
     * The data used to update Novels.
     */
    data: XOR<NovelUpdateManyMutationInput, NovelUncheckedUpdateManyInput>
    /**
     * Filter which Novels to update
     */
    where?: NovelWhereInput
    /**
     * Limit how many Novels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Novel upsert
   */
  export type NovelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Novel
     */
    select?: NovelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Novel
     */
    omit?: NovelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelInclude<ExtArgs> | null
    /**
     * The filter to search for the Novel to update in case it exists.
     */
    where: NovelWhereUniqueInput
    /**
     * In case the Novel found by the `where` argument doesn't exist, create a new Novel with this data.
     */
    create: XOR<NovelCreateInput, NovelUncheckedCreateInput>
    /**
     * In case the Novel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NovelUpdateInput, NovelUncheckedUpdateInput>
  }

  /**
   * Novel delete
   */
  export type NovelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Novel
     */
    select?: NovelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Novel
     */
    omit?: NovelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelInclude<ExtArgs> | null
    /**
     * Filter which Novel to delete.
     */
    where: NovelWhereUniqueInput
  }

  /**
   * Novel deleteMany
   */
  export type NovelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Novels to delete
     */
    where?: NovelWhereInput
    /**
     * Limit how many Novels to delete.
     */
    limit?: number
  }

  /**
   * Novel.author
   */
  export type Novel$authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Author
     */
    select?: AuthorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Author
     */
    omit?: AuthorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthorInclude<ExtArgs> | null
    where?: AuthorWhereInput
  }

  /**
   * Novel.chapters
   */
  export type Novel$chaptersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    where?: ChapterWhereInput
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    cursor?: ChapterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Novel.novelTags
   */
  export type Novel$novelTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelTag
     */
    select?: NovelTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NovelTag
     */
    omit?: NovelTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelTagInclude<ExtArgs> | null
    where?: NovelTagWhereInput
    orderBy?: NovelTagOrderByWithRelationInput | NovelTagOrderByWithRelationInput[]
    cursor?: NovelTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NovelTagScalarFieldEnum | NovelTagScalarFieldEnum[]
  }

  /**
   * Novel.reviews
   */
  export type Novel$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Novel.statistics
   */
  export type Novel$statisticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelStatistic
     */
    select?: NovelStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NovelStatistic
     */
    omit?: NovelStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelStatisticInclude<ExtArgs> | null
    where?: NovelStatisticWhereInput
    orderBy?: NovelStatisticOrderByWithRelationInput | NovelStatisticOrderByWithRelationInput[]
    cursor?: NovelStatisticWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NovelStatisticScalarFieldEnum | NovelStatisticScalarFieldEnum[]
  }

  /**
   * Novel.readers
   */
  export type Novel$readersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading
     */
    select?: ReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading
     */
    omit?: ReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingInclude<ExtArgs> | null
    where?: ReadingWhereInput
    orderBy?: ReadingOrderByWithRelationInput | ReadingOrderByWithRelationInput[]
    cursor?: ReadingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReadingScalarFieldEnum | ReadingScalarFieldEnum[]
  }

  /**
   * Novel.favorites
   */
  export type Novel$favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    cursor?: FavoriteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Novel.comments
   */
  export type Novel$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Novel without action
   */
  export type NovelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Novel
     */
    select?: NovelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Novel
     */
    omit?: NovelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelInclude<ExtArgs> | null
  }


  /**
   * Model Genre
   */

  export type AggregateGenre = {
    _count: GenreCountAggregateOutputType | null
    _avg: GenreAvgAggregateOutputType | null
    _sum: GenreSumAggregateOutputType | null
    _min: GenreMinAggregateOutputType | null
    _max: GenreMaxAggregateOutputType | null
  }

  export type GenreAvgAggregateOutputType = {
    id: number | null
  }

  export type GenreSumAggregateOutputType = {
    id: number | null
  }

  export type GenreMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type GenreMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type GenreCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type GenreAvgAggregateInputType = {
    id?: true
  }

  export type GenreSumAggregateInputType = {
    id?: true
  }

  export type GenreMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type GenreMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type GenreCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type GenreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genre to aggregate.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Genres
    **/
    _count?: true | GenreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GenreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GenreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GenreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GenreMaxAggregateInputType
  }

  export type GetGenreAggregateType<T extends GenreAggregateArgs> = {
        [P in keyof T & keyof AggregateGenre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenre[P]>
      : GetScalarType<T[P], AggregateGenre[P]>
  }




  export type GenreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GenreWhereInput
    orderBy?: GenreOrderByWithAggregationInput | GenreOrderByWithAggregationInput[]
    by: GenreScalarFieldEnum[] | GenreScalarFieldEnum
    having?: GenreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GenreCountAggregateInputType | true
    _avg?: GenreAvgAggregateInputType
    _sum?: GenreSumAggregateInputType
    _min?: GenreMinAggregateInputType
    _max?: GenreMaxAggregateInputType
  }

  export type GenreGroupByOutputType = {
    id: number
    name: string
    _count: GenreCountAggregateOutputType | null
    _avg: GenreAvgAggregateOutputType | null
    _sum: GenreSumAggregateOutputType | null
    _min: GenreMinAggregateOutputType | null
    _max: GenreMaxAggregateOutputType | null
  }

  type GetGenreGroupByPayload<T extends GenreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GenreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GenreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GenreGroupByOutputType[P]>
            : GetScalarType<T[P], GenreGroupByOutputType[P]>
        }
      >
    >


  export type GenreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    novels?: boolean | Genre$novelsArgs<ExtArgs>
    _count?: boolean | GenreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["genre"]>

  export type GenreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["genre"]>

  export type GenreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["genre"]>

  export type GenreSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type GenreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["genre"]>
  export type GenreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    novels?: boolean | Genre$novelsArgs<ExtArgs>
    _count?: boolean | GenreCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GenreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GenreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GenrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Genre"
    objects: {
      novels: Prisma.$NovelPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["genre"]>
    composites: {}
  }

  type GenreGetPayload<S extends boolean | null | undefined | GenreDefaultArgs> = $Result.GetResult<Prisma.$GenrePayload, S>

  type GenreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GenreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GenreCountAggregateInputType | true
    }

  export interface GenreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Genre'], meta: { name: 'Genre' } }
    /**
     * Find zero or one Genre that matches the filter.
     * @param {GenreFindUniqueArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GenreFindUniqueArgs>(args: SelectSubset<T, GenreFindUniqueArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Genre that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GenreFindUniqueOrThrowArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GenreFindUniqueOrThrowArgs>(args: SelectSubset<T, GenreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Genre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindFirstArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GenreFindFirstArgs>(args?: SelectSubset<T, GenreFindFirstArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Genre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindFirstOrThrowArgs} args - Arguments to find a Genre
     * @example
     * // Get one Genre
     * const genre = await prisma.genre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GenreFindFirstOrThrowArgs>(args?: SelectSubset<T, GenreFindFirstOrThrowArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Genres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Genres
     * const genres = await prisma.genre.findMany()
     * 
     * // Get first 10 Genres
     * const genres = await prisma.genre.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const genreWithIdOnly = await prisma.genre.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GenreFindManyArgs>(args?: SelectSubset<T, GenreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Genre.
     * @param {GenreCreateArgs} args - Arguments to create a Genre.
     * @example
     * // Create one Genre
     * const Genre = await prisma.genre.create({
     *   data: {
     *     // ... data to create a Genre
     *   }
     * })
     * 
     */
    create<T extends GenreCreateArgs>(args: SelectSubset<T, GenreCreateArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Genres.
     * @param {GenreCreateManyArgs} args - Arguments to create many Genres.
     * @example
     * // Create many Genres
     * const genre = await prisma.genre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GenreCreateManyArgs>(args?: SelectSubset<T, GenreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Genres and returns the data saved in the database.
     * @param {GenreCreateManyAndReturnArgs} args - Arguments to create many Genres.
     * @example
     * // Create many Genres
     * const genre = await prisma.genre.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Genres and only return the `id`
     * const genreWithIdOnly = await prisma.genre.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GenreCreateManyAndReturnArgs>(args?: SelectSubset<T, GenreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Genre.
     * @param {GenreDeleteArgs} args - Arguments to delete one Genre.
     * @example
     * // Delete one Genre
     * const Genre = await prisma.genre.delete({
     *   where: {
     *     // ... filter to delete one Genre
     *   }
     * })
     * 
     */
    delete<T extends GenreDeleteArgs>(args: SelectSubset<T, GenreDeleteArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Genre.
     * @param {GenreUpdateArgs} args - Arguments to update one Genre.
     * @example
     * // Update one Genre
     * const genre = await prisma.genre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GenreUpdateArgs>(args: SelectSubset<T, GenreUpdateArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Genres.
     * @param {GenreDeleteManyArgs} args - Arguments to filter Genres to delete.
     * @example
     * // Delete a few Genres
     * const { count } = await prisma.genre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GenreDeleteManyArgs>(args?: SelectSubset<T, GenreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Genres
     * const genre = await prisma.genre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GenreUpdateManyArgs>(args: SelectSubset<T, GenreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Genres and returns the data updated in the database.
     * @param {GenreUpdateManyAndReturnArgs} args - Arguments to update many Genres.
     * @example
     * // Update many Genres
     * const genre = await prisma.genre.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Genres and only return the `id`
     * const genreWithIdOnly = await prisma.genre.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GenreUpdateManyAndReturnArgs>(args: SelectSubset<T, GenreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Genre.
     * @param {GenreUpsertArgs} args - Arguments to update or create a Genre.
     * @example
     * // Update or create a Genre
     * const genre = await prisma.genre.upsert({
     *   create: {
     *     // ... data to create a Genre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Genre we want to update
     *   }
     * })
     */
    upsert<T extends GenreUpsertArgs>(args: SelectSubset<T, GenreUpsertArgs<ExtArgs>>): Prisma__GenreClient<$Result.GetResult<Prisma.$GenrePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Genres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreCountArgs} args - Arguments to filter Genres to count.
     * @example
     * // Count the number of Genres
     * const count = await prisma.genre.count({
     *   where: {
     *     // ... the filter for the Genres we want to count
     *   }
     * })
    **/
    count<T extends GenreCountArgs>(
      args?: Subset<T, GenreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GenreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Genre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GenreAggregateArgs>(args: Subset<T, GenreAggregateArgs>): Prisma.PrismaPromise<GetGenreAggregateType<T>>

    /**
     * Group by Genre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GenreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GenreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GenreGroupByArgs['orderBy'] }
        : { orderBy?: GenreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GenreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGenreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Genre model
   */
  readonly fields: GenreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Genre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GenreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    novels<T extends Genre$novelsArgs<ExtArgs> = {}>(args?: Subset<T, Genre$novelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NovelPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Genre model
   */ 
  interface GenreFieldRefs {
    readonly id: FieldRef<"Genre", 'Int'>
    readonly name: FieldRef<"Genre", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Genre findUnique
   */
  export type GenreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre findUniqueOrThrow
   */
  export type GenreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre findFirst
   */
  export type GenreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genres.
     */
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre findFirstOrThrow
   */
  export type GenreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genre to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Genres.
     */
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre findMany
   */
  export type GenreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter, which Genres to fetch.
     */
    where?: GenreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Genres to fetch.
     */
    orderBy?: GenreOrderByWithRelationInput | GenreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Genres.
     */
    cursor?: GenreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Genres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Genres.
     */
    skip?: number
    distinct?: GenreScalarFieldEnum | GenreScalarFieldEnum[]
  }

  /**
   * Genre create
   */
  export type GenreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The data needed to create a Genre.
     */
    data: XOR<GenreCreateInput, GenreUncheckedCreateInput>
  }

  /**
   * Genre createMany
   */
  export type GenreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Genres.
     */
    data: GenreCreateManyInput | GenreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Genre createManyAndReturn
   */
  export type GenreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * The data used to create many Genres.
     */
    data: GenreCreateManyInput | GenreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Genre update
   */
  export type GenreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The data needed to update a Genre.
     */
    data: XOR<GenreUpdateInput, GenreUncheckedUpdateInput>
    /**
     * Choose, which Genre to update.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre updateMany
   */
  export type GenreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Genres.
     */
    data: XOR<GenreUpdateManyMutationInput, GenreUncheckedUpdateManyInput>
    /**
     * Filter which Genres to update
     */
    where?: GenreWhereInput
    /**
     * Limit how many Genres to update.
     */
    limit?: number
  }

  /**
   * Genre updateManyAndReturn
   */
  export type GenreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * The data used to update Genres.
     */
    data: XOR<GenreUpdateManyMutationInput, GenreUncheckedUpdateManyInput>
    /**
     * Filter which Genres to update
     */
    where?: GenreWhereInput
    /**
     * Limit how many Genres to update.
     */
    limit?: number
  }

  /**
   * Genre upsert
   */
  export type GenreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * The filter to search for the Genre to update in case it exists.
     */
    where: GenreWhereUniqueInput
    /**
     * In case the Genre found by the `where` argument doesn't exist, create a new Genre with this data.
     */
    create: XOR<GenreCreateInput, GenreUncheckedCreateInput>
    /**
     * In case the Genre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GenreUpdateInput, GenreUncheckedUpdateInput>
  }

  /**
   * Genre delete
   */
  export type GenreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
    /**
     * Filter which Genre to delete.
     */
    where: GenreWhereUniqueInput
  }

  /**
   * Genre deleteMany
   */
  export type GenreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genres to delete
     */
    where?: GenreWhereInput
    /**
     * Limit how many Genres to delete.
     */
    limit?: number
  }

  /**
   * Genre.novels
   */
  export type Genre$novelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Novel
     */
    select?: NovelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Novel
     */
    omit?: NovelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelInclude<ExtArgs> | null
    where?: NovelWhereInput
    orderBy?: NovelOrderByWithRelationInput | NovelOrderByWithRelationInput[]
    cursor?: NovelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NovelScalarFieldEnum | NovelScalarFieldEnum[]
  }

  /**
   * Genre without action
   */
  export type GenreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genre
     */
    select?: GenreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genre
     */
    omit?: GenreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GenreInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagAvgAggregateOutputType = {
    id: number | null
    tagGroupId: number | null
  }

  export type TagSumAggregateOutputType = {
    id: number | null
    tagGroupId: number | null
  }

  export type TagMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    tagGroupId: number | null
  }

  export type TagMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    tagGroupId: number | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    description: number
    tagGroupId: number
    _all: number
  }


  export type TagAvgAggregateInputType = {
    id?: true
    tagGroupId?: true
  }

  export type TagSumAggregateInputType = {
    id?: true
    tagGroupId?: true
  }

  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tagGroupId?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tagGroupId?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tagGroupId?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _avg?: TagAvgAggregateInputType
    _sum?: TagSumAggregateInputType
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: number
    name: string
    description: string | null
    tagGroupId: number
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tagGroupId?: boolean
    tagGroup?: boolean | TagGroupDefaultArgs<ExtArgs>
    novels?: boolean | Tag$novelsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tagGroupId?: boolean
    tagGroup?: boolean | TagGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tagGroupId?: boolean
    tagGroup?: boolean | TagGroupDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    tagGroupId?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "tagGroupId", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tagGroup?: boolean | TagGroupDefaultArgs<ExtArgs>
    novels?: boolean | Tag$novelsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tagGroup?: boolean | TagGroupDefaultArgs<ExtArgs>
  }
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tagGroup?: boolean | TagGroupDefaultArgs<ExtArgs>
  }

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      tagGroup: Prisma.$TagGroupPayload<ExtArgs>
      novels: Prisma.$NovelTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      tagGroupId: number
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tagGroup<T extends TagGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagGroupDefaultArgs<ExtArgs>>): Prisma__TagGroupClient<$Result.GetResult<Prisma.$TagGroupPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    novels<T extends Tag$novelsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$novelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NovelTagPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */ 
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'Int'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly description: FieldRef<"Tag", 'String'>
    readonly tagGroupId: FieldRef<"Tag", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.novels
   */
  export type Tag$novelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelTag
     */
    select?: NovelTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NovelTag
     */
    omit?: NovelTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelTagInclude<ExtArgs> | null
    where?: NovelTagWhereInput
    orderBy?: NovelTagOrderByWithRelationInput | NovelTagOrderByWithRelationInput[]
    cursor?: NovelTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NovelTagScalarFieldEnum | NovelTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model TagGroup
   */

  export type AggregateTagGroup = {
    _count: TagGroupCountAggregateOutputType | null
    _avg: TagGroupAvgAggregateOutputType | null
    _sum: TagGroupSumAggregateOutputType | null
    _min: TagGroupMinAggregateOutputType | null
    _max: TagGroupMaxAggregateOutputType | null
  }

  export type TagGroupAvgAggregateOutputType = {
    id: number | null
  }

  export type TagGroupSumAggregateOutputType = {
    id: number | null
  }

  export type TagGroupMinAggregateOutputType = {
    id: number | null
    name: string | null
    color: string | null
  }

  export type TagGroupMaxAggregateOutputType = {
    id: number | null
    name: string | null
    color: string | null
  }

  export type TagGroupCountAggregateOutputType = {
    id: number
    name: number
    color: number
    _all: number
  }


  export type TagGroupAvgAggregateInputType = {
    id?: true
  }

  export type TagGroupSumAggregateInputType = {
    id?: true
  }

  export type TagGroupMinAggregateInputType = {
    id?: true
    name?: true
    color?: true
  }

  export type TagGroupMaxAggregateInputType = {
    id?: true
    name?: true
    color?: true
  }

  export type TagGroupCountAggregateInputType = {
    id?: true
    name?: true
    color?: true
    _all?: true
  }

  export type TagGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TagGroup to aggregate.
     */
    where?: TagGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagGroups to fetch.
     */
    orderBy?: TagGroupOrderByWithRelationInput | TagGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TagGroups
    **/
    _count?: true | TagGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagGroupMaxAggregateInputType
  }

  export type GetTagGroupAggregateType<T extends TagGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateTagGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTagGroup[P]>
      : GetScalarType<T[P], AggregateTagGroup[P]>
  }




  export type TagGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagGroupWhereInput
    orderBy?: TagGroupOrderByWithAggregationInput | TagGroupOrderByWithAggregationInput[]
    by: TagGroupScalarFieldEnum[] | TagGroupScalarFieldEnum
    having?: TagGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagGroupCountAggregateInputType | true
    _avg?: TagGroupAvgAggregateInputType
    _sum?: TagGroupSumAggregateInputType
    _min?: TagGroupMinAggregateInputType
    _max?: TagGroupMaxAggregateInputType
  }

  export type TagGroupGroupByOutputType = {
    id: number
    name: string
    color: string
    _count: TagGroupCountAggregateOutputType | null
    _avg: TagGroupAvgAggregateOutputType | null
    _sum: TagGroupSumAggregateOutputType | null
    _min: TagGroupMinAggregateOutputType | null
    _max: TagGroupMaxAggregateOutputType | null
  }

  type GetTagGroupGroupByPayload<T extends TagGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupGroupByOutputType[P]>
        }
      >
    >


  export type TagGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
    tags?: boolean | TagGroup$tagsArgs<ExtArgs>
    _count?: boolean | TagGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tagGroup"]>

  export type TagGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
  }, ExtArgs["result"]["tagGroup"]>

  export type TagGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    color?: boolean
  }, ExtArgs["result"]["tagGroup"]>

  export type TagGroupSelectScalar = {
    id?: boolean
    name?: boolean
    color?: boolean
  }

  export type TagGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "color", ExtArgs["result"]["tagGroup"]>
  export type TagGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tags?: boolean | TagGroup$tagsArgs<ExtArgs>
    _count?: boolean | TagGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TagGroup"
    objects: {
      tags: Prisma.$TagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      color: string
    }, ExtArgs["result"]["tagGroup"]>
    composites: {}
  }

  type TagGroupGetPayload<S extends boolean | null | undefined | TagGroupDefaultArgs> = $Result.GetResult<Prisma.$TagGroupPayload, S>

  type TagGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagGroupCountAggregateInputType | true
    }

  export interface TagGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TagGroup'], meta: { name: 'TagGroup' } }
    /**
     * Find zero or one TagGroup that matches the filter.
     * @param {TagGroupFindUniqueArgs} args - Arguments to find a TagGroup
     * @example
     * // Get one TagGroup
     * const tagGroup = await prisma.tagGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagGroupFindUniqueArgs>(args: SelectSubset<T, TagGroupFindUniqueArgs<ExtArgs>>): Prisma__TagGroupClient<$Result.GetResult<Prisma.$TagGroupPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TagGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagGroupFindUniqueOrThrowArgs} args - Arguments to find a TagGroup
     * @example
     * // Get one TagGroup
     * const tagGroup = await prisma.tagGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, TagGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagGroupClient<$Result.GetResult<Prisma.$TagGroupPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TagGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupFindFirstArgs} args - Arguments to find a TagGroup
     * @example
     * // Get one TagGroup
     * const tagGroup = await prisma.tagGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagGroupFindFirstArgs>(args?: SelectSubset<T, TagGroupFindFirstArgs<ExtArgs>>): Prisma__TagGroupClient<$Result.GetResult<Prisma.$TagGroupPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TagGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupFindFirstOrThrowArgs} args - Arguments to find a TagGroup
     * @example
     * // Get one TagGroup
     * const tagGroup = await prisma.tagGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, TagGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagGroupClient<$Result.GetResult<Prisma.$TagGroupPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TagGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TagGroups
     * const tagGroups = await prisma.tagGroup.findMany()
     * 
     * // Get first 10 TagGroups
     * const tagGroups = await prisma.tagGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagGroupWithIdOnly = await prisma.tagGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagGroupFindManyArgs>(args?: SelectSubset<T, TagGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagGroupPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TagGroup.
     * @param {TagGroupCreateArgs} args - Arguments to create a TagGroup.
     * @example
     * // Create one TagGroup
     * const TagGroup = await prisma.tagGroup.create({
     *   data: {
     *     // ... data to create a TagGroup
     *   }
     * })
     * 
     */
    create<T extends TagGroupCreateArgs>(args: SelectSubset<T, TagGroupCreateArgs<ExtArgs>>): Prisma__TagGroupClient<$Result.GetResult<Prisma.$TagGroupPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TagGroups.
     * @param {TagGroupCreateManyArgs} args - Arguments to create many TagGroups.
     * @example
     * // Create many TagGroups
     * const tagGroup = await prisma.tagGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagGroupCreateManyArgs>(args?: SelectSubset<T, TagGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TagGroups and returns the data saved in the database.
     * @param {TagGroupCreateManyAndReturnArgs} args - Arguments to create many TagGroups.
     * @example
     * // Create many TagGroups
     * const tagGroup = await prisma.tagGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TagGroups and only return the `id`
     * const tagGroupWithIdOnly = await prisma.tagGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, TagGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagGroupPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a TagGroup.
     * @param {TagGroupDeleteArgs} args - Arguments to delete one TagGroup.
     * @example
     * // Delete one TagGroup
     * const TagGroup = await prisma.tagGroup.delete({
     *   where: {
     *     // ... filter to delete one TagGroup
     *   }
     * })
     * 
     */
    delete<T extends TagGroupDeleteArgs>(args: SelectSubset<T, TagGroupDeleteArgs<ExtArgs>>): Prisma__TagGroupClient<$Result.GetResult<Prisma.$TagGroupPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TagGroup.
     * @param {TagGroupUpdateArgs} args - Arguments to update one TagGroup.
     * @example
     * // Update one TagGroup
     * const tagGroup = await prisma.tagGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagGroupUpdateArgs>(args: SelectSubset<T, TagGroupUpdateArgs<ExtArgs>>): Prisma__TagGroupClient<$Result.GetResult<Prisma.$TagGroupPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TagGroups.
     * @param {TagGroupDeleteManyArgs} args - Arguments to filter TagGroups to delete.
     * @example
     * // Delete a few TagGroups
     * const { count } = await prisma.tagGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagGroupDeleteManyArgs>(args?: SelectSubset<T, TagGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TagGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TagGroups
     * const tagGroup = await prisma.tagGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagGroupUpdateManyArgs>(args: SelectSubset<T, TagGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TagGroups and returns the data updated in the database.
     * @param {TagGroupUpdateManyAndReturnArgs} args - Arguments to update many TagGroups.
     * @example
     * // Update many TagGroups
     * const tagGroup = await prisma.tagGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TagGroups and only return the `id`
     * const tagGroupWithIdOnly = await prisma.tagGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, TagGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagGroupPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one TagGroup.
     * @param {TagGroupUpsertArgs} args - Arguments to update or create a TagGroup.
     * @example
     * // Update or create a TagGroup
     * const tagGroup = await prisma.tagGroup.upsert({
     *   create: {
     *     // ... data to create a TagGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TagGroup we want to update
     *   }
     * })
     */
    upsert<T extends TagGroupUpsertArgs>(args: SelectSubset<T, TagGroupUpsertArgs<ExtArgs>>): Prisma__TagGroupClient<$Result.GetResult<Prisma.$TagGroupPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TagGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupCountArgs} args - Arguments to filter TagGroups to count.
     * @example
     * // Count the number of TagGroups
     * const count = await prisma.tagGroup.count({
     *   where: {
     *     // ... the filter for the TagGroups we want to count
     *   }
     * })
    **/
    count<T extends TagGroupCountArgs>(
      args?: Subset<T, TagGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TagGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagGroupAggregateArgs>(args: Subset<T, TagGroupAggregateArgs>): Prisma.PrismaPromise<GetTagGroupAggregateType<T>>

    /**
     * Group by TagGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TagGroup model
   */
  readonly fields: TagGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TagGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tags<T extends TagGroup$tagsArgs<ExtArgs> = {}>(args?: Subset<T, TagGroup$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TagGroup model
   */ 
  interface TagGroupFieldRefs {
    readonly id: FieldRef<"TagGroup", 'Int'>
    readonly name: FieldRef<"TagGroup", 'String'>
    readonly color: FieldRef<"TagGroup", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TagGroup findUnique
   */
  export type TagGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagGroup
     */
    select?: TagGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagGroup
     */
    omit?: TagGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagGroupInclude<ExtArgs> | null
    /**
     * Filter, which TagGroup to fetch.
     */
    where: TagGroupWhereUniqueInput
  }

  /**
   * TagGroup findUniqueOrThrow
   */
  export type TagGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagGroup
     */
    select?: TagGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagGroup
     */
    omit?: TagGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagGroupInclude<ExtArgs> | null
    /**
     * Filter, which TagGroup to fetch.
     */
    where: TagGroupWhereUniqueInput
  }

  /**
   * TagGroup findFirst
   */
  export type TagGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagGroup
     */
    select?: TagGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagGroup
     */
    omit?: TagGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagGroupInclude<ExtArgs> | null
    /**
     * Filter, which TagGroup to fetch.
     */
    where?: TagGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagGroups to fetch.
     */
    orderBy?: TagGroupOrderByWithRelationInput | TagGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TagGroups.
     */
    cursor?: TagGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TagGroups.
     */
    distinct?: TagGroupScalarFieldEnum | TagGroupScalarFieldEnum[]
  }

  /**
   * TagGroup findFirstOrThrow
   */
  export type TagGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagGroup
     */
    select?: TagGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagGroup
     */
    omit?: TagGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagGroupInclude<ExtArgs> | null
    /**
     * Filter, which TagGroup to fetch.
     */
    where?: TagGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagGroups to fetch.
     */
    orderBy?: TagGroupOrderByWithRelationInput | TagGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TagGroups.
     */
    cursor?: TagGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TagGroups.
     */
    distinct?: TagGroupScalarFieldEnum | TagGroupScalarFieldEnum[]
  }

  /**
   * TagGroup findMany
   */
  export type TagGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagGroup
     */
    select?: TagGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagGroup
     */
    omit?: TagGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagGroupInclude<ExtArgs> | null
    /**
     * Filter, which TagGroups to fetch.
     */
    where?: TagGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TagGroups to fetch.
     */
    orderBy?: TagGroupOrderByWithRelationInput | TagGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TagGroups.
     */
    cursor?: TagGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TagGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TagGroups.
     */
    skip?: number
    distinct?: TagGroupScalarFieldEnum | TagGroupScalarFieldEnum[]
  }

  /**
   * TagGroup create
   */
  export type TagGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagGroup
     */
    select?: TagGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagGroup
     */
    omit?: TagGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a TagGroup.
     */
    data: XOR<TagGroupCreateInput, TagGroupUncheckedCreateInput>
  }

  /**
   * TagGroup createMany
   */
  export type TagGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TagGroups.
     */
    data: TagGroupCreateManyInput | TagGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TagGroup createManyAndReturn
   */
  export type TagGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagGroup
     */
    select?: TagGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TagGroup
     */
    omit?: TagGroupOmit<ExtArgs> | null
    /**
     * The data used to create many TagGroups.
     */
    data: TagGroupCreateManyInput | TagGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TagGroup update
   */
  export type TagGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagGroup
     */
    select?: TagGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagGroup
     */
    omit?: TagGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a TagGroup.
     */
    data: XOR<TagGroupUpdateInput, TagGroupUncheckedUpdateInput>
    /**
     * Choose, which TagGroup to update.
     */
    where: TagGroupWhereUniqueInput
  }

  /**
   * TagGroup updateMany
   */
  export type TagGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TagGroups.
     */
    data: XOR<TagGroupUpdateManyMutationInput, TagGroupUncheckedUpdateManyInput>
    /**
     * Filter which TagGroups to update
     */
    where?: TagGroupWhereInput
    /**
     * Limit how many TagGroups to update.
     */
    limit?: number
  }

  /**
   * TagGroup updateManyAndReturn
   */
  export type TagGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagGroup
     */
    select?: TagGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TagGroup
     */
    omit?: TagGroupOmit<ExtArgs> | null
    /**
     * The data used to update TagGroups.
     */
    data: XOR<TagGroupUpdateManyMutationInput, TagGroupUncheckedUpdateManyInput>
    /**
     * Filter which TagGroups to update
     */
    where?: TagGroupWhereInput
    /**
     * Limit how many TagGroups to update.
     */
    limit?: number
  }

  /**
   * TagGroup upsert
   */
  export type TagGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagGroup
     */
    select?: TagGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagGroup
     */
    omit?: TagGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the TagGroup to update in case it exists.
     */
    where: TagGroupWhereUniqueInput
    /**
     * In case the TagGroup found by the `where` argument doesn't exist, create a new TagGroup with this data.
     */
    create: XOR<TagGroupCreateInput, TagGroupUncheckedCreateInput>
    /**
     * In case the TagGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagGroupUpdateInput, TagGroupUncheckedUpdateInput>
  }

  /**
   * TagGroup delete
   */
  export type TagGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagGroup
     */
    select?: TagGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagGroup
     */
    omit?: TagGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagGroupInclude<ExtArgs> | null
    /**
     * Filter which TagGroup to delete.
     */
    where: TagGroupWhereUniqueInput
  }

  /**
   * TagGroup deleteMany
   */
  export type TagGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TagGroups to delete
     */
    where?: TagGroupWhereInput
    /**
     * Limit how many TagGroups to delete.
     */
    limit?: number
  }

  /**
   * TagGroup.tags
   */
  export type TagGroup$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * TagGroup without action
   */
  export type TagGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagGroup
     */
    select?: TagGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TagGroup
     */
    omit?: TagGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagGroupInclude<ExtArgs> | null
  }


  /**
   * Model NovelTag
   */

  export type AggregateNovelTag = {
    _count: NovelTagCountAggregateOutputType | null
    _avg: NovelTagAvgAggregateOutputType | null
    _sum: NovelTagSumAggregateOutputType | null
    _min: NovelTagMinAggregateOutputType | null
    _max: NovelTagMaxAggregateOutputType | null
  }

  export type NovelTagAvgAggregateOutputType = {
    novelId: number | null
    tagId: number | null
  }

  export type NovelTagSumAggregateOutputType = {
    novelId: number | null
    tagId: number | null
  }

  export type NovelTagMinAggregateOutputType = {
    novelId: number | null
    tagId: number | null
  }

  export type NovelTagMaxAggregateOutputType = {
    novelId: number | null
    tagId: number | null
  }

  export type NovelTagCountAggregateOutputType = {
    novelId: number
    tagId: number
    _all: number
  }


  export type NovelTagAvgAggregateInputType = {
    novelId?: true
    tagId?: true
  }

  export type NovelTagSumAggregateInputType = {
    novelId?: true
    tagId?: true
  }

  export type NovelTagMinAggregateInputType = {
    novelId?: true
    tagId?: true
  }

  export type NovelTagMaxAggregateInputType = {
    novelId?: true
    tagId?: true
  }

  export type NovelTagCountAggregateInputType = {
    novelId?: true
    tagId?: true
    _all?: true
  }

  export type NovelTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NovelTag to aggregate.
     */
    where?: NovelTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NovelTags to fetch.
     */
    orderBy?: NovelTagOrderByWithRelationInput | NovelTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NovelTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NovelTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NovelTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NovelTags
    **/
    _count?: true | NovelTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NovelTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NovelTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NovelTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NovelTagMaxAggregateInputType
  }

  export type GetNovelTagAggregateType<T extends NovelTagAggregateArgs> = {
        [P in keyof T & keyof AggregateNovelTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNovelTag[P]>
      : GetScalarType<T[P], AggregateNovelTag[P]>
  }




  export type NovelTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NovelTagWhereInput
    orderBy?: NovelTagOrderByWithAggregationInput | NovelTagOrderByWithAggregationInput[]
    by: NovelTagScalarFieldEnum[] | NovelTagScalarFieldEnum
    having?: NovelTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NovelTagCountAggregateInputType | true
    _avg?: NovelTagAvgAggregateInputType
    _sum?: NovelTagSumAggregateInputType
    _min?: NovelTagMinAggregateInputType
    _max?: NovelTagMaxAggregateInputType
  }

  export type NovelTagGroupByOutputType = {
    novelId: number
    tagId: number
    _count: NovelTagCountAggregateOutputType | null
    _avg: NovelTagAvgAggregateOutputType | null
    _sum: NovelTagSumAggregateOutputType | null
    _min: NovelTagMinAggregateOutputType | null
    _max: NovelTagMaxAggregateOutputType | null
  }

  type GetNovelTagGroupByPayload<T extends NovelTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NovelTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NovelTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NovelTagGroupByOutputType[P]>
            : GetScalarType<T[P], NovelTagGroupByOutputType[P]>
        }
      >
    >


  export type NovelTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    novelId?: boolean
    tagId?: boolean
    novel?: boolean | NovelDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["novelTag"]>

  export type NovelTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    novelId?: boolean
    tagId?: boolean
    novel?: boolean | NovelDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["novelTag"]>

  export type NovelTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    novelId?: boolean
    tagId?: boolean
    novel?: boolean | NovelDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["novelTag"]>

  export type NovelTagSelectScalar = {
    novelId?: boolean
    tagId?: boolean
  }

  export type NovelTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"novelId" | "tagId", ExtArgs["result"]["novelTag"]>
  export type NovelTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    novel?: boolean | NovelDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type NovelTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    novel?: boolean | NovelDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type NovelTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    novel?: boolean | NovelDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $NovelTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NovelTag"
    objects: {
      novel: Prisma.$NovelPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      novelId: number
      tagId: number
    }, ExtArgs["result"]["novelTag"]>
    composites: {}
  }

  type NovelTagGetPayload<S extends boolean | null | undefined | NovelTagDefaultArgs> = $Result.GetResult<Prisma.$NovelTagPayload, S>

  type NovelTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NovelTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NovelTagCountAggregateInputType | true
    }

  export interface NovelTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NovelTag'], meta: { name: 'NovelTag' } }
    /**
     * Find zero or one NovelTag that matches the filter.
     * @param {NovelTagFindUniqueArgs} args - Arguments to find a NovelTag
     * @example
     * // Get one NovelTag
     * const novelTag = await prisma.novelTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NovelTagFindUniqueArgs>(args: SelectSubset<T, NovelTagFindUniqueArgs<ExtArgs>>): Prisma__NovelTagClient<$Result.GetResult<Prisma.$NovelTagPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one NovelTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NovelTagFindUniqueOrThrowArgs} args - Arguments to find a NovelTag
     * @example
     * // Get one NovelTag
     * const novelTag = await prisma.novelTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NovelTagFindUniqueOrThrowArgs>(args: SelectSubset<T, NovelTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NovelTagClient<$Result.GetResult<Prisma.$NovelTagPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first NovelTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NovelTagFindFirstArgs} args - Arguments to find a NovelTag
     * @example
     * // Get one NovelTag
     * const novelTag = await prisma.novelTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NovelTagFindFirstArgs>(args?: SelectSubset<T, NovelTagFindFirstArgs<ExtArgs>>): Prisma__NovelTagClient<$Result.GetResult<Prisma.$NovelTagPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first NovelTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NovelTagFindFirstOrThrowArgs} args - Arguments to find a NovelTag
     * @example
     * // Get one NovelTag
     * const novelTag = await prisma.novelTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NovelTagFindFirstOrThrowArgs>(args?: SelectSubset<T, NovelTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__NovelTagClient<$Result.GetResult<Prisma.$NovelTagPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more NovelTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NovelTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NovelTags
     * const novelTags = await prisma.novelTag.findMany()
     * 
     * // Get first 10 NovelTags
     * const novelTags = await prisma.novelTag.findMany({ take: 10 })
     * 
     * // Only select the `novelId`
     * const novelTagWithNovelIdOnly = await prisma.novelTag.findMany({ select: { novelId: true } })
     * 
     */
    findMany<T extends NovelTagFindManyArgs>(args?: SelectSubset<T, NovelTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NovelTagPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a NovelTag.
     * @param {NovelTagCreateArgs} args - Arguments to create a NovelTag.
     * @example
     * // Create one NovelTag
     * const NovelTag = await prisma.novelTag.create({
     *   data: {
     *     // ... data to create a NovelTag
     *   }
     * })
     * 
     */
    create<T extends NovelTagCreateArgs>(args: SelectSubset<T, NovelTagCreateArgs<ExtArgs>>): Prisma__NovelTagClient<$Result.GetResult<Prisma.$NovelTagPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many NovelTags.
     * @param {NovelTagCreateManyArgs} args - Arguments to create many NovelTags.
     * @example
     * // Create many NovelTags
     * const novelTag = await prisma.novelTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NovelTagCreateManyArgs>(args?: SelectSubset<T, NovelTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NovelTags and returns the data saved in the database.
     * @param {NovelTagCreateManyAndReturnArgs} args - Arguments to create many NovelTags.
     * @example
     * // Create many NovelTags
     * const novelTag = await prisma.novelTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NovelTags and only return the `novelId`
     * const novelTagWithNovelIdOnly = await prisma.novelTag.createManyAndReturn({
     *   select: { novelId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NovelTagCreateManyAndReturnArgs>(args?: SelectSubset<T, NovelTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NovelTagPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a NovelTag.
     * @param {NovelTagDeleteArgs} args - Arguments to delete one NovelTag.
     * @example
     * // Delete one NovelTag
     * const NovelTag = await prisma.novelTag.delete({
     *   where: {
     *     // ... filter to delete one NovelTag
     *   }
     * })
     * 
     */
    delete<T extends NovelTagDeleteArgs>(args: SelectSubset<T, NovelTagDeleteArgs<ExtArgs>>): Prisma__NovelTagClient<$Result.GetResult<Prisma.$NovelTagPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one NovelTag.
     * @param {NovelTagUpdateArgs} args - Arguments to update one NovelTag.
     * @example
     * // Update one NovelTag
     * const novelTag = await prisma.novelTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NovelTagUpdateArgs>(args: SelectSubset<T, NovelTagUpdateArgs<ExtArgs>>): Prisma__NovelTagClient<$Result.GetResult<Prisma.$NovelTagPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more NovelTags.
     * @param {NovelTagDeleteManyArgs} args - Arguments to filter NovelTags to delete.
     * @example
     * // Delete a few NovelTags
     * const { count } = await prisma.novelTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NovelTagDeleteManyArgs>(args?: SelectSubset<T, NovelTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NovelTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NovelTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NovelTags
     * const novelTag = await prisma.novelTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NovelTagUpdateManyArgs>(args: SelectSubset<T, NovelTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NovelTags and returns the data updated in the database.
     * @param {NovelTagUpdateManyAndReturnArgs} args - Arguments to update many NovelTags.
     * @example
     * // Update many NovelTags
     * const novelTag = await prisma.novelTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NovelTags and only return the `novelId`
     * const novelTagWithNovelIdOnly = await prisma.novelTag.updateManyAndReturn({
     *   select: { novelId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NovelTagUpdateManyAndReturnArgs>(args: SelectSubset<T, NovelTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NovelTagPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one NovelTag.
     * @param {NovelTagUpsertArgs} args - Arguments to update or create a NovelTag.
     * @example
     * // Update or create a NovelTag
     * const novelTag = await prisma.novelTag.upsert({
     *   create: {
     *     // ... data to create a NovelTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NovelTag we want to update
     *   }
     * })
     */
    upsert<T extends NovelTagUpsertArgs>(args: SelectSubset<T, NovelTagUpsertArgs<ExtArgs>>): Prisma__NovelTagClient<$Result.GetResult<Prisma.$NovelTagPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of NovelTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NovelTagCountArgs} args - Arguments to filter NovelTags to count.
     * @example
     * // Count the number of NovelTags
     * const count = await prisma.novelTag.count({
     *   where: {
     *     // ... the filter for the NovelTags we want to count
     *   }
     * })
    **/
    count<T extends NovelTagCountArgs>(
      args?: Subset<T, NovelTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NovelTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NovelTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NovelTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NovelTagAggregateArgs>(args: Subset<T, NovelTagAggregateArgs>): Prisma.PrismaPromise<GetNovelTagAggregateType<T>>

    /**
     * Group by NovelTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NovelTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NovelTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NovelTagGroupByArgs['orderBy'] }
        : { orderBy?: NovelTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NovelTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNovelTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NovelTag model
   */
  readonly fields: NovelTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NovelTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NovelTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    novel<T extends NovelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NovelDefaultArgs<ExtArgs>>): Prisma__NovelClient<$Result.GetResult<Prisma.$NovelPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NovelTag model
   */ 
  interface NovelTagFieldRefs {
    readonly novelId: FieldRef<"NovelTag", 'Int'>
    readonly tagId: FieldRef<"NovelTag", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * NovelTag findUnique
   */
  export type NovelTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelTag
     */
    select?: NovelTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NovelTag
     */
    omit?: NovelTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelTagInclude<ExtArgs> | null
    /**
     * Filter, which NovelTag to fetch.
     */
    where: NovelTagWhereUniqueInput
  }

  /**
   * NovelTag findUniqueOrThrow
   */
  export type NovelTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelTag
     */
    select?: NovelTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NovelTag
     */
    omit?: NovelTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelTagInclude<ExtArgs> | null
    /**
     * Filter, which NovelTag to fetch.
     */
    where: NovelTagWhereUniqueInput
  }

  /**
   * NovelTag findFirst
   */
  export type NovelTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelTag
     */
    select?: NovelTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NovelTag
     */
    omit?: NovelTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelTagInclude<ExtArgs> | null
    /**
     * Filter, which NovelTag to fetch.
     */
    where?: NovelTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NovelTags to fetch.
     */
    orderBy?: NovelTagOrderByWithRelationInput | NovelTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NovelTags.
     */
    cursor?: NovelTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NovelTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NovelTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NovelTags.
     */
    distinct?: NovelTagScalarFieldEnum | NovelTagScalarFieldEnum[]
  }

  /**
   * NovelTag findFirstOrThrow
   */
  export type NovelTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelTag
     */
    select?: NovelTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NovelTag
     */
    omit?: NovelTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelTagInclude<ExtArgs> | null
    /**
     * Filter, which NovelTag to fetch.
     */
    where?: NovelTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NovelTags to fetch.
     */
    orderBy?: NovelTagOrderByWithRelationInput | NovelTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NovelTags.
     */
    cursor?: NovelTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NovelTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NovelTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NovelTags.
     */
    distinct?: NovelTagScalarFieldEnum | NovelTagScalarFieldEnum[]
  }

  /**
   * NovelTag findMany
   */
  export type NovelTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelTag
     */
    select?: NovelTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NovelTag
     */
    omit?: NovelTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelTagInclude<ExtArgs> | null
    /**
     * Filter, which NovelTags to fetch.
     */
    where?: NovelTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NovelTags to fetch.
     */
    orderBy?: NovelTagOrderByWithRelationInput | NovelTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NovelTags.
     */
    cursor?: NovelTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NovelTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NovelTags.
     */
    skip?: number
    distinct?: NovelTagScalarFieldEnum | NovelTagScalarFieldEnum[]
  }

  /**
   * NovelTag create
   */
  export type NovelTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelTag
     */
    select?: NovelTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NovelTag
     */
    omit?: NovelTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelTagInclude<ExtArgs> | null
    /**
     * The data needed to create a NovelTag.
     */
    data: XOR<NovelTagCreateInput, NovelTagUncheckedCreateInput>
  }

  /**
   * NovelTag createMany
   */
  export type NovelTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NovelTags.
     */
    data: NovelTagCreateManyInput | NovelTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NovelTag createManyAndReturn
   */
  export type NovelTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelTag
     */
    select?: NovelTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NovelTag
     */
    omit?: NovelTagOmit<ExtArgs> | null
    /**
     * The data used to create many NovelTags.
     */
    data: NovelTagCreateManyInput | NovelTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NovelTag update
   */
  export type NovelTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelTag
     */
    select?: NovelTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NovelTag
     */
    omit?: NovelTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelTagInclude<ExtArgs> | null
    /**
     * The data needed to update a NovelTag.
     */
    data: XOR<NovelTagUpdateInput, NovelTagUncheckedUpdateInput>
    /**
     * Choose, which NovelTag to update.
     */
    where: NovelTagWhereUniqueInput
  }

  /**
   * NovelTag updateMany
   */
  export type NovelTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NovelTags.
     */
    data: XOR<NovelTagUpdateManyMutationInput, NovelTagUncheckedUpdateManyInput>
    /**
     * Filter which NovelTags to update
     */
    where?: NovelTagWhereInput
    /**
     * Limit how many NovelTags to update.
     */
    limit?: number
  }

  /**
   * NovelTag updateManyAndReturn
   */
  export type NovelTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelTag
     */
    select?: NovelTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NovelTag
     */
    omit?: NovelTagOmit<ExtArgs> | null
    /**
     * The data used to update NovelTags.
     */
    data: XOR<NovelTagUpdateManyMutationInput, NovelTagUncheckedUpdateManyInput>
    /**
     * Filter which NovelTags to update
     */
    where?: NovelTagWhereInput
    /**
     * Limit how many NovelTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NovelTag upsert
   */
  export type NovelTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelTag
     */
    select?: NovelTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NovelTag
     */
    omit?: NovelTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelTagInclude<ExtArgs> | null
    /**
     * The filter to search for the NovelTag to update in case it exists.
     */
    where: NovelTagWhereUniqueInput
    /**
     * In case the NovelTag found by the `where` argument doesn't exist, create a new NovelTag with this data.
     */
    create: XOR<NovelTagCreateInput, NovelTagUncheckedCreateInput>
    /**
     * In case the NovelTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NovelTagUpdateInput, NovelTagUncheckedUpdateInput>
  }

  /**
   * NovelTag delete
   */
  export type NovelTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelTag
     */
    select?: NovelTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NovelTag
     */
    omit?: NovelTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelTagInclude<ExtArgs> | null
    /**
     * Filter which NovelTag to delete.
     */
    where: NovelTagWhereUniqueInput
  }

  /**
   * NovelTag deleteMany
   */
  export type NovelTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NovelTags to delete
     */
    where?: NovelTagWhereInput
    /**
     * Limit how many NovelTags to delete.
     */
    limit?: number
  }

  /**
   * NovelTag without action
   */
  export type NovelTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelTag
     */
    select?: NovelTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NovelTag
     */
    omit?: NovelTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelTagInclude<ExtArgs> | null
  }


  /**
   * Model Chapter
   */

  export type AggregateChapter = {
    _count: ChapterCountAggregateOutputType | null
    _avg: ChapterAvgAggregateOutputType | null
    _sum: ChapterSumAggregateOutputType | null
    _min: ChapterMinAggregateOutputType | null
    _max: ChapterMaxAggregateOutputType | null
  }

  export type ChapterAvgAggregateOutputType = {
    id: number | null
    novelId: number | null
    chapterNumber: number | null
    unlockCost: number | null
  }

  export type ChapterSumAggregateOutputType = {
    id: number | null
    novelId: number | null
    chapterNumber: number | null
    unlockCost: number | null
  }

  export type ChapterMinAggregateOutputType = {
    id: number | null
    novelId: number | null
    chapterNumber: number | null
    title: string | null
    content: string | null
    isLocked: boolean | null
    unlockCost: number | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChapterMaxAggregateOutputType = {
    id: number | null
    novelId: number | null
    chapterNumber: number | null
    title: string | null
    content: string | null
    isLocked: boolean | null
    unlockCost: number | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChapterCountAggregateOutputType = {
    id: number
    novelId: number
    chapterNumber: number
    title: number
    content: number
    isLocked: number
    unlockCost: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChapterAvgAggregateInputType = {
    id?: true
    novelId?: true
    chapterNumber?: true
    unlockCost?: true
  }

  export type ChapterSumAggregateInputType = {
    id?: true
    novelId?: true
    chapterNumber?: true
    unlockCost?: true
  }

  export type ChapterMinAggregateInputType = {
    id?: true
    novelId?: true
    chapterNumber?: true
    title?: true
    content?: true
    isLocked?: true
    unlockCost?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChapterMaxAggregateInputType = {
    id?: true
    novelId?: true
    chapterNumber?: true
    title?: true
    content?: true
    isLocked?: true
    unlockCost?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChapterCountAggregateInputType = {
    id?: true
    novelId?: true
    chapterNumber?: true
    title?: true
    content?: true
    isLocked?: true
    unlockCost?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChapterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chapter to aggregate.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chapters
    **/
    _count?: true | ChapterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChapterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChapterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChapterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChapterMaxAggregateInputType
  }

  export type GetChapterAggregateType<T extends ChapterAggregateArgs> = {
        [P in keyof T & keyof AggregateChapter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapter[P]>
      : GetScalarType<T[P], AggregateChapter[P]>
  }




  export type ChapterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterWhereInput
    orderBy?: ChapterOrderByWithAggregationInput | ChapterOrderByWithAggregationInput[]
    by: ChapterScalarFieldEnum[] | ChapterScalarFieldEnum
    having?: ChapterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChapterCountAggregateInputType | true
    _avg?: ChapterAvgAggregateInputType
    _sum?: ChapterSumAggregateInputType
    _min?: ChapterMinAggregateInputType
    _max?: ChapterMaxAggregateInputType
  }

  export type ChapterGroupByOutputType = {
    id: number
    novelId: number
    chapterNumber: number
    title: string
    content: string
    isLocked: boolean
    unlockCost: number
    publishedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: ChapterCountAggregateOutputType | null
    _avg: ChapterAvgAggregateOutputType | null
    _sum: ChapterSumAggregateOutputType | null
    _min: ChapterMinAggregateOutputType | null
    _max: ChapterMaxAggregateOutputType | null
  }

  type GetChapterGroupByPayload<T extends ChapterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChapterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChapterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChapterGroupByOutputType[P]>
            : GetScalarType<T[P], ChapterGroupByOutputType[P]>
        }
      >
    >


  export type ChapterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    novelId?: boolean
    chapterNumber?: boolean
    title?: boolean
    content?: boolean
    isLocked?: boolean
    unlockCost?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    novel?: boolean | NovelDefaultArgs<ExtArgs>
    comments?: boolean | Chapter$commentsArgs<ExtArgs>
    statistics?: boolean | Chapter$statisticsArgs<ExtArgs>
    reading?: boolean | Chapter$readingArgs<ExtArgs>
    _count?: boolean | ChapterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type ChapterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    novelId?: boolean
    chapterNumber?: boolean
    title?: boolean
    content?: boolean
    isLocked?: boolean
    unlockCost?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    novel?: boolean | NovelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type ChapterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    novelId?: boolean
    chapterNumber?: boolean
    title?: boolean
    content?: boolean
    isLocked?: boolean
    unlockCost?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    novel?: boolean | NovelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapter"]>

  export type ChapterSelectScalar = {
    id?: boolean
    novelId?: boolean
    chapterNumber?: boolean
    title?: boolean
    content?: boolean
    isLocked?: boolean
    unlockCost?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChapterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "novelId" | "chapterNumber" | "title" | "content" | "isLocked" | "unlockCost" | "publishedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["chapter"]>
  export type ChapterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    novel?: boolean | NovelDefaultArgs<ExtArgs>
    comments?: boolean | Chapter$commentsArgs<ExtArgs>
    statistics?: boolean | Chapter$statisticsArgs<ExtArgs>
    reading?: boolean | Chapter$readingArgs<ExtArgs>
    _count?: boolean | ChapterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChapterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    novel?: boolean | NovelDefaultArgs<ExtArgs>
  }
  export type ChapterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    novel?: boolean | NovelDefaultArgs<ExtArgs>
  }

  export type $ChapterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chapter"
    objects: {
      novel: Prisma.$NovelPayload<ExtArgs>
      comments: Prisma.$CommentPayload<ExtArgs>[]
      statistics: Prisma.$ChapterStatisticPayload<ExtArgs>[]
      reading: Prisma.$ReadingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      novelId: number
      chapterNumber: number
      title: string
      content: string
      isLocked: boolean
      unlockCost: number
      publishedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chapter"]>
    composites: {}
  }

  type ChapterGetPayload<S extends boolean | null | undefined | ChapterDefaultArgs> = $Result.GetResult<Prisma.$ChapterPayload, S>

  type ChapterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChapterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChapterCountAggregateInputType | true
    }

  export interface ChapterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chapter'], meta: { name: 'Chapter' } }
    /**
     * Find zero or one Chapter that matches the filter.
     * @param {ChapterFindUniqueArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChapterFindUniqueArgs>(args: SelectSubset<T, ChapterFindUniqueArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Chapter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChapterFindUniqueOrThrowArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChapterFindUniqueOrThrowArgs>(args: SelectSubset<T, ChapterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Chapter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindFirstArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChapterFindFirstArgs>(args?: SelectSubset<T, ChapterFindFirstArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Chapter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindFirstOrThrowArgs} args - Arguments to find a Chapter
     * @example
     * // Get one Chapter
     * const chapter = await prisma.chapter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChapterFindFirstOrThrowArgs>(args?: SelectSubset<T, ChapterFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Chapters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chapters
     * const chapters = await prisma.chapter.findMany()
     * 
     * // Get first 10 Chapters
     * const chapters = await prisma.chapter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chapterWithIdOnly = await prisma.chapter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChapterFindManyArgs>(args?: SelectSubset<T, ChapterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Chapter.
     * @param {ChapterCreateArgs} args - Arguments to create a Chapter.
     * @example
     * // Create one Chapter
     * const Chapter = await prisma.chapter.create({
     *   data: {
     *     // ... data to create a Chapter
     *   }
     * })
     * 
     */
    create<T extends ChapterCreateArgs>(args: SelectSubset<T, ChapterCreateArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Chapters.
     * @param {ChapterCreateManyArgs} args - Arguments to create many Chapters.
     * @example
     * // Create many Chapters
     * const chapter = await prisma.chapter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChapterCreateManyArgs>(args?: SelectSubset<T, ChapterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chapters and returns the data saved in the database.
     * @param {ChapterCreateManyAndReturnArgs} args - Arguments to create many Chapters.
     * @example
     * // Create many Chapters
     * const chapter = await prisma.chapter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chapters and only return the `id`
     * const chapterWithIdOnly = await prisma.chapter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChapterCreateManyAndReturnArgs>(args?: SelectSubset<T, ChapterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Chapter.
     * @param {ChapterDeleteArgs} args - Arguments to delete one Chapter.
     * @example
     * // Delete one Chapter
     * const Chapter = await prisma.chapter.delete({
     *   where: {
     *     // ... filter to delete one Chapter
     *   }
     * })
     * 
     */
    delete<T extends ChapterDeleteArgs>(args: SelectSubset<T, ChapterDeleteArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Chapter.
     * @param {ChapterUpdateArgs} args - Arguments to update one Chapter.
     * @example
     * // Update one Chapter
     * const chapter = await prisma.chapter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChapterUpdateArgs>(args: SelectSubset<T, ChapterUpdateArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Chapters.
     * @param {ChapterDeleteManyArgs} args - Arguments to filter Chapters to delete.
     * @example
     * // Delete a few Chapters
     * const { count } = await prisma.chapter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChapterDeleteManyArgs>(args?: SelectSubset<T, ChapterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chapters
     * const chapter = await prisma.chapter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChapterUpdateManyArgs>(args: SelectSubset<T, ChapterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chapters and returns the data updated in the database.
     * @param {ChapterUpdateManyAndReturnArgs} args - Arguments to update many Chapters.
     * @example
     * // Update many Chapters
     * const chapter = await prisma.chapter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chapters and only return the `id`
     * const chapterWithIdOnly = await prisma.chapter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChapterUpdateManyAndReturnArgs>(args: SelectSubset<T, ChapterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Chapter.
     * @param {ChapterUpsertArgs} args - Arguments to update or create a Chapter.
     * @example
     * // Update or create a Chapter
     * const chapter = await prisma.chapter.upsert({
     *   create: {
     *     // ... data to create a Chapter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chapter we want to update
     *   }
     * })
     */
    upsert<T extends ChapterUpsertArgs>(args: SelectSubset<T, ChapterUpsertArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Chapters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterCountArgs} args - Arguments to filter Chapters to count.
     * @example
     * // Count the number of Chapters
     * const count = await prisma.chapter.count({
     *   where: {
     *     // ... the filter for the Chapters we want to count
     *   }
     * })
    **/
    count<T extends ChapterCountArgs>(
      args?: Subset<T, ChapterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChapterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChapterAggregateArgs>(args: Subset<T, ChapterAggregateArgs>): Prisma.PrismaPromise<GetChapterAggregateType<T>>

    /**
     * Group by Chapter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChapterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChapterGroupByArgs['orderBy'] }
        : { orderBy?: ChapterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChapterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chapter model
   */
  readonly fields: ChapterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chapter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChapterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    novel<T extends NovelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NovelDefaultArgs<ExtArgs>>): Prisma__NovelClient<$Result.GetResult<Prisma.$NovelPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    comments<T extends Chapter$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Chapter$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    statistics<T extends Chapter$statisticsArgs<ExtArgs> = {}>(args?: Subset<T, Chapter$statisticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterStatisticPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    reading<T extends Chapter$readingArgs<ExtArgs> = {}>(args?: Subset<T, Chapter$readingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReadingPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chapter model
   */ 
  interface ChapterFieldRefs {
    readonly id: FieldRef<"Chapter", 'Int'>
    readonly novelId: FieldRef<"Chapter", 'Int'>
    readonly chapterNumber: FieldRef<"Chapter", 'Int'>
    readonly title: FieldRef<"Chapter", 'String'>
    readonly content: FieldRef<"Chapter", 'String'>
    readonly isLocked: FieldRef<"Chapter", 'Boolean'>
    readonly unlockCost: FieldRef<"Chapter", 'Int'>
    readonly publishedAt: FieldRef<"Chapter", 'DateTime'>
    readonly createdAt: FieldRef<"Chapter", 'DateTime'>
    readonly updatedAt: FieldRef<"Chapter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chapter findUnique
   */
  export type ChapterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter findUniqueOrThrow
   */
  export type ChapterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter findFirst
   */
  export type ChapterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chapters.
     */
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter findFirstOrThrow
   */
  export type ChapterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapter to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chapters.
     */
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter findMany
   */
  export type ChapterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter, which Chapters to fetch.
     */
    where?: ChapterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chapters to fetch.
     */
    orderBy?: ChapterOrderByWithRelationInput | ChapterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chapters.
     */
    cursor?: ChapterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chapters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chapters.
     */
    skip?: number
    distinct?: ChapterScalarFieldEnum | ChapterScalarFieldEnum[]
  }

  /**
   * Chapter create
   */
  export type ChapterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The data needed to create a Chapter.
     */
    data: XOR<ChapterCreateInput, ChapterUncheckedCreateInput>
  }

  /**
   * Chapter createMany
   */
  export type ChapterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chapters.
     */
    data: ChapterCreateManyInput | ChapterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chapter createManyAndReturn
   */
  export type ChapterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * The data used to create many Chapters.
     */
    data: ChapterCreateManyInput | ChapterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chapter update
   */
  export type ChapterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The data needed to update a Chapter.
     */
    data: XOR<ChapterUpdateInput, ChapterUncheckedUpdateInput>
    /**
     * Choose, which Chapter to update.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter updateMany
   */
  export type ChapterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chapters.
     */
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyInput>
    /**
     * Filter which Chapters to update
     */
    where?: ChapterWhereInput
    /**
     * Limit how many Chapters to update.
     */
    limit?: number
  }

  /**
   * Chapter updateManyAndReturn
   */
  export type ChapterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * The data used to update Chapters.
     */
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyInput>
    /**
     * Filter which Chapters to update
     */
    where?: ChapterWhereInput
    /**
     * Limit how many Chapters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chapter upsert
   */
  export type ChapterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * The filter to search for the Chapter to update in case it exists.
     */
    where: ChapterWhereUniqueInput
    /**
     * In case the Chapter found by the `where` argument doesn't exist, create a new Chapter with this data.
     */
    create: XOR<ChapterCreateInput, ChapterUncheckedCreateInput>
    /**
     * In case the Chapter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChapterUpdateInput, ChapterUncheckedUpdateInput>
  }

  /**
   * Chapter delete
   */
  export type ChapterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
    /**
     * Filter which Chapter to delete.
     */
    where: ChapterWhereUniqueInput
  }

  /**
   * Chapter deleteMany
   */
  export type ChapterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chapters to delete
     */
    where?: ChapterWhereInput
    /**
     * Limit how many Chapters to delete.
     */
    limit?: number
  }

  /**
   * Chapter.comments
   */
  export type Chapter$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Chapter.statistics
   */
  export type Chapter$statisticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterStatistic
     */
    select?: ChapterStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterStatistic
     */
    omit?: ChapterStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterStatisticInclude<ExtArgs> | null
    where?: ChapterStatisticWhereInput
    orderBy?: ChapterStatisticOrderByWithRelationInput | ChapterStatisticOrderByWithRelationInput[]
    cursor?: ChapterStatisticWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChapterStatisticScalarFieldEnum | ChapterStatisticScalarFieldEnum[]
  }

  /**
   * Chapter.reading
   */
  export type Chapter$readingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading
     */
    select?: ReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading
     */
    omit?: ReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingInclude<ExtArgs> | null
    where?: ReadingWhereInput
    orderBy?: ReadingOrderByWithRelationInput | ReadingOrderByWithRelationInput[]
    cursor?: ReadingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReadingScalarFieldEnum | ReadingScalarFieldEnum[]
  }

  /**
   * Chapter without action
   */
  export type ChapterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chapter
     */
    select?: ChapterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chapter
     */
    omit?: ChapterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    id: number | null
    rating: number | null
    userId: number | null
    novelId: number | null
  }

  export type ReviewSumAggregateOutputType = {
    id: number | null
    rating: number | null
    userId: number | null
    novelId: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: number | null
    rating: number | null
    content: string | null
    isSpoiler: boolean | null
    userId: number | null
    novelId: number | null
    createdAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: number | null
    rating: number | null
    content: string | null
    isSpoiler: boolean | null
    userId: number | null
    novelId: number | null
    createdAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    rating: number
    content: number
    isSpoiler: number
    userId: number
    novelId: number
    createdAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    id?: true
    rating?: true
    userId?: true
    novelId?: true
  }

  export type ReviewSumAggregateInputType = {
    id?: true
    rating?: true
    userId?: true
    novelId?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    rating?: true
    content?: true
    isSpoiler?: true
    userId?: true
    novelId?: true
    createdAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    rating?: true
    content?: true
    isSpoiler?: true
    userId?: true
    novelId?: true
    createdAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    rating?: true
    content?: true
    isSpoiler?: true
    userId?: true
    novelId?: true
    createdAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: number
    rating: number
    content: string
    isSpoiler: boolean
    userId: number
    novelId: number
    createdAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    content?: boolean
    isSpoiler?: boolean
    userId?: boolean
    novelId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    novel?: boolean | NovelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    content?: boolean
    isSpoiler?: boolean
    userId?: boolean
    novelId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    novel?: boolean | NovelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rating?: boolean
    content?: boolean
    isSpoiler?: boolean
    userId?: boolean
    novelId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    novel?: boolean | NovelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    rating?: boolean
    content?: boolean
    isSpoiler?: boolean
    userId?: boolean
    novelId?: boolean
    createdAt?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rating" | "content" | "isSpoiler" | "userId" | "novelId" | "createdAt", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    novel?: boolean | NovelDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    novel?: boolean | NovelDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    novel?: boolean | NovelDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      novel: Prisma.$NovelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rating: number
      content: string
      isSpoiler: boolean
      userId: number
      novelId: number
      createdAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    novel<T extends NovelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NovelDefaultArgs<ExtArgs>>): Prisma__NovelClient<$Result.GetResult<Prisma.$NovelPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */ 
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'Int'>
    readonly rating: FieldRef<"Review", 'Float'>
    readonly content: FieldRef<"Review", 'String'>
    readonly isSpoiler: FieldRef<"Review", 'Boolean'>
    readonly userId: FieldRef<"Review", 'Int'>
    readonly novelId: FieldRef<"Review", 'Int'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    id: number | null
    likes: number | null
    userId: number | null
    chapterId: number | null
    novelId: number | null
  }

  export type CommentSumAggregateOutputType = {
    id: number | null
    likes: number | null
    userId: number | null
    chapterId: number | null
    novelId: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: number | null
    content: string | null
    likes: number | null
    userId: number | null
    chapterId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    novelId: number | null
  }

  export type CommentMaxAggregateOutputType = {
    id: number | null
    content: string | null
    likes: number | null
    userId: number | null
    chapterId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    novelId: number | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    content: number
    likes: number
    userId: number
    chapterId: number
    createdAt: number
    updatedAt: number
    novelId: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    id?: true
    likes?: true
    userId?: true
    chapterId?: true
    novelId?: true
  }

  export type CommentSumAggregateInputType = {
    id?: true
    likes?: true
    userId?: true
    chapterId?: true
    novelId?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    content?: true
    likes?: true
    userId?: true
    chapterId?: true
    createdAt?: true
    updatedAt?: true
    novelId?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    content?: true
    likes?: true
    userId?: true
    chapterId?: true
    createdAt?: true
    updatedAt?: true
    novelId?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    content?: true
    likes?: true
    userId?: true
    chapterId?: true
    createdAt?: true
    updatedAt?: true
    novelId?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: number
    content: string
    likes: number
    userId: number
    chapterId: number
    createdAt: Date
    updatedAt: Date
    novelId: number | null
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    likes?: boolean
    userId?: boolean
    chapterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    novelId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    Novel?: boolean | Comment$NovelArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    likes?: boolean
    userId?: boolean
    chapterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    novelId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    Novel?: boolean | Comment$NovelArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    likes?: boolean
    userId?: boolean
    chapterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    novelId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    Novel?: boolean | Comment$NovelArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    content?: boolean
    likes?: boolean
    userId?: boolean
    chapterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    novelId?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "likes" | "userId" | "chapterId" | "createdAt" | "updatedAt" | "novelId", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    Novel?: boolean | Comment$NovelArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    Novel?: boolean | Comment$NovelArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
    Novel?: boolean | Comment$NovelArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      chapter: Prisma.$ChapterPayload<ExtArgs>
      replies: Prisma.$ReplyCommentPayload<ExtArgs>[]
      Novel: Prisma.$NovelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      content: string
      likes: number
      userId: number
      chapterId: number
      createdAt: Date
      updatedAt: Date
      novelId: number | null
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    chapter<T extends ChapterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChapterDefaultArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    replies<T extends Comment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReplyCommentPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Novel<T extends Comment$NovelArgs<ExtArgs> = {}>(args?: Subset<T, Comment$NovelArgs<ExtArgs>>): Prisma__NovelClient<$Result.GetResult<Prisma.$NovelPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'Int'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly likes: FieldRef<"Comment", 'Int'>
    readonly userId: FieldRef<"Comment", 'Int'>
    readonly chapterId: FieldRef<"Comment", 'Int'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
    readonly novelId: FieldRef<"Comment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.replies
   */
  export type Comment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReplyComment
     */
    select?: ReplyCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReplyComment
     */
    omit?: ReplyCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyCommentInclude<ExtArgs> | null
    where?: ReplyCommentWhereInput
    orderBy?: ReplyCommentOrderByWithRelationInput | ReplyCommentOrderByWithRelationInput[]
    cursor?: ReplyCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReplyCommentScalarFieldEnum | ReplyCommentScalarFieldEnum[]
  }

  /**
   * Comment.Novel
   */
  export type Comment$NovelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Novel
     */
    select?: NovelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Novel
     */
    omit?: NovelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelInclude<ExtArgs> | null
    where?: NovelWhereInput
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model ReplyComment
   */

  export type AggregateReplyComment = {
    _count: ReplyCommentCountAggregateOutputType | null
    _avg: ReplyCommentAvgAggregateOutputType | null
    _sum: ReplyCommentSumAggregateOutputType | null
    _min: ReplyCommentMinAggregateOutputType | null
    _max: ReplyCommentMaxAggregateOutputType | null
  }

  export type ReplyCommentAvgAggregateOutputType = {
    id: number | null
    likes: number | null
    userId: number | null
    commentId: number | null
  }

  export type ReplyCommentSumAggregateOutputType = {
    id: number | null
    likes: number | null
    userId: number | null
    commentId: number | null
  }

  export type ReplyCommentMinAggregateOutputType = {
    id: number | null
    content: string | null
    likes: number | null
    userId: number | null
    commentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReplyCommentMaxAggregateOutputType = {
    id: number | null
    content: string | null
    likes: number | null
    userId: number | null
    commentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReplyCommentCountAggregateOutputType = {
    id: number
    content: number
    likes: number
    userId: number
    commentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReplyCommentAvgAggregateInputType = {
    id?: true
    likes?: true
    userId?: true
    commentId?: true
  }

  export type ReplyCommentSumAggregateInputType = {
    id?: true
    likes?: true
    userId?: true
    commentId?: true
  }

  export type ReplyCommentMinAggregateInputType = {
    id?: true
    content?: true
    likes?: true
    userId?: true
    commentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReplyCommentMaxAggregateInputType = {
    id?: true
    content?: true
    likes?: true
    userId?: true
    commentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReplyCommentCountAggregateInputType = {
    id?: true
    content?: true
    likes?: true
    userId?: true
    commentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReplyCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReplyComment to aggregate.
     */
    where?: ReplyCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReplyComments to fetch.
     */
    orderBy?: ReplyCommentOrderByWithRelationInput | ReplyCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReplyCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReplyComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReplyComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReplyComments
    **/
    _count?: true | ReplyCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReplyCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReplyCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReplyCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReplyCommentMaxAggregateInputType
  }

  export type GetReplyCommentAggregateType<T extends ReplyCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateReplyComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReplyComment[P]>
      : GetScalarType<T[P], AggregateReplyComment[P]>
  }




  export type ReplyCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReplyCommentWhereInput
    orderBy?: ReplyCommentOrderByWithAggregationInput | ReplyCommentOrderByWithAggregationInput[]
    by: ReplyCommentScalarFieldEnum[] | ReplyCommentScalarFieldEnum
    having?: ReplyCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReplyCommentCountAggregateInputType | true
    _avg?: ReplyCommentAvgAggregateInputType
    _sum?: ReplyCommentSumAggregateInputType
    _min?: ReplyCommentMinAggregateInputType
    _max?: ReplyCommentMaxAggregateInputType
  }

  export type ReplyCommentGroupByOutputType = {
    id: number
    content: string
    likes: number
    userId: number
    commentId: number
    createdAt: Date
    updatedAt: Date
    _count: ReplyCommentCountAggregateOutputType | null
    _avg: ReplyCommentAvgAggregateOutputType | null
    _sum: ReplyCommentSumAggregateOutputType | null
    _min: ReplyCommentMinAggregateOutputType | null
    _max: ReplyCommentMaxAggregateOutputType | null
  }

  type GetReplyCommentGroupByPayload<T extends ReplyCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReplyCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReplyCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReplyCommentGroupByOutputType[P]>
            : GetScalarType<T[P], ReplyCommentGroupByOutputType[P]>
        }
      >
    >


  export type ReplyCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    likes?: boolean
    userId?: boolean
    commentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["replyComment"]>

  export type ReplyCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    likes?: boolean
    userId?: boolean
    commentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["replyComment"]>

  export type ReplyCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    likes?: boolean
    userId?: boolean
    commentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["replyComment"]>

  export type ReplyCommentSelectScalar = {
    id?: boolean
    content?: boolean
    likes?: boolean
    userId?: boolean
    commentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReplyCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "likes" | "userId" | "commentId" | "createdAt" | "updatedAt", ExtArgs["result"]["replyComment"]>
  export type ReplyCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }
  export type ReplyCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }
  export type ReplyCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    comment?: boolean | CommentDefaultArgs<ExtArgs>
  }

  export type $ReplyCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReplyComment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      comment: Prisma.$CommentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      content: string
      likes: number
      userId: number
      commentId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["replyComment"]>
    composites: {}
  }

  type ReplyCommentGetPayload<S extends boolean | null | undefined | ReplyCommentDefaultArgs> = $Result.GetResult<Prisma.$ReplyCommentPayload, S>

  type ReplyCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReplyCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReplyCommentCountAggregateInputType | true
    }

  export interface ReplyCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReplyComment'], meta: { name: 'ReplyComment' } }
    /**
     * Find zero or one ReplyComment that matches the filter.
     * @param {ReplyCommentFindUniqueArgs} args - Arguments to find a ReplyComment
     * @example
     * // Get one ReplyComment
     * const replyComment = await prisma.replyComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReplyCommentFindUniqueArgs>(args: SelectSubset<T, ReplyCommentFindUniqueArgs<ExtArgs>>): Prisma__ReplyCommentClient<$Result.GetResult<Prisma.$ReplyCommentPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ReplyComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReplyCommentFindUniqueOrThrowArgs} args - Arguments to find a ReplyComment
     * @example
     * // Get one ReplyComment
     * const replyComment = await prisma.replyComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReplyCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, ReplyCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReplyCommentClient<$Result.GetResult<Prisma.$ReplyCommentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ReplyComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyCommentFindFirstArgs} args - Arguments to find a ReplyComment
     * @example
     * // Get one ReplyComment
     * const replyComment = await prisma.replyComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReplyCommentFindFirstArgs>(args?: SelectSubset<T, ReplyCommentFindFirstArgs<ExtArgs>>): Prisma__ReplyCommentClient<$Result.GetResult<Prisma.$ReplyCommentPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ReplyComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyCommentFindFirstOrThrowArgs} args - Arguments to find a ReplyComment
     * @example
     * // Get one ReplyComment
     * const replyComment = await prisma.replyComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReplyCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, ReplyCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReplyCommentClient<$Result.GetResult<Prisma.$ReplyCommentPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ReplyComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReplyComments
     * const replyComments = await prisma.replyComment.findMany()
     * 
     * // Get first 10 ReplyComments
     * const replyComments = await prisma.replyComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const replyCommentWithIdOnly = await prisma.replyComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReplyCommentFindManyArgs>(args?: SelectSubset<T, ReplyCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReplyCommentPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ReplyComment.
     * @param {ReplyCommentCreateArgs} args - Arguments to create a ReplyComment.
     * @example
     * // Create one ReplyComment
     * const ReplyComment = await prisma.replyComment.create({
     *   data: {
     *     // ... data to create a ReplyComment
     *   }
     * })
     * 
     */
    create<T extends ReplyCommentCreateArgs>(args: SelectSubset<T, ReplyCommentCreateArgs<ExtArgs>>): Prisma__ReplyCommentClient<$Result.GetResult<Prisma.$ReplyCommentPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ReplyComments.
     * @param {ReplyCommentCreateManyArgs} args - Arguments to create many ReplyComments.
     * @example
     * // Create many ReplyComments
     * const replyComment = await prisma.replyComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReplyCommentCreateManyArgs>(args?: SelectSubset<T, ReplyCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReplyComments and returns the data saved in the database.
     * @param {ReplyCommentCreateManyAndReturnArgs} args - Arguments to create many ReplyComments.
     * @example
     * // Create many ReplyComments
     * const replyComment = await prisma.replyComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReplyComments and only return the `id`
     * const replyCommentWithIdOnly = await prisma.replyComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReplyCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, ReplyCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReplyCommentPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ReplyComment.
     * @param {ReplyCommentDeleteArgs} args - Arguments to delete one ReplyComment.
     * @example
     * // Delete one ReplyComment
     * const ReplyComment = await prisma.replyComment.delete({
     *   where: {
     *     // ... filter to delete one ReplyComment
     *   }
     * })
     * 
     */
    delete<T extends ReplyCommentDeleteArgs>(args: SelectSubset<T, ReplyCommentDeleteArgs<ExtArgs>>): Prisma__ReplyCommentClient<$Result.GetResult<Prisma.$ReplyCommentPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ReplyComment.
     * @param {ReplyCommentUpdateArgs} args - Arguments to update one ReplyComment.
     * @example
     * // Update one ReplyComment
     * const replyComment = await prisma.replyComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReplyCommentUpdateArgs>(args: SelectSubset<T, ReplyCommentUpdateArgs<ExtArgs>>): Prisma__ReplyCommentClient<$Result.GetResult<Prisma.$ReplyCommentPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ReplyComments.
     * @param {ReplyCommentDeleteManyArgs} args - Arguments to filter ReplyComments to delete.
     * @example
     * // Delete a few ReplyComments
     * const { count } = await prisma.replyComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReplyCommentDeleteManyArgs>(args?: SelectSubset<T, ReplyCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReplyComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReplyComments
     * const replyComment = await prisma.replyComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReplyCommentUpdateManyArgs>(args: SelectSubset<T, ReplyCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReplyComments and returns the data updated in the database.
     * @param {ReplyCommentUpdateManyAndReturnArgs} args - Arguments to update many ReplyComments.
     * @example
     * // Update many ReplyComments
     * const replyComment = await prisma.replyComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReplyComments and only return the `id`
     * const replyCommentWithIdOnly = await prisma.replyComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReplyCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, ReplyCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReplyCommentPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ReplyComment.
     * @param {ReplyCommentUpsertArgs} args - Arguments to update or create a ReplyComment.
     * @example
     * // Update or create a ReplyComment
     * const replyComment = await prisma.replyComment.upsert({
     *   create: {
     *     // ... data to create a ReplyComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReplyComment we want to update
     *   }
     * })
     */
    upsert<T extends ReplyCommentUpsertArgs>(args: SelectSubset<T, ReplyCommentUpsertArgs<ExtArgs>>): Prisma__ReplyCommentClient<$Result.GetResult<Prisma.$ReplyCommentPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ReplyComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyCommentCountArgs} args - Arguments to filter ReplyComments to count.
     * @example
     * // Count the number of ReplyComments
     * const count = await prisma.replyComment.count({
     *   where: {
     *     // ... the filter for the ReplyComments we want to count
     *   }
     * })
    **/
    count<T extends ReplyCommentCountArgs>(
      args?: Subset<T, ReplyCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReplyCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReplyComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReplyCommentAggregateArgs>(args: Subset<T, ReplyCommentAggregateArgs>): Prisma.PrismaPromise<GetReplyCommentAggregateType<T>>

    /**
     * Group by ReplyComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReplyCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReplyCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReplyCommentGroupByArgs['orderBy'] }
        : { orderBy?: ReplyCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReplyCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReplyCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReplyComment model
   */
  readonly fields: ReplyCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReplyComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReplyCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    comment<T extends CommentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommentDefaultArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReplyComment model
   */ 
  interface ReplyCommentFieldRefs {
    readonly id: FieldRef<"ReplyComment", 'Int'>
    readonly content: FieldRef<"ReplyComment", 'String'>
    readonly likes: FieldRef<"ReplyComment", 'Int'>
    readonly userId: FieldRef<"ReplyComment", 'Int'>
    readonly commentId: FieldRef<"ReplyComment", 'Int'>
    readonly createdAt: FieldRef<"ReplyComment", 'DateTime'>
    readonly updatedAt: FieldRef<"ReplyComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReplyComment findUnique
   */
  export type ReplyCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReplyComment
     */
    select?: ReplyCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReplyComment
     */
    omit?: ReplyCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReplyComment to fetch.
     */
    where: ReplyCommentWhereUniqueInput
  }

  /**
   * ReplyComment findUniqueOrThrow
   */
  export type ReplyCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReplyComment
     */
    select?: ReplyCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReplyComment
     */
    omit?: ReplyCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReplyComment to fetch.
     */
    where: ReplyCommentWhereUniqueInput
  }

  /**
   * ReplyComment findFirst
   */
  export type ReplyCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReplyComment
     */
    select?: ReplyCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReplyComment
     */
    omit?: ReplyCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReplyComment to fetch.
     */
    where?: ReplyCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReplyComments to fetch.
     */
    orderBy?: ReplyCommentOrderByWithRelationInput | ReplyCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReplyComments.
     */
    cursor?: ReplyCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReplyComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReplyComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReplyComments.
     */
    distinct?: ReplyCommentScalarFieldEnum | ReplyCommentScalarFieldEnum[]
  }

  /**
   * ReplyComment findFirstOrThrow
   */
  export type ReplyCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReplyComment
     */
    select?: ReplyCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReplyComment
     */
    omit?: ReplyCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReplyComment to fetch.
     */
    where?: ReplyCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReplyComments to fetch.
     */
    orderBy?: ReplyCommentOrderByWithRelationInput | ReplyCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReplyComments.
     */
    cursor?: ReplyCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReplyComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReplyComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReplyComments.
     */
    distinct?: ReplyCommentScalarFieldEnum | ReplyCommentScalarFieldEnum[]
  }

  /**
   * ReplyComment findMany
   */
  export type ReplyCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReplyComment
     */
    select?: ReplyCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReplyComment
     */
    omit?: ReplyCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReplyComments to fetch.
     */
    where?: ReplyCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReplyComments to fetch.
     */
    orderBy?: ReplyCommentOrderByWithRelationInput | ReplyCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReplyComments.
     */
    cursor?: ReplyCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReplyComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReplyComments.
     */
    skip?: number
    distinct?: ReplyCommentScalarFieldEnum | ReplyCommentScalarFieldEnum[]
  }

  /**
   * ReplyComment create
   */
  export type ReplyCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReplyComment
     */
    select?: ReplyCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReplyComment
     */
    omit?: ReplyCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a ReplyComment.
     */
    data: XOR<ReplyCommentCreateInput, ReplyCommentUncheckedCreateInput>
  }

  /**
   * ReplyComment createMany
   */
  export type ReplyCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReplyComments.
     */
    data: ReplyCommentCreateManyInput | ReplyCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReplyComment createManyAndReturn
   */
  export type ReplyCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReplyComment
     */
    select?: ReplyCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReplyComment
     */
    omit?: ReplyCommentOmit<ExtArgs> | null
    /**
     * The data used to create many ReplyComments.
     */
    data: ReplyCommentCreateManyInput | ReplyCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReplyComment update
   */
  export type ReplyCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReplyComment
     */
    select?: ReplyCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReplyComment
     */
    omit?: ReplyCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a ReplyComment.
     */
    data: XOR<ReplyCommentUpdateInput, ReplyCommentUncheckedUpdateInput>
    /**
     * Choose, which ReplyComment to update.
     */
    where: ReplyCommentWhereUniqueInput
  }

  /**
   * ReplyComment updateMany
   */
  export type ReplyCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReplyComments.
     */
    data: XOR<ReplyCommentUpdateManyMutationInput, ReplyCommentUncheckedUpdateManyInput>
    /**
     * Filter which ReplyComments to update
     */
    where?: ReplyCommentWhereInput
    /**
     * Limit how many ReplyComments to update.
     */
    limit?: number
  }

  /**
   * ReplyComment updateManyAndReturn
   */
  export type ReplyCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReplyComment
     */
    select?: ReplyCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReplyComment
     */
    omit?: ReplyCommentOmit<ExtArgs> | null
    /**
     * The data used to update ReplyComments.
     */
    data: XOR<ReplyCommentUpdateManyMutationInput, ReplyCommentUncheckedUpdateManyInput>
    /**
     * Filter which ReplyComments to update
     */
    where?: ReplyCommentWhereInput
    /**
     * Limit how many ReplyComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReplyComment upsert
   */
  export type ReplyCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReplyComment
     */
    select?: ReplyCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReplyComment
     */
    omit?: ReplyCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the ReplyComment to update in case it exists.
     */
    where: ReplyCommentWhereUniqueInput
    /**
     * In case the ReplyComment found by the `where` argument doesn't exist, create a new ReplyComment with this data.
     */
    create: XOR<ReplyCommentCreateInput, ReplyCommentUncheckedCreateInput>
    /**
     * In case the ReplyComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReplyCommentUpdateInput, ReplyCommentUncheckedUpdateInput>
  }

  /**
   * ReplyComment delete
   */
  export type ReplyCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReplyComment
     */
    select?: ReplyCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReplyComment
     */
    omit?: ReplyCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyCommentInclude<ExtArgs> | null
    /**
     * Filter which ReplyComment to delete.
     */
    where: ReplyCommentWhereUniqueInput
  }

  /**
   * ReplyComment deleteMany
   */
  export type ReplyCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReplyComments to delete
     */
    where?: ReplyCommentWhereInput
    /**
     * Limit how many ReplyComments to delete.
     */
    limit?: number
  }

  /**
   * ReplyComment without action
   */
  export type ReplyCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReplyComment
     */
    select?: ReplyCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReplyComment
     */
    omit?: ReplyCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReplyCommentInclude<ExtArgs> | null
  }


  /**
   * Model Reading
   */

  export type AggregateReading = {
    _count: ReadingCountAggregateOutputType | null
    _avg: ReadingAvgAggregateOutputType | null
    _sum: ReadingSumAggregateOutputType | null
    _min: ReadingMinAggregateOutputType | null
    _max: ReadingMaxAggregateOutputType | null
  }

  export type ReadingAvgAggregateOutputType = {
    userId: number | null
    novelId: number | null
    chapterId: number | null
  }

  export type ReadingSumAggregateOutputType = {
    userId: number | null
    novelId: number | null
    chapterId: number | null
  }

  export type ReadingMinAggregateOutputType = {
    userId: number | null
    novelId: number | null
    chapterId: number | null
    lastRead: Date | null
  }

  export type ReadingMaxAggregateOutputType = {
    userId: number | null
    novelId: number | null
    chapterId: number | null
    lastRead: Date | null
  }

  export type ReadingCountAggregateOutputType = {
    userId: number
    novelId: number
    chapterId: number
    lastRead: number
    _all: number
  }


  export type ReadingAvgAggregateInputType = {
    userId?: true
    novelId?: true
    chapterId?: true
  }

  export type ReadingSumAggregateInputType = {
    userId?: true
    novelId?: true
    chapterId?: true
  }

  export type ReadingMinAggregateInputType = {
    userId?: true
    novelId?: true
    chapterId?: true
    lastRead?: true
  }

  export type ReadingMaxAggregateInputType = {
    userId?: true
    novelId?: true
    chapterId?: true
    lastRead?: true
  }

  export type ReadingCountAggregateInputType = {
    userId?: true
    novelId?: true
    chapterId?: true
    lastRead?: true
    _all?: true
  }

  export type ReadingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reading to aggregate.
     */
    where?: ReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Readings to fetch.
     */
    orderBy?: ReadingOrderByWithRelationInput | ReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Readings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Readings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Readings
    **/
    _count?: true | ReadingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReadingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReadingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReadingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReadingMaxAggregateInputType
  }

  export type GetReadingAggregateType<T extends ReadingAggregateArgs> = {
        [P in keyof T & keyof AggregateReading]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReading[P]>
      : GetScalarType<T[P], AggregateReading[P]>
  }




  export type ReadingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReadingWhereInput
    orderBy?: ReadingOrderByWithAggregationInput | ReadingOrderByWithAggregationInput[]
    by: ReadingScalarFieldEnum[] | ReadingScalarFieldEnum
    having?: ReadingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReadingCountAggregateInputType | true
    _avg?: ReadingAvgAggregateInputType
    _sum?: ReadingSumAggregateInputType
    _min?: ReadingMinAggregateInputType
    _max?: ReadingMaxAggregateInputType
  }

  export type ReadingGroupByOutputType = {
    userId: number
    novelId: number
    chapterId: number
    lastRead: Date
    _count: ReadingCountAggregateOutputType | null
    _avg: ReadingAvgAggregateOutputType | null
    _sum: ReadingSumAggregateOutputType | null
    _min: ReadingMinAggregateOutputType | null
    _max: ReadingMaxAggregateOutputType | null
  }

  type GetReadingGroupByPayload<T extends ReadingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReadingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReadingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReadingGroupByOutputType[P]>
            : GetScalarType<T[P], ReadingGroupByOutputType[P]>
        }
      >
    >


  export type ReadingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    novelId?: boolean
    chapterId?: boolean
    lastRead?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    novel?: boolean | NovelDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reading"]>

  export type ReadingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    novelId?: boolean
    chapterId?: boolean
    lastRead?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    novel?: boolean | NovelDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reading"]>

  export type ReadingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    novelId?: boolean
    chapterId?: boolean
    lastRead?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    novel?: boolean | NovelDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reading"]>

  export type ReadingSelectScalar = {
    userId?: boolean
    novelId?: boolean
    chapterId?: boolean
    lastRead?: boolean
  }

  export type ReadingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "novelId" | "chapterId" | "lastRead", ExtArgs["result"]["reading"]>
  export type ReadingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    novel?: boolean | NovelDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }
  export type ReadingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    novel?: boolean | NovelDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }
  export type ReadingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    novel?: boolean | NovelDefaultArgs<ExtArgs>
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }

  export type $ReadingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reading"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      novel: Prisma.$NovelPayload<ExtArgs>
      chapter: Prisma.$ChapterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      novelId: number
      chapterId: number
      lastRead: Date
    }, ExtArgs["result"]["reading"]>
    composites: {}
  }

  type ReadingGetPayload<S extends boolean | null | undefined | ReadingDefaultArgs> = $Result.GetResult<Prisma.$ReadingPayload, S>

  type ReadingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReadingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReadingCountAggregateInputType | true
    }

  export interface ReadingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reading'], meta: { name: 'Reading' } }
    /**
     * Find zero or one Reading that matches the filter.
     * @param {ReadingFindUniqueArgs} args - Arguments to find a Reading
     * @example
     * // Get one Reading
     * const reading = await prisma.reading.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReadingFindUniqueArgs>(args: SelectSubset<T, ReadingFindUniqueArgs<ExtArgs>>): Prisma__ReadingClient<$Result.GetResult<Prisma.$ReadingPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Reading that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReadingFindUniqueOrThrowArgs} args - Arguments to find a Reading
     * @example
     * // Get one Reading
     * const reading = await prisma.reading.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReadingFindUniqueOrThrowArgs>(args: SelectSubset<T, ReadingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReadingClient<$Result.GetResult<Prisma.$ReadingPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Reading that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingFindFirstArgs} args - Arguments to find a Reading
     * @example
     * // Get one Reading
     * const reading = await prisma.reading.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReadingFindFirstArgs>(args?: SelectSubset<T, ReadingFindFirstArgs<ExtArgs>>): Prisma__ReadingClient<$Result.GetResult<Prisma.$ReadingPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Reading that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingFindFirstOrThrowArgs} args - Arguments to find a Reading
     * @example
     * // Get one Reading
     * const reading = await prisma.reading.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReadingFindFirstOrThrowArgs>(args?: SelectSubset<T, ReadingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReadingClient<$Result.GetResult<Prisma.$ReadingPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Readings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Readings
     * const readings = await prisma.reading.findMany()
     * 
     * // Get first 10 Readings
     * const readings = await prisma.reading.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const readingWithUserIdOnly = await prisma.reading.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends ReadingFindManyArgs>(args?: SelectSubset<T, ReadingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReadingPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Reading.
     * @param {ReadingCreateArgs} args - Arguments to create a Reading.
     * @example
     * // Create one Reading
     * const Reading = await prisma.reading.create({
     *   data: {
     *     // ... data to create a Reading
     *   }
     * })
     * 
     */
    create<T extends ReadingCreateArgs>(args: SelectSubset<T, ReadingCreateArgs<ExtArgs>>): Prisma__ReadingClient<$Result.GetResult<Prisma.$ReadingPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Readings.
     * @param {ReadingCreateManyArgs} args - Arguments to create many Readings.
     * @example
     * // Create many Readings
     * const reading = await prisma.reading.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReadingCreateManyArgs>(args?: SelectSubset<T, ReadingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Readings and returns the data saved in the database.
     * @param {ReadingCreateManyAndReturnArgs} args - Arguments to create many Readings.
     * @example
     * // Create many Readings
     * const reading = await prisma.reading.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Readings and only return the `userId`
     * const readingWithUserIdOnly = await prisma.reading.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReadingCreateManyAndReturnArgs>(args?: SelectSubset<T, ReadingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReadingPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Reading.
     * @param {ReadingDeleteArgs} args - Arguments to delete one Reading.
     * @example
     * // Delete one Reading
     * const Reading = await prisma.reading.delete({
     *   where: {
     *     // ... filter to delete one Reading
     *   }
     * })
     * 
     */
    delete<T extends ReadingDeleteArgs>(args: SelectSubset<T, ReadingDeleteArgs<ExtArgs>>): Prisma__ReadingClient<$Result.GetResult<Prisma.$ReadingPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Reading.
     * @param {ReadingUpdateArgs} args - Arguments to update one Reading.
     * @example
     * // Update one Reading
     * const reading = await prisma.reading.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReadingUpdateArgs>(args: SelectSubset<T, ReadingUpdateArgs<ExtArgs>>): Prisma__ReadingClient<$Result.GetResult<Prisma.$ReadingPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Readings.
     * @param {ReadingDeleteManyArgs} args - Arguments to filter Readings to delete.
     * @example
     * // Delete a few Readings
     * const { count } = await prisma.reading.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReadingDeleteManyArgs>(args?: SelectSubset<T, ReadingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Readings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Readings
     * const reading = await prisma.reading.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReadingUpdateManyArgs>(args: SelectSubset<T, ReadingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Readings and returns the data updated in the database.
     * @param {ReadingUpdateManyAndReturnArgs} args - Arguments to update many Readings.
     * @example
     * // Update many Readings
     * const reading = await prisma.reading.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Readings and only return the `userId`
     * const readingWithUserIdOnly = await prisma.reading.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReadingUpdateManyAndReturnArgs>(args: SelectSubset<T, ReadingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReadingPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Reading.
     * @param {ReadingUpsertArgs} args - Arguments to update or create a Reading.
     * @example
     * // Update or create a Reading
     * const reading = await prisma.reading.upsert({
     *   create: {
     *     // ... data to create a Reading
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reading we want to update
     *   }
     * })
     */
    upsert<T extends ReadingUpsertArgs>(args: SelectSubset<T, ReadingUpsertArgs<ExtArgs>>): Prisma__ReadingClient<$Result.GetResult<Prisma.$ReadingPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Readings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingCountArgs} args - Arguments to filter Readings to count.
     * @example
     * // Count the number of Readings
     * const count = await prisma.reading.count({
     *   where: {
     *     // ... the filter for the Readings we want to count
     *   }
     * })
    **/
    count<T extends ReadingCountArgs>(
      args?: Subset<T, ReadingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReadingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReadingAggregateArgs>(args: Subset<T, ReadingAggregateArgs>): Prisma.PrismaPromise<GetReadingAggregateType<T>>

    /**
     * Group by Reading.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReadingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReadingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReadingGroupByArgs['orderBy'] }
        : { orderBy?: ReadingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReadingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReadingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reading model
   */
  readonly fields: ReadingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reading.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReadingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    novel<T extends NovelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NovelDefaultArgs<ExtArgs>>): Prisma__NovelClient<$Result.GetResult<Prisma.$NovelPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    chapter<T extends ChapterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChapterDefaultArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reading model
   */ 
  interface ReadingFieldRefs {
    readonly userId: FieldRef<"Reading", 'Int'>
    readonly novelId: FieldRef<"Reading", 'Int'>
    readonly chapterId: FieldRef<"Reading", 'Int'>
    readonly lastRead: FieldRef<"Reading", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reading findUnique
   */
  export type ReadingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading
     */
    select?: ReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading
     */
    omit?: ReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingInclude<ExtArgs> | null
    /**
     * Filter, which Reading to fetch.
     */
    where: ReadingWhereUniqueInput
  }

  /**
   * Reading findUniqueOrThrow
   */
  export type ReadingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading
     */
    select?: ReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading
     */
    omit?: ReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingInclude<ExtArgs> | null
    /**
     * Filter, which Reading to fetch.
     */
    where: ReadingWhereUniqueInput
  }

  /**
   * Reading findFirst
   */
  export type ReadingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading
     */
    select?: ReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading
     */
    omit?: ReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingInclude<ExtArgs> | null
    /**
     * Filter, which Reading to fetch.
     */
    where?: ReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Readings to fetch.
     */
    orderBy?: ReadingOrderByWithRelationInput | ReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Readings.
     */
    cursor?: ReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Readings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Readings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Readings.
     */
    distinct?: ReadingScalarFieldEnum | ReadingScalarFieldEnum[]
  }

  /**
   * Reading findFirstOrThrow
   */
  export type ReadingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading
     */
    select?: ReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading
     */
    omit?: ReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingInclude<ExtArgs> | null
    /**
     * Filter, which Reading to fetch.
     */
    where?: ReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Readings to fetch.
     */
    orderBy?: ReadingOrderByWithRelationInput | ReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Readings.
     */
    cursor?: ReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Readings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Readings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Readings.
     */
    distinct?: ReadingScalarFieldEnum | ReadingScalarFieldEnum[]
  }

  /**
   * Reading findMany
   */
  export type ReadingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading
     */
    select?: ReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading
     */
    omit?: ReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingInclude<ExtArgs> | null
    /**
     * Filter, which Readings to fetch.
     */
    where?: ReadingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Readings to fetch.
     */
    orderBy?: ReadingOrderByWithRelationInput | ReadingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Readings.
     */
    cursor?: ReadingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Readings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Readings.
     */
    skip?: number
    distinct?: ReadingScalarFieldEnum | ReadingScalarFieldEnum[]
  }

  /**
   * Reading create
   */
  export type ReadingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading
     */
    select?: ReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading
     */
    omit?: ReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingInclude<ExtArgs> | null
    /**
     * The data needed to create a Reading.
     */
    data: XOR<ReadingCreateInput, ReadingUncheckedCreateInput>
  }

  /**
   * Reading createMany
   */
  export type ReadingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Readings.
     */
    data: ReadingCreateManyInput | ReadingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reading createManyAndReturn
   */
  export type ReadingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading
     */
    select?: ReadingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reading
     */
    omit?: ReadingOmit<ExtArgs> | null
    /**
     * The data used to create many Readings.
     */
    data: ReadingCreateManyInput | ReadingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reading update
   */
  export type ReadingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading
     */
    select?: ReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading
     */
    omit?: ReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingInclude<ExtArgs> | null
    /**
     * The data needed to update a Reading.
     */
    data: XOR<ReadingUpdateInput, ReadingUncheckedUpdateInput>
    /**
     * Choose, which Reading to update.
     */
    where: ReadingWhereUniqueInput
  }

  /**
   * Reading updateMany
   */
  export type ReadingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Readings.
     */
    data: XOR<ReadingUpdateManyMutationInput, ReadingUncheckedUpdateManyInput>
    /**
     * Filter which Readings to update
     */
    where?: ReadingWhereInput
    /**
     * Limit how many Readings to update.
     */
    limit?: number
  }

  /**
   * Reading updateManyAndReturn
   */
  export type ReadingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading
     */
    select?: ReadingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reading
     */
    omit?: ReadingOmit<ExtArgs> | null
    /**
     * The data used to update Readings.
     */
    data: XOR<ReadingUpdateManyMutationInput, ReadingUncheckedUpdateManyInput>
    /**
     * Filter which Readings to update
     */
    where?: ReadingWhereInput
    /**
     * Limit how many Readings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reading upsert
   */
  export type ReadingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading
     */
    select?: ReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading
     */
    omit?: ReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingInclude<ExtArgs> | null
    /**
     * The filter to search for the Reading to update in case it exists.
     */
    where: ReadingWhereUniqueInput
    /**
     * In case the Reading found by the `where` argument doesn't exist, create a new Reading with this data.
     */
    create: XOR<ReadingCreateInput, ReadingUncheckedCreateInput>
    /**
     * In case the Reading was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReadingUpdateInput, ReadingUncheckedUpdateInput>
  }

  /**
   * Reading delete
   */
  export type ReadingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading
     */
    select?: ReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading
     */
    omit?: ReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingInclude<ExtArgs> | null
    /**
     * Filter which Reading to delete.
     */
    where: ReadingWhereUniqueInput
  }

  /**
   * Reading deleteMany
   */
  export type ReadingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Readings to delete
     */
    where?: ReadingWhereInput
    /**
     * Limit how many Readings to delete.
     */
    limit?: number
  }

  /**
   * Reading without action
   */
  export type ReadingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reading
     */
    select?: ReadingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reading
     */
    omit?: ReadingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReadingInclude<ExtArgs> | null
  }


  /**
   * Model Favorite
   */

  export type AggregateFavorite = {
    _count: FavoriteCountAggregateOutputType | null
    _avg: FavoriteAvgAggregateOutputType | null
    _sum: FavoriteSumAggregateOutputType | null
    _min: FavoriteMinAggregateOutputType | null
    _max: FavoriteMaxAggregateOutputType | null
  }

  export type FavoriteAvgAggregateOutputType = {
    userId: number | null
    novelId: number | null
  }

  export type FavoriteSumAggregateOutputType = {
    userId: number | null
    novelId: number | null
  }

  export type FavoriteMinAggregateOutputType = {
    userId: number | null
    novelId: number | null
    createdAt: Date | null
  }

  export type FavoriteMaxAggregateOutputType = {
    userId: number | null
    novelId: number | null
    createdAt: Date | null
  }

  export type FavoriteCountAggregateOutputType = {
    userId: number
    novelId: number
    createdAt: number
    _all: number
  }


  export type FavoriteAvgAggregateInputType = {
    userId?: true
    novelId?: true
  }

  export type FavoriteSumAggregateInputType = {
    userId?: true
    novelId?: true
  }

  export type FavoriteMinAggregateInputType = {
    userId?: true
    novelId?: true
    createdAt?: true
  }

  export type FavoriteMaxAggregateInputType = {
    userId?: true
    novelId?: true
    createdAt?: true
  }

  export type FavoriteCountAggregateInputType = {
    userId?: true
    novelId?: true
    createdAt?: true
    _all?: true
  }

  export type FavoriteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorite to aggregate.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Favorites
    **/
    _count?: true | FavoriteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FavoriteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FavoriteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FavoriteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FavoriteMaxAggregateInputType
  }

  export type GetFavoriteAggregateType<T extends FavoriteAggregateArgs> = {
        [P in keyof T & keyof AggregateFavorite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavorite[P]>
      : GetScalarType<T[P], AggregateFavorite[P]>
  }




  export type FavoriteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteWhereInput
    orderBy?: FavoriteOrderByWithAggregationInput | FavoriteOrderByWithAggregationInput[]
    by: FavoriteScalarFieldEnum[] | FavoriteScalarFieldEnum
    having?: FavoriteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FavoriteCountAggregateInputType | true
    _avg?: FavoriteAvgAggregateInputType
    _sum?: FavoriteSumAggregateInputType
    _min?: FavoriteMinAggregateInputType
    _max?: FavoriteMaxAggregateInputType
  }

  export type FavoriteGroupByOutputType = {
    userId: number
    novelId: number
    createdAt: Date
    _count: FavoriteCountAggregateOutputType | null
    _avg: FavoriteAvgAggregateOutputType | null
    _sum: FavoriteSumAggregateOutputType | null
    _min: FavoriteMinAggregateOutputType | null
    _max: FavoriteMaxAggregateOutputType | null
  }

  type GetFavoriteGroupByPayload<T extends FavoriteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FavoriteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FavoriteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FavoriteGroupByOutputType[P]>
            : GetScalarType<T[P], FavoriteGroupByOutputType[P]>
        }
      >
    >


  export type FavoriteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    novelId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    novel?: boolean | NovelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    novelId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    novel?: boolean | NovelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    novelId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    novel?: boolean | NovelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favorite"]>

  export type FavoriteSelectScalar = {
    userId?: boolean
    novelId?: boolean
    createdAt?: boolean
  }

  export type FavoriteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "novelId" | "createdAt", ExtArgs["result"]["favorite"]>
  export type FavoriteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    novel?: boolean | NovelDefaultArgs<ExtArgs>
  }
  export type FavoriteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    novel?: boolean | NovelDefaultArgs<ExtArgs>
  }
  export type FavoriteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    novel?: boolean | NovelDefaultArgs<ExtArgs>
  }

  export type $FavoritePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Favorite"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      novel: Prisma.$NovelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: number
      novelId: number
      createdAt: Date
    }, ExtArgs["result"]["favorite"]>
    composites: {}
  }

  type FavoriteGetPayload<S extends boolean | null | undefined | FavoriteDefaultArgs> = $Result.GetResult<Prisma.$FavoritePayload, S>

  type FavoriteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FavoriteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FavoriteCountAggregateInputType | true
    }

  export interface FavoriteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Favorite'], meta: { name: 'Favorite' } }
    /**
     * Find zero or one Favorite that matches the filter.
     * @param {FavoriteFindUniqueArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FavoriteFindUniqueArgs>(args: SelectSubset<T, FavoriteFindUniqueArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Favorite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FavoriteFindUniqueOrThrowArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FavoriteFindUniqueOrThrowArgs>(args: SelectSubset<T, FavoriteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Favorite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindFirstArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FavoriteFindFirstArgs>(args?: SelectSubset<T, FavoriteFindFirstArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Favorite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindFirstOrThrowArgs} args - Arguments to find a Favorite
     * @example
     * // Get one Favorite
     * const favorite = await prisma.favorite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FavoriteFindFirstOrThrowArgs>(args?: SelectSubset<T, FavoriteFindFirstOrThrowArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Favorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Favorites
     * const favorites = await prisma.favorite.findMany()
     * 
     * // Get first 10 Favorites
     * const favorites = await prisma.favorite.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const favoriteWithUserIdOnly = await prisma.favorite.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends FavoriteFindManyArgs>(args?: SelectSubset<T, FavoriteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Favorite.
     * @param {FavoriteCreateArgs} args - Arguments to create a Favorite.
     * @example
     * // Create one Favorite
     * const Favorite = await prisma.favorite.create({
     *   data: {
     *     // ... data to create a Favorite
     *   }
     * })
     * 
     */
    create<T extends FavoriteCreateArgs>(args: SelectSubset<T, FavoriteCreateArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Favorites.
     * @param {FavoriteCreateManyArgs} args - Arguments to create many Favorites.
     * @example
     * // Create many Favorites
     * const favorite = await prisma.favorite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FavoriteCreateManyArgs>(args?: SelectSubset<T, FavoriteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Favorites and returns the data saved in the database.
     * @param {FavoriteCreateManyAndReturnArgs} args - Arguments to create many Favorites.
     * @example
     * // Create many Favorites
     * const favorite = await prisma.favorite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Favorites and only return the `userId`
     * const favoriteWithUserIdOnly = await prisma.favorite.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FavoriteCreateManyAndReturnArgs>(args?: SelectSubset<T, FavoriteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Favorite.
     * @param {FavoriteDeleteArgs} args - Arguments to delete one Favorite.
     * @example
     * // Delete one Favorite
     * const Favorite = await prisma.favorite.delete({
     *   where: {
     *     // ... filter to delete one Favorite
     *   }
     * })
     * 
     */
    delete<T extends FavoriteDeleteArgs>(args: SelectSubset<T, FavoriteDeleteArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Favorite.
     * @param {FavoriteUpdateArgs} args - Arguments to update one Favorite.
     * @example
     * // Update one Favorite
     * const favorite = await prisma.favorite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FavoriteUpdateArgs>(args: SelectSubset<T, FavoriteUpdateArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Favorites.
     * @param {FavoriteDeleteManyArgs} args - Arguments to filter Favorites to delete.
     * @example
     * // Delete a few Favorites
     * const { count } = await prisma.favorite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FavoriteDeleteManyArgs>(args?: SelectSubset<T, FavoriteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Favorites
     * const favorite = await prisma.favorite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FavoriteUpdateManyArgs>(args: SelectSubset<T, FavoriteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Favorites and returns the data updated in the database.
     * @param {FavoriteUpdateManyAndReturnArgs} args - Arguments to update many Favorites.
     * @example
     * // Update many Favorites
     * const favorite = await prisma.favorite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Favorites and only return the `userId`
     * const favoriteWithUserIdOnly = await prisma.favorite.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FavoriteUpdateManyAndReturnArgs>(args: SelectSubset<T, FavoriteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Favorite.
     * @param {FavoriteUpsertArgs} args - Arguments to update or create a Favorite.
     * @example
     * // Update or create a Favorite
     * const favorite = await prisma.favorite.upsert({
     *   create: {
     *     // ... data to create a Favorite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Favorite we want to update
     *   }
     * })
     */
    upsert<T extends FavoriteUpsertArgs>(args: SelectSubset<T, FavoriteUpsertArgs<ExtArgs>>): Prisma__FavoriteClient<$Result.GetResult<Prisma.$FavoritePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteCountArgs} args - Arguments to filter Favorites to count.
     * @example
     * // Count the number of Favorites
     * const count = await prisma.favorite.count({
     *   where: {
     *     // ... the filter for the Favorites we want to count
     *   }
     * })
    **/
    count<T extends FavoriteCountArgs>(
      args?: Subset<T, FavoriteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FavoriteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Favorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FavoriteAggregateArgs>(args: Subset<T, FavoriteAggregateArgs>): Prisma.PrismaPromise<GetFavoriteAggregateType<T>>

    /**
     * Group by Favorite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FavoriteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FavoriteGroupByArgs['orderBy'] }
        : { orderBy?: FavoriteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FavoriteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFavoriteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Favorite model
   */
  readonly fields: FavoriteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Favorite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FavoriteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    novel<T extends NovelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NovelDefaultArgs<ExtArgs>>): Prisma__NovelClient<$Result.GetResult<Prisma.$NovelPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Favorite model
   */ 
  interface FavoriteFieldRefs {
    readonly userId: FieldRef<"Favorite", 'Int'>
    readonly novelId: FieldRef<"Favorite", 'Int'>
    readonly createdAt: FieldRef<"Favorite", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Favorite findUnique
   */
  export type FavoriteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite findUniqueOrThrow
   */
  export type FavoriteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite findFirst
   */
  export type FavoriteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorites.
     */
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite findFirstOrThrow
   */
  export type FavoriteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorite to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Favorites.
     */
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite findMany
   */
  export type FavoriteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter, which Favorites to fetch.
     */
    where?: FavoriteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Favorites to fetch.
     */
    orderBy?: FavoriteOrderByWithRelationInput | FavoriteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Favorites.
     */
    cursor?: FavoriteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Favorites.
     */
    skip?: number
    distinct?: FavoriteScalarFieldEnum | FavoriteScalarFieldEnum[]
  }

  /**
   * Favorite create
   */
  export type FavoriteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The data needed to create a Favorite.
     */
    data: XOR<FavoriteCreateInput, FavoriteUncheckedCreateInput>
  }

  /**
   * Favorite createMany
   */
  export type FavoriteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Favorites.
     */
    data: FavoriteCreateManyInput | FavoriteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Favorite createManyAndReturn
   */
  export type FavoriteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * The data used to create many Favorites.
     */
    data: FavoriteCreateManyInput | FavoriteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorite update
   */
  export type FavoriteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The data needed to update a Favorite.
     */
    data: XOR<FavoriteUpdateInput, FavoriteUncheckedUpdateInput>
    /**
     * Choose, which Favorite to update.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite updateMany
   */
  export type FavoriteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Favorites.
     */
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyInput>
    /**
     * Filter which Favorites to update
     */
    where?: FavoriteWhereInput
    /**
     * Limit how many Favorites to update.
     */
    limit?: number
  }

  /**
   * Favorite updateManyAndReturn
   */
  export type FavoriteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * The data used to update Favorites.
     */
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyInput>
    /**
     * Filter which Favorites to update
     */
    where?: FavoriteWhereInput
    /**
     * Limit how many Favorites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Favorite upsert
   */
  export type FavoriteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * The filter to search for the Favorite to update in case it exists.
     */
    where: FavoriteWhereUniqueInput
    /**
     * In case the Favorite found by the `where` argument doesn't exist, create a new Favorite with this data.
     */
    create: XOR<FavoriteCreateInput, FavoriteUncheckedCreateInput>
    /**
     * In case the Favorite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FavoriteUpdateInput, FavoriteUncheckedUpdateInput>
  }

  /**
   * Favorite delete
   */
  export type FavoriteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
    /**
     * Filter which Favorite to delete.
     */
    where: FavoriteWhereUniqueInput
  }

  /**
   * Favorite deleteMany
   */
  export type FavoriteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Favorites to delete
     */
    where?: FavoriteWhereInput
    /**
     * Limit how many Favorites to delete.
     */
    limit?: number
  }

  /**
   * Favorite without action
   */
  export type FavoriteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Favorite
     */
    select?: FavoriteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Favorite
     */
    omit?: FavoriteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteInclude<ExtArgs> | null
  }


  /**
   * Model NovelStatistic
   */

  export type AggregateNovelStatistic = {
    _count: NovelStatisticCountAggregateOutputType | null
    _avg: NovelStatisticAvgAggregateOutputType | null
    _sum: NovelStatisticSumAggregateOutputType | null
    _min: NovelStatisticMinAggregateOutputType | null
    _max: NovelStatisticMaxAggregateOutputType | null
  }

  export type NovelStatisticAvgAggregateOutputType = {
    id: number | null
    novelId: number | null
    dailyViews: number | null
    totalViews: number | null
    reviews: number | null
    comments: number | null
  }

  export type NovelStatisticSumAggregateOutputType = {
    id: number | null
    novelId: number | null
    dailyViews: number | null
    totalViews: number | null
    reviews: number | null
    comments: number | null
  }

  export type NovelStatisticMinAggregateOutputType = {
    id: number | null
    novelId: number | null
    dailyViews: number | null
    totalViews: number | null
    reviews: number | null
    comments: number | null
    date: Date | null
  }

  export type NovelStatisticMaxAggregateOutputType = {
    id: number | null
    novelId: number | null
    dailyViews: number | null
    totalViews: number | null
    reviews: number | null
    comments: number | null
    date: Date | null
  }

  export type NovelStatisticCountAggregateOutputType = {
    id: number
    novelId: number
    dailyViews: number
    totalViews: number
    reviews: number
    comments: number
    date: number
    _all: number
  }


  export type NovelStatisticAvgAggregateInputType = {
    id?: true
    novelId?: true
    dailyViews?: true
    totalViews?: true
    reviews?: true
    comments?: true
  }

  export type NovelStatisticSumAggregateInputType = {
    id?: true
    novelId?: true
    dailyViews?: true
    totalViews?: true
    reviews?: true
    comments?: true
  }

  export type NovelStatisticMinAggregateInputType = {
    id?: true
    novelId?: true
    dailyViews?: true
    totalViews?: true
    reviews?: true
    comments?: true
    date?: true
  }

  export type NovelStatisticMaxAggregateInputType = {
    id?: true
    novelId?: true
    dailyViews?: true
    totalViews?: true
    reviews?: true
    comments?: true
    date?: true
  }

  export type NovelStatisticCountAggregateInputType = {
    id?: true
    novelId?: true
    dailyViews?: true
    totalViews?: true
    reviews?: true
    comments?: true
    date?: true
    _all?: true
  }

  export type NovelStatisticAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NovelStatistic to aggregate.
     */
    where?: NovelStatisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NovelStatistics to fetch.
     */
    orderBy?: NovelStatisticOrderByWithRelationInput | NovelStatisticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NovelStatisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NovelStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NovelStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NovelStatistics
    **/
    _count?: true | NovelStatisticCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NovelStatisticAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NovelStatisticSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NovelStatisticMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NovelStatisticMaxAggregateInputType
  }

  export type GetNovelStatisticAggregateType<T extends NovelStatisticAggregateArgs> = {
        [P in keyof T & keyof AggregateNovelStatistic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNovelStatistic[P]>
      : GetScalarType<T[P], AggregateNovelStatistic[P]>
  }




  export type NovelStatisticGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NovelStatisticWhereInput
    orderBy?: NovelStatisticOrderByWithAggregationInput | NovelStatisticOrderByWithAggregationInput[]
    by: NovelStatisticScalarFieldEnum[] | NovelStatisticScalarFieldEnum
    having?: NovelStatisticScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NovelStatisticCountAggregateInputType | true
    _avg?: NovelStatisticAvgAggregateInputType
    _sum?: NovelStatisticSumAggregateInputType
    _min?: NovelStatisticMinAggregateInputType
    _max?: NovelStatisticMaxAggregateInputType
  }

  export type NovelStatisticGroupByOutputType = {
    id: number
    novelId: number
    dailyViews: number
    totalViews: number
    reviews: number
    comments: number
    date: Date
    _count: NovelStatisticCountAggregateOutputType | null
    _avg: NovelStatisticAvgAggregateOutputType | null
    _sum: NovelStatisticSumAggregateOutputType | null
    _min: NovelStatisticMinAggregateOutputType | null
    _max: NovelStatisticMaxAggregateOutputType | null
  }

  type GetNovelStatisticGroupByPayload<T extends NovelStatisticGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NovelStatisticGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NovelStatisticGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NovelStatisticGroupByOutputType[P]>
            : GetScalarType<T[P], NovelStatisticGroupByOutputType[P]>
        }
      >
    >


  export type NovelStatisticSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    novelId?: boolean
    dailyViews?: boolean
    totalViews?: boolean
    reviews?: boolean
    comments?: boolean
    date?: boolean
    novel?: boolean | NovelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["novelStatistic"]>

  export type NovelStatisticSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    novelId?: boolean
    dailyViews?: boolean
    totalViews?: boolean
    reviews?: boolean
    comments?: boolean
    date?: boolean
    novel?: boolean | NovelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["novelStatistic"]>

  export type NovelStatisticSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    novelId?: boolean
    dailyViews?: boolean
    totalViews?: boolean
    reviews?: boolean
    comments?: boolean
    date?: boolean
    novel?: boolean | NovelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["novelStatistic"]>

  export type NovelStatisticSelectScalar = {
    id?: boolean
    novelId?: boolean
    dailyViews?: boolean
    totalViews?: boolean
    reviews?: boolean
    comments?: boolean
    date?: boolean
  }

  export type NovelStatisticOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "novelId" | "dailyViews" | "totalViews" | "reviews" | "comments" | "date", ExtArgs["result"]["novelStatistic"]>
  export type NovelStatisticInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    novel?: boolean | NovelDefaultArgs<ExtArgs>
  }
  export type NovelStatisticIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    novel?: boolean | NovelDefaultArgs<ExtArgs>
  }
  export type NovelStatisticIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    novel?: boolean | NovelDefaultArgs<ExtArgs>
  }

  export type $NovelStatisticPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NovelStatistic"
    objects: {
      novel: Prisma.$NovelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      novelId: number
      dailyViews: number
      totalViews: number
      reviews: number
      comments: number
      date: Date
    }, ExtArgs["result"]["novelStatistic"]>
    composites: {}
  }

  type NovelStatisticGetPayload<S extends boolean | null | undefined | NovelStatisticDefaultArgs> = $Result.GetResult<Prisma.$NovelStatisticPayload, S>

  type NovelStatisticCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NovelStatisticFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NovelStatisticCountAggregateInputType | true
    }

  export interface NovelStatisticDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NovelStatistic'], meta: { name: 'NovelStatistic' } }
    /**
     * Find zero or one NovelStatistic that matches the filter.
     * @param {NovelStatisticFindUniqueArgs} args - Arguments to find a NovelStatistic
     * @example
     * // Get one NovelStatistic
     * const novelStatistic = await prisma.novelStatistic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NovelStatisticFindUniqueArgs>(args: SelectSubset<T, NovelStatisticFindUniqueArgs<ExtArgs>>): Prisma__NovelStatisticClient<$Result.GetResult<Prisma.$NovelStatisticPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one NovelStatistic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NovelStatisticFindUniqueOrThrowArgs} args - Arguments to find a NovelStatistic
     * @example
     * // Get one NovelStatistic
     * const novelStatistic = await prisma.novelStatistic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NovelStatisticFindUniqueOrThrowArgs>(args: SelectSubset<T, NovelStatisticFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NovelStatisticClient<$Result.GetResult<Prisma.$NovelStatisticPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first NovelStatistic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NovelStatisticFindFirstArgs} args - Arguments to find a NovelStatistic
     * @example
     * // Get one NovelStatistic
     * const novelStatistic = await prisma.novelStatistic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NovelStatisticFindFirstArgs>(args?: SelectSubset<T, NovelStatisticFindFirstArgs<ExtArgs>>): Prisma__NovelStatisticClient<$Result.GetResult<Prisma.$NovelStatisticPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first NovelStatistic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NovelStatisticFindFirstOrThrowArgs} args - Arguments to find a NovelStatistic
     * @example
     * // Get one NovelStatistic
     * const novelStatistic = await prisma.novelStatistic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NovelStatisticFindFirstOrThrowArgs>(args?: SelectSubset<T, NovelStatisticFindFirstOrThrowArgs<ExtArgs>>): Prisma__NovelStatisticClient<$Result.GetResult<Prisma.$NovelStatisticPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more NovelStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NovelStatisticFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NovelStatistics
     * const novelStatistics = await prisma.novelStatistic.findMany()
     * 
     * // Get first 10 NovelStatistics
     * const novelStatistics = await prisma.novelStatistic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const novelStatisticWithIdOnly = await prisma.novelStatistic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NovelStatisticFindManyArgs>(args?: SelectSubset<T, NovelStatisticFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NovelStatisticPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a NovelStatistic.
     * @param {NovelStatisticCreateArgs} args - Arguments to create a NovelStatistic.
     * @example
     * // Create one NovelStatistic
     * const NovelStatistic = await prisma.novelStatistic.create({
     *   data: {
     *     // ... data to create a NovelStatistic
     *   }
     * })
     * 
     */
    create<T extends NovelStatisticCreateArgs>(args: SelectSubset<T, NovelStatisticCreateArgs<ExtArgs>>): Prisma__NovelStatisticClient<$Result.GetResult<Prisma.$NovelStatisticPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many NovelStatistics.
     * @param {NovelStatisticCreateManyArgs} args - Arguments to create many NovelStatistics.
     * @example
     * // Create many NovelStatistics
     * const novelStatistic = await prisma.novelStatistic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NovelStatisticCreateManyArgs>(args?: SelectSubset<T, NovelStatisticCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NovelStatistics and returns the data saved in the database.
     * @param {NovelStatisticCreateManyAndReturnArgs} args - Arguments to create many NovelStatistics.
     * @example
     * // Create many NovelStatistics
     * const novelStatistic = await prisma.novelStatistic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NovelStatistics and only return the `id`
     * const novelStatisticWithIdOnly = await prisma.novelStatistic.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NovelStatisticCreateManyAndReturnArgs>(args?: SelectSubset<T, NovelStatisticCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NovelStatisticPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a NovelStatistic.
     * @param {NovelStatisticDeleteArgs} args - Arguments to delete one NovelStatistic.
     * @example
     * // Delete one NovelStatistic
     * const NovelStatistic = await prisma.novelStatistic.delete({
     *   where: {
     *     // ... filter to delete one NovelStatistic
     *   }
     * })
     * 
     */
    delete<T extends NovelStatisticDeleteArgs>(args: SelectSubset<T, NovelStatisticDeleteArgs<ExtArgs>>): Prisma__NovelStatisticClient<$Result.GetResult<Prisma.$NovelStatisticPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one NovelStatistic.
     * @param {NovelStatisticUpdateArgs} args - Arguments to update one NovelStatistic.
     * @example
     * // Update one NovelStatistic
     * const novelStatistic = await prisma.novelStatistic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NovelStatisticUpdateArgs>(args: SelectSubset<T, NovelStatisticUpdateArgs<ExtArgs>>): Prisma__NovelStatisticClient<$Result.GetResult<Prisma.$NovelStatisticPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more NovelStatistics.
     * @param {NovelStatisticDeleteManyArgs} args - Arguments to filter NovelStatistics to delete.
     * @example
     * // Delete a few NovelStatistics
     * const { count } = await prisma.novelStatistic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NovelStatisticDeleteManyArgs>(args?: SelectSubset<T, NovelStatisticDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NovelStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NovelStatisticUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NovelStatistics
     * const novelStatistic = await prisma.novelStatistic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NovelStatisticUpdateManyArgs>(args: SelectSubset<T, NovelStatisticUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NovelStatistics and returns the data updated in the database.
     * @param {NovelStatisticUpdateManyAndReturnArgs} args - Arguments to update many NovelStatistics.
     * @example
     * // Update many NovelStatistics
     * const novelStatistic = await prisma.novelStatistic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NovelStatistics and only return the `id`
     * const novelStatisticWithIdOnly = await prisma.novelStatistic.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NovelStatisticUpdateManyAndReturnArgs>(args: SelectSubset<T, NovelStatisticUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NovelStatisticPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one NovelStatistic.
     * @param {NovelStatisticUpsertArgs} args - Arguments to update or create a NovelStatistic.
     * @example
     * // Update or create a NovelStatistic
     * const novelStatistic = await prisma.novelStatistic.upsert({
     *   create: {
     *     // ... data to create a NovelStatistic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NovelStatistic we want to update
     *   }
     * })
     */
    upsert<T extends NovelStatisticUpsertArgs>(args: SelectSubset<T, NovelStatisticUpsertArgs<ExtArgs>>): Prisma__NovelStatisticClient<$Result.GetResult<Prisma.$NovelStatisticPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of NovelStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NovelStatisticCountArgs} args - Arguments to filter NovelStatistics to count.
     * @example
     * // Count the number of NovelStatistics
     * const count = await prisma.novelStatistic.count({
     *   where: {
     *     // ... the filter for the NovelStatistics we want to count
     *   }
     * })
    **/
    count<T extends NovelStatisticCountArgs>(
      args?: Subset<T, NovelStatisticCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NovelStatisticCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NovelStatistic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NovelStatisticAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NovelStatisticAggregateArgs>(args: Subset<T, NovelStatisticAggregateArgs>): Prisma.PrismaPromise<GetNovelStatisticAggregateType<T>>

    /**
     * Group by NovelStatistic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NovelStatisticGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NovelStatisticGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NovelStatisticGroupByArgs['orderBy'] }
        : { orderBy?: NovelStatisticGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NovelStatisticGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNovelStatisticGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NovelStatistic model
   */
  readonly fields: NovelStatisticFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NovelStatistic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NovelStatisticClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    novel<T extends NovelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NovelDefaultArgs<ExtArgs>>): Prisma__NovelClient<$Result.GetResult<Prisma.$NovelPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NovelStatistic model
   */ 
  interface NovelStatisticFieldRefs {
    readonly id: FieldRef<"NovelStatistic", 'Int'>
    readonly novelId: FieldRef<"NovelStatistic", 'Int'>
    readonly dailyViews: FieldRef<"NovelStatistic", 'Int'>
    readonly totalViews: FieldRef<"NovelStatistic", 'Int'>
    readonly reviews: FieldRef<"NovelStatistic", 'Int'>
    readonly comments: FieldRef<"NovelStatistic", 'Int'>
    readonly date: FieldRef<"NovelStatistic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NovelStatistic findUnique
   */
  export type NovelStatisticFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelStatistic
     */
    select?: NovelStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NovelStatistic
     */
    omit?: NovelStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelStatisticInclude<ExtArgs> | null
    /**
     * Filter, which NovelStatistic to fetch.
     */
    where: NovelStatisticWhereUniqueInput
  }

  /**
   * NovelStatistic findUniqueOrThrow
   */
  export type NovelStatisticFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelStatistic
     */
    select?: NovelStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NovelStatistic
     */
    omit?: NovelStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelStatisticInclude<ExtArgs> | null
    /**
     * Filter, which NovelStatistic to fetch.
     */
    where: NovelStatisticWhereUniqueInput
  }

  /**
   * NovelStatistic findFirst
   */
  export type NovelStatisticFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelStatistic
     */
    select?: NovelStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NovelStatistic
     */
    omit?: NovelStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelStatisticInclude<ExtArgs> | null
    /**
     * Filter, which NovelStatistic to fetch.
     */
    where?: NovelStatisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NovelStatistics to fetch.
     */
    orderBy?: NovelStatisticOrderByWithRelationInput | NovelStatisticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NovelStatistics.
     */
    cursor?: NovelStatisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NovelStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NovelStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NovelStatistics.
     */
    distinct?: NovelStatisticScalarFieldEnum | NovelStatisticScalarFieldEnum[]
  }

  /**
   * NovelStatistic findFirstOrThrow
   */
  export type NovelStatisticFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelStatistic
     */
    select?: NovelStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NovelStatistic
     */
    omit?: NovelStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelStatisticInclude<ExtArgs> | null
    /**
     * Filter, which NovelStatistic to fetch.
     */
    where?: NovelStatisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NovelStatistics to fetch.
     */
    orderBy?: NovelStatisticOrderByWithRelationInput | NovelStatisticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NovelStatistics.
     */
    cursor?: NovelStatisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NovelStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NovelStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NovelStatistics.
     */
    distinct?: NovelStatisticScalarFieldEnum | NovelStatisticScalarFieldEnum[]
  }

  /**
   * NovelStatistic findMany
   */
  export type NovelStatisticFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelStatistic
     */
    select?: NovelStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NovelStatistic
     */
    omit?: NovelStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelStatisticInclude<ExtArgs> | null
    /**
     * Filter, which NovelStatistics to fetch.
     */
    where?: NovelStatisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NovelStatistics to fetch.
     */
    orderBy?: NovelStatisticOrderByWithRelationInput | NovelStatisticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NovelStatistics.
     */
    cursor?: NovelStatisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NovelStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NovelStatistics.
     */
    skip?: number
    distinct?: NovelStatisticScalarFieldEnum | NovelStatisticScalarFieldEnum[]
  }

  /**
   * NovelStatistic create
   */
  export type NovelStatisticCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelStatistic
     */
    select?: NovelStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NovelStatistic
     */
    omit?: NovelStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelStatisticInclude<ExtArgs> | null
    /**
     * The data needed to create a NovelStatistic.
     */
    data: XOR<NovelStatisticCreateInput, NovelStatisticUncheckedCreateInput>
  }

  /**
   * NovelStatistic createMany
   */
  export type NovelStatisticCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NovelStatistics.
     */
    data: NovelStatisticCreateManyInput | NovelStatisticCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NovelStatistic createManyAndReturn
   */
  export type NovelStatisticCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelStatistic
     */
    select?: NovelStatisticSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NovelStatistic
     */
    omit?: NovelStatisticOmit<ExtArgs> | null
    /**
     * The data used to create many NovelStatistics.
     */
    data: NovelStatisticCreateManyInput | NovelStatisticCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelStatisticIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NovelStatistic update
   */
  export type NovelStatisticUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelStatistic
     */
    select?: NovelStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NovelStatistic
     */
    omit?: NovelStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelStatisticInclude<ExtArgs> | null
    /**
     * The data needed to update a NovelStatistic.
     */
    data: XOR<NovelStatisticUpdateInput, NovelStatisticUncheckedUpdateInput>
    /**
     * Choose, which NovelStatistic to update.
     */
    where: NovelStatisticWhereUniqueInput
  }

  /**
   * NovelStatistic updateMany
   */
  export type NovelStatisticUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NovelStatistics.
     */
    data: XOR<NovelStatisticUpdateManyMutationInput, NovelStatisticUncheckedUpdateManyInput>
    /**
     * Filter which NovelStatistics to update
     */
    where?: NovelStatisticWhereInput
    /**
     * Limit how many NovelStatistics to update.
     */
    limit?: number
  }

  /**
   * NovelStatistic updateManyAndReturn
   */
  export type NovelStatisticUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelStatistic
     */
    select?: NovelStatisticSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NovelStatistic
     */
    omit?: NovelStatisticOmit<ExtArgs> | null
    /**
     * The data used to update NovelStatistics.
     */
    data: XOR<NovelStatisticUpdateManyMutationInput, NovelStatisticUncheckedUpdateManyInput>
    /**
     * Filter which NovelStatistics to update
     */
    where?: NovelStatisticWhereInput
    /**
     * Limit how many NovelStatistics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelStatisticIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NovelStatistic upsert
   */
  export type NovelStatisticUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelStatistic
     */
    select?: NovelStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NovelStatistic
     */
    omit?: NovelStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelStatisticInclude<ExtArgs> | null
    /**
     * The filter to search for the NovelStatistic to update in case it exists.
     */
    where: NovelStatisticWhereUniqueInput
    /**
     * In case the NovelStatistic found by the `where` argument doesn't exist, create a new NovelStatistic with this data.
     */
    create: XOR<NovelStatisticCreateInput, NovelStatisticUncheckedCreateInput>
    /**
     * In case the NovelStatistic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NovelStatisticUpdateInput, NovelStatisticUncheckedUpdateInput>
  }

  /**
   * NovelStatistic delete
   */
  export type NovelStatisticDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelStatistic
     */
    select?: NovelStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NovelStatistic
     */
    omit?: NovelStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelStatisticInclude<ExtArgs> | null
    /**
     * Filter which NovelStatistic to delete.
     */
    where: NovelStatisticWhereUniqueInput
  }

  /**
   * NovelStatistic deleteMany
   */
  export type NovelStatisticDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NovelStatistics to delete
     */
    where?: NovelStatisticWhereInput
    /**
     * Limit how many NovelStatistics to delete.
     */
    limit?: number
  }

  /**
   * NovelStatistic without action
   */
  export type NovelStatisticDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NovelStatistic
     */
    select?: NovelStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NovelStatistic
     */
    omit?: NovelStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NovelStatisticInclude<ExtArgs> | null
  }


  /**
   * Model ChapterStatistic
   */

  export type AggregateChapterStatistic = {
    _count: ChapterStatisticCountAggregateOutputType | null
    _avg: ChapterStatisticAvgAggregateOutputType | null
    _sum: ChapterStatisticSumAggregateOutputType | null
    _min: ChapterStatisticMinAggregateOutputType | null
    _max: ChapterStatisticMaxAggregateOutputType | null
  }

  export type ChapterStatisticAvgAggregateOutputType = {
    id: number | null
    chapterId: number | null
    views: number | null
  }

  export type ChapterStatisticSumAggregateOutputType = {
    id: number | null
    chapterId: number | null
    views: number | null
  }

  export type ChapterStatisticMinAggregateOutputType = {
    id: number | null
    chapterId: number | null
    views: number | null
    date: Date | null
  }

  export type ChapterStatisticMaxAggregateOutputType = {
    id: number | null
    chapterId: number | null
    views: number | null
    date: Date | null
  }

  export type ChapterStatisticCountAggregateOutputType = {
    id: number
    chapterId: number
    views: number
    date: number
    _all: number
  }


  export type ChapterStatisticAvgAggregateInputType = {
    id?: true
    chapterId?: true
    views?: true
  }

  export type ChapterStatisticSumAggregateInputType = {
    id?: true
    chapterId?: true
    views?: true
  }

  export type ChapterStatisticMinAggregateInputType = {
    id?: true
    chapterId?: true
    views?: true
    date?: true
  }

  export type ChapterStatisticMaxAggregateInputType = {
    id?: true
    chapterId?: true
    views?: true
    date?: true
  }

  export type ChapterStatisticCountAggregateInputType = {
    id?: true
    chapterId?: true
    views?: true
    date?: true
    _all?: true
  }

  export type ChapterStatisticAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChapterStatistic to aggregate.
     */
    where?: ChapterStatisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterStatistics to fetch.
     */
    orderBy?: ChapterStatisticOrderByWithRelationInput | ChapterStatisticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChapterStatisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChapterStatistics
    **/
    _count?: true | ChapterStatisticCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChapterStatisticAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChapterStatisticSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChapterStatisticMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChapterStatisticMaxAggregateInputType
  }

  export type GetChapterStatisticAggregateType<T extends ChapterStatisticAggregateArgs> = {
        [P in keyof T & keyof AggregateChapterStatistic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChapterStatistic[P]>
      : GetScalarType<T[P], AggregateChapterStatistic[P]>
  }




  export type ChapterStatisticGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChapterStatisticWhereInput
    orderBy?: ChapterStatisticOrderByWithAggregationInput | ChapterStatisticOrderByWithAggregationInput[]
    by: ChapterStatisticScalarFieldEnum[] | ChapterStatisticScalarFieldEnum
    having?: ChapterStatisticScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChapterStatisticCountAggregateInputType | true
    _avg?: ChapterStatisticAvgAggregateInputType
    _sum?: ChapterStatisticSumAggregateInputType
    _min?: ChapterStatisticMinAggregateInputType
    _max?: ChapterStatisticMaxAggregateInputType
  }

  export type ChapterStatisticGroupByOutputType = {
    id: number
    chapterId: number
    views: number
    date: Date
    _count: ChapterStatisticCountAggregateOutputType | null
    _avg: ChapterStatisticAvgAggregateOutputType | null
    _sum: ChapterStatisticSumAggregateOutputType | null
    _min: ChapterStatisticMinAggregateOutputType | null
    _max: ChapterStatisticMaxAggregateOutputType | null
  }

  type GetChapterStatisticGroupByPayload<T extends ChapterStatisticGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChapterStatisticGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChapterStatisticGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChapterStatisticGroupByOutputType[P]>
            : GetScalarType<T[P], ChapterStatisticGroupByOutputType[P]>
        }
      >
    >


  export type ChapterStatisticSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapterId?: boolean
    views?: boolean
    date?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapterStatistic"]>

  export type ChapterStatisticSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapterId?: boolean
    views?: boolean
    date?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapterStatistic"]>

  export type ChapterStatisticSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chapterId?: boolean
    views?: boolean
    date?: boolean
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chapterStatistic"]>

  export type ChapterStatisticSelectScalar = {
    id?: boolean
    chapterId?: boolean
    views?: boolean
    date?: boolean
  }

  export type ChapterStatisticOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chapterId" | "views" | "date", ExtArgs["result"]["chapterStatistic"]>
  export type ChapterStatisticInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }
  export type ChapterStatisticIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }
  export type ChapterStatisticIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chapter?: boolean | ChapterDefaultArgs<ExtArgs>
  }

  export type $ChapterStatisticPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChapterStatistic"
    objects: {
      chapter: Prisma.$ChapterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      chapterId: number
      views: number
      date: Date
    }, ExtArgs["result"]["chapterStatistic"]>
    composites: {}
  }

  type ChapterStatisticGetPayload<S extends boolean | null | undefined | ChapterStatisticDefaultArgs> = $Result.GetResult<Prisma.$ChapterStatisticPayload, S>

  type ChapterStatisticCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChapterStatisticFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChapterStatisticCountAggregateInputType | true
    }

  export interface ChapterStatisticDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChapterStatistic'], meta: { name: 'ChapterStatistic' } }
    /**
     * Find zero or one ChapterStatistic that matches the filter.
     * @param {ChapterStatisticFindUniqueArgs} args - Arguments to find a ChapterStatistic
     * @example
     * // Get one ChapterStatistic
     * const chapterStatistic = await prisma.chapterStatistic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChapterStatisticFindUniqueArgs>(args: SelectSubset<T, ChapterStatisticFindUniqueArgs<ExtArgs>>): Prisma__ChapterStatisticClient<$Result.GetResult<Prisma.$ChapterStatisticPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ChapterStatistic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChapterStatisticFindUniqueOrThrowArgs} args - Arguments to find a ChapterStatistic
     * @example
     * // Get one ChapterStatistic
     * const chapterStatistic = await prisma.chapterStatistic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChapterStatisticFindUniqueOrThrowArgs>(args: SelectSubset<T, ChapterStatisticFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChapterStatisticClient<$Result.GetResult<Prisma.$ChapterStatisticPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ChapterStatistic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterStatisticFindFirstArgs} args - Arguments to find a ChapterStatistic
     * @example
     * // Get one ChapterStatistic
     * const chapterStatistic = await prisma.chapterStatistic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChapterStatisticFindFirstArgs>(args?: SelectSubset<T, ChapterStatisticFindFirstArgs<ExtArgs>>): Prisma__ChapterStatisticClient<$Result.GetResult<Prisma.$ChapterStatisticPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ChapterStatistic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterStatisticFindFirstOrThrowArgs} args - Arguments to find a ChapterStatistic
     * @example
     * // Get one ChapterStatistic
     * const chapterStatistic = await prisma.chapterStatistic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChapterStatisticFindFirstOrThrowArgs>(args?: SelectSubset<T, ChapterStatisticFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChapterStatisticClient<$Result.GetResult<Prisma.$ChapterStatisticPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ChapterStatistics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterStatisticFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChapterStatistics
     * const chapterStatistics = await prisma.chapterStatistic.findMany()
     * 
     * // Get first 10 ChapterStatistics
     * const chapterStatistics = await prisma.chapterStatistic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chapterStatisticWithIdOnly = await prisma.chapterStatistic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChapterStatisticFindManyArgs>(args?: SelectSubset<T, ChapterStatisticFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterStatisticPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ChapterStatistic.
     * @param {ChapterStatisticCreateArgs} args - Arguments to create a ChapterStatistic.
     * @example
     * // Create one ChapterStatistic
     * const ChapterStatistic = await prisma.chapterStatistic.create({
     *   data: {
     *     // ... data to create a ChapterStatistic
     *   }
     * })
     * 
     */
    create<T extends ChapterStatisticCreateArgs>(args: SelectSubset<T, ChapterStatisticCreateArgs<ExtArgs>>): Prisma__ChapterStatisticClient<$Result.GetResult<Prisma.$ChapterStatisticPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ChapterStatistics.
     * @param {ChapterStatisticCreateManyArgs} args - Arguments to create many ChapterStatistics.
     * @example
     * // Create many ChapterStatistics
     * const chapterStatistic = await prisma.chapterStatistic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChapterStatisticCreateManyArgs>(args?: SelectSubset<T, ChapterStatisticCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChapterStatistics and returns the data saved in the database.
     * @param {ChapterStatisticCreateManyAndReturnArgs} args - Arguments to create many ChapterStatistics.
     * @example
     * // Create many ChapterStatistics
     * const chapterStatistic = await prisma.chapterStatistic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChapterStatistics and only return the `id`
     * const chapterStatisticWithIdOnly = await prisma.chapterStatistic.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChapterStatisticCreateManyAndReturnArgs>(args?: SelectSubset<T, ChapterStatisticCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterStatisticPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ChapterStatistic.
     * @param {ChapterStatisticDeleteArgs} args - Arguments to delete one ChapterStatistic.
     * @example
     * // Delete one ChapterStatistic
     * const ChapterStatistic = await prisma.chapterStatistic.delete({
     *   where: {
     *     // ... filter to delete one ChapterStatistic
     *   }
     * })
     * 
     */
    delete<T extends ChapterStatisticDeleteArgs>(args: SelectSubset<T, ChapterStatisticDeleteArgs<ExtArgs>>): Prisma__ChapterStatisticClient<$Result.GetResult<Prisma.$ChapterStatisticPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ChapterStatistic.
     * @param {ChapterStatisticUpdateArgs} args - Arguments to update one ChapterStatistic.
     * @example
     * // Update one ChapterStatistic
     * const chapterStatistic = await prisma.chapterStatistic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChapterStatisticUpdateArgs>(args: SelectSubset<T, ChapterStatisticUpdateArgs<ExtArgs>>): Prisma__ChapterStatisticClient<$Result.GetResult<Prisma.$ChapterStatisticPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ChapterStatistics.
     * @param {ChapterStatisticDeleteManyArgs} args - Arguments to filter ChapterStatistics to delete.
     * @example
     * // Delete a few ChapterStatistics
     * const { count } = await prisma.chapterStatistic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChapterStatisticDeleteManyArgs>(args?: SelectSubset<T, ChapterStatisticDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChapterStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterStatisticUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChapterStatistics
     * const chapterStatistic = await prisma.chapterStatistic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChapterStatisticUpdateManyArgs>(args: SelectSubset<T, ChapterStatisticUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChapterStatistics and returns the data updated in the database.
     * @param {ChapterStatisticUpdateManyAndReturnArgs} args - Arguments to update many ChapterStatistics.
     * @example
     * // Update many ChapterStatistics
     * const chapterStatistic = await prisma.chapterStatistic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChapterStatistics and only return the `id`
     * const chapterStatisticWithIdOnly = await prisma.chapterStatistic.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChapterStatisticUpdateManyAndReturnArgs>(args: SelectSubset<T, ChapterStatisticUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChapterStatisticPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ChapterStatistic.
     * @param {ChapterStatisticUpsertArgs} args - Arguments to update or create a ChapterStatistic.
     * @example
     * // Update or create a ChapterStatistic
     * const chapterStatistic = await prisma.chapterStatistic.upsert({
     *   create: {
     *     // ... data to create a ChapterStatistic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChapterStatistic we want to update
     *   }
     * })
     */
    upsert<T extends ChapterStatisticUpsertArgs>(args: SelectSubset<T, ChapterStatisticUpsertArgs<ExtArgs>>): Prisma__ChapterStatisticClient<$Result.GetResult<Prisma.$ChapterStatisticPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ChapterStatistics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterStatisticCountArgs} args - Arguments to filter ChapterStatistics to count.
     * @example
     * // Count the number of ChapterStatistics
     * const count = await prisma.chapterStatistic.count({
     *   where: {
     *     // ... the filter for the ChapterStatistics we want to count
     *   }
     * })
    **/
    count<T extends ChapterStatisticCountArgs>(
      args?: Subset<T, ChapterStatisticCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChapterStatisticCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChapterStatistic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterStatisticAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChapterStatisticAggregateArgs>(args: Subset<T, ChapterStatisticAggregateArgs>): Prisma.PrismaPromise<GetChapterStatisticAggregateType<T>>

    /**
     * Group by ChapterStatistic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChapterStatisticGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChapterStatisticGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChapterStatisticGroupByArgs['orderBy'] }
        : { orderBy?: ChapterStatisticGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChapterStatisticGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChapterStatisticGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChapterStatistic model
   */
  readonly fields: ChapterStatisticFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChapterStatistic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChapterStatisticClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chapter<T extends ChapterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChapterDefaultArgs<ExtArgs>>): Prisma__ChapterClient<$Result.GetResult<Prisma.$ChapterPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChapterStatistic model
   */ 
  interface ChapterStatisticFieldRefs {
    readonly id: FieldRef<"ChapterStatistic", 'Int'>
    readonly chapterId: FieldRef<"ChapterStatistic", 'Int'>
    readonly views: FieldRef<"ChapterStatistic", 'Int'>
    readonly date: FieldRef<"ChapterStatistic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChapterStatistic findUnique
   */
  export type ChapterStatisticFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterStatistic
     */
    select?: ChapterStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterStatistic
     */
    omit?: ChapterStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterStatisticInclude<ExtArgs> | null
    /**
     * Filter, which ChapterStatistic to fetch.
     */
    where: ChapterStatisticWhereUniqueInput
  }

  /**
   * ChapterStatistic findUniqueOrThrow
   */
  export type ChapterStatisticFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterStatistic
     */
    select?: ChapterStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterStatistic
     */
    omit?: ChapterStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterStatisticInclude<ExtArgs> | null
    /**
     * Filter, which ChapterStatistic to fetch.
     */
    where: ChapterStatisticWhereUniqueInput
  }

  /**
   * ChapterStatistic findFirst
   */
  export type ChapterStatisticFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterStatistic
     */
    select?: ChapterStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterStatistic
     */
    omit?: ChapterStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterStatisticInclude<ExtArgs> | null
    /**
     * Filter, which ChapterStatistic to fetch.
     */
    where?: ChapterStatisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterStatistics to fetch.
     */
    orderBy?: ChapterStatisticOrderByWithRelationInput | ChapterStatisticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChapterStatistics.
     */
    cursor?: ChapterStatisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChapterStatistics.
     */
    distinct?: ChapterStatisticScalarFieldEnum | ChapterStatisticScalarFieldEnum[]
  }

  /**
   * ChapterStatistic findFirstOrThrow
   */
  export type ChapterStatisticFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterStatistic
     */
    select?: ChapterStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterStatistic
     */
    omit?: ChapterStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterStatisticInclude<ExtArgs> | null
    /**
     * Filter, which ChapterStatistic to fetch.
     */
    where?: ChapterStatisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterStatistics to fetch.
     */
    orderBy?: ChapterStatisticOrderByWithRelationInput | ChapterStatisticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChapterStatistics.
     */
    cursor?: ChapterStatisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterStatistics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChapterStatistics.
     */
    distinct?: ChapterStatisticScalarFieldEnum | ChapterStatisticScalarFieldEnum[]
  }

  /**
   * ChapterStatistic findMany
   */
  export type ChapterStatisticFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterStatistic
     */
    select?: ChapterStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterStatistic
     */
    omit?: ChapterStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterStatisticInclude<ExtArgs> | null
    /**
     * Filter, which ChapterStatistics to fetch.
     */
    where?: ChapterStatisticWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChapterStatistics to fetch.
     */
    orderBy?: ChapterStatisticOrderByWithRelationInput | ChapterStatisticOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChapterStatistics.
     */
    cursor?: ChapterStatisticWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChapterStatistics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChapterStatistics.
     */
    skip?: number
    distinct?: ChapterStatisticScalarFieldEnum | ChapterStatisticScalarFieldEnum[]
  }

  /**
   * ChapterStatistic create
   */
  export type ChapterStatisticCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterStatistic
     */
    select?: ChapterStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterStatistic
     */
    omit?: ChapterStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterStatisticInclude<ExtArgs> | null
    /**
     * The data needed to create a ChapterStatistic.
     */
    data: XOR<ChapterStatisticCreateInput, ChapterStatisticUncheckedCreateInput>
  }

  /**
   * ChapterStatistic createMany
   */
  export type ChapterStatisticCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChapterStatistics.
     */
    data: ChapterStatisticCreateManyInput | ChapterStatisticCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChapterStatistic createManyAndReturn
   */
  export type ChapterStatisticCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterStatistic
     */
    select?: ChapterStatisticSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterStatistic
     */
    omit?: ChapterStatisticOmit<ExtArgs> | null
    /**
     * The data used to create many ChapterStatistics.
     */
    data: ChapterStatisticCreateManyInput | ChapterStatisticCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterStatisticIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChapterStatistic update
   */
  export type ChapterStatisticUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterStatistic
     */
    select?: ChapterStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterStatistic
     */
    omit?: ChapterStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterStatisticInclude<ExtArgs> | null
    /**
     * The data needed to update a ChapterStatistic.
     */
    data: XOR<ChapterStatisticUpdateInput, ChapterStatisticUncheckedUpdateInput>
    /**
     * Choose, which ChapterStatistic to update.
     */
    where: ChapterStatisticWhereUniqueInput
  }

  /**
   * ChapterStatistic updateMany
   */
  export type ChapterStatisticUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChapterStatistics.
     */
    data: XOR<ChapterStatisticUpdateManyMutationInput, ChapterStatisticUncheckedUpdateManyInput>
    /**
     * Filter which ChapterStatistics to update
     */
    where?: ChapterStatisticWhereInput
    /**
     * Limit how many ChapterStatistics to update.
     */
    limit?: number
  }

  /**
   * ChapterStatistic updateManyAndReturn
   */
  export type ChapterStatisticUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterStatistic
     */
    select?: ChapterStatisticSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterStatistic
     */
    omit?: ChapterStatisticOmit<ExtArgs> | null
    /**
     * The data used to update ChapterStatistics.
     */
    data: XOR<ChapterStatisticUpdateManyMutationInput, ChapterStatisticUncheckedUpdateManyInput>
    /**
     * Filter which ChapterStatistics to update
     */
    where?: ChapterStatisticWhereInput
    /**
     * Limit how many ChapterStatistics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterStatisticIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChapterStatistic upsert
   */
  export type ChapterStatisticUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterStatistic
     */
    select?: ChapterStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterStatistic
     */
    omit?: ChapterStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterStatisticInclude<ExtArgs> | null
    /**
     * The filter to search for the ChapterStatistic to update in case it exists.
     */
    where: ChapterStatisticWhereUniqueInput
    /**
     * In case the ChapterStatistic found by the `where` argument doesn't exist, create a new ChapterStatistic with this data.
     */
    create: XOR<ChapterStatisticCreateInput, ChapterStatisticUncheckedCreateInput>
    /**
     * In case the ChapterStatistic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChapterStatisticUpdateInput, ChapterStatisticUncheckedUpdateInput>
  }

  /**
   * ChapterStatistic delete
   */
  export type ChapterStatisticDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterStatistic
     */
    select?: ChapterStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterStatistic
     */
    omit?: ChapterStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterStatisticInclude<ExtArgs> | null
    /**
     * Filter which ChapterStatistic to delete.
     */
    where: ChapterStatisticWhereUniqueInput
  }

  /**
   * ChapterStatistic deleteMany
   */
  export type ChapterStatisticDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChapterStatistics to delete
     */
    where?: ChapterStatisticWhereInput
    /**
     * Limit how many ChapterStatistics to delete.
     */
    limit?: number
  }

  /**
   * ChapterStatistic without action
   */
  export type ChapterStatisticDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChapterStatistic
     */
    select?: ChapterStatisticSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChapterStatistic
     */
    omit?: ChapterStatisticOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChapterStatisticInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    nickname: 'nickname',
    email: 'email',
    password: 'password',
    phone: 'phone',
    avatar: 'avatar',
    coverImage: 'coverImage',
    role: 'role',
    gender: 'gender',
    bio: 'bio',
    birthDate: 'birthDate',
    socialLinks: 'socialLinks',
    keys: 'keys',
    tickets: 'tickets',
    candies: 'candies',
    createdAt: 'createdAt',
    emailVerifiedAt: 'emailVerifiedAt',
    isTwoFactorAuth: 'isTwoFactorAuth'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    token: 'token',
    userId: 'userId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const NotificationSettingsScalarFieldEnum: {
    userId: 'userId',
    enableNewChapter: 'enableNewChapter',
    enableInteractions: 'enableInteractions'
  };

  export type NotificationSettingsScalarFieldEnum = (typeof NotificationSettingsScalarFieldEnum)[keyof typeof NotificationSettingsScalarFieldEnum]


  export const AuthorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    originalName: 'originalName',
    country: 'country'
  };

  export type AuthorScalarFieldEnum = (typeof AuthorScalarFieldEnum)[keyof typeof AuthorScalarFieldEnum]


  export const NovelScalarFieldEnum: {
    id: 'id',
    title: 'title',
    originalTitle: 'originalTitle',
    authorId: 'authorId',
    createdById: 'createdById',
    genreId: 'genreId',
    kind: 'kind',
    gender: 'gender',
    status: 'status',
    synopsis: 'synopsis',
    coverImage: 'coverImage',
    wordCount: 'wordCount',
    totalChapters: 'totalChapters',
    publishedAt: 'publishedAt',
    newChapterAt: 'newChapterAt',
    createdAt: 'createdAt'
  };

  export type NovelScalarFieldEnum = (typeof NovelScalarFieldEnum)[keyof typeof NovelScalarFieldEnum]


  export const GenreScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type GenreScalarFieldEnum = (typeof GenreScalarFieldEnum)[keyof typeof GenreScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    tagGroupId: 'tagGroupId'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const TagGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    color: 'color'
  };

  export type TagGroupScalarFieldEnum = (typeof TagGroupScalarFieldEnum)[keyof typeof TagGroupScalarFieldEnum]


  export const NovelTagScalarFieldEnum: {
    novelId: 'novelId',
    tagId: 'tagId'
  };

  export type NovelTagScalarFieldEnum = (typeof NovelTagScalarFieldEnum)[keyof typeof NovelTagScalarFieldEnum]


  export const ChapterScalarFieldEnum: {
    id: 'id',
    novelId: 'novelId',
    chapterNumber: 'chapterNumber',
    title: 'title',
    content: 'content',
    isLocked: 'isLocked',
    unlockCost: 'unlockCost',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChapterScalarFieldEnum = (typeof ChapterScalarFieldEnum)[keyof typeof ChapterScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    rating: 'rating',
    content: 'content',
    isSpoiler: 'isSpoiler',
    userId: 'userId',
    novelId: 'novelId',
    createdAt: 'createdAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    likes: 'likes',
    userId: 'userId',
    chapterId: 'chapterId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    novelId: 'novelId'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const ReplyCommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    likes: 'likes',
    userId: 'userId',
    commentId: 'commentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReplyCommentScalarFieldEnum = (typeof ReplyCommentScalarFieldEnum)[keyof typeof ReplyCommentScalarFieldEnum]


  export const ReadingScalarFieldEnum: {
    userId: 'userId',
    novelId: 'novelId',
    chapterId: 'chapterId',
    lastRead: 'lastRead'
  };

  export type ReadingScalarFieldEnum = (typeof ReadingScalarFieldEnum)[keyof typeof ReadingScalarFieldEnum]


  export const FavoriteScalarFieldEnum: {
    userId: 'userId',
    novelId: 'novelId',
    createdAt: 'createdAt'
  };

  export type FavoriteScalarFieldEnum = (typeof FavoriteScalarFieldEnum)[keyof typeof FavoriteScalarFieldEnum]


  export const NovelStatisticScalarFieldEnum: {
    id: 'id',
    novelId: 'novelId',
    dailyViews: 'dailyViews',
    totalViews: 'totalViews',
    reviews: 'reviews',
    comments: 'comments',
    date: 'date'
  };

  export type NovelStatisticScalarFieldEnum = (typeof NovelStatisticScalarFieldEnum)[keyof typeof NovelStatisticScalarFieldEnum]


  export const ChapterStatisticScalarFieldEnum: {
    id: 'id',
    chapterId: 'chapterId',
    views: 'views',
    date: 'date'
  };

  export type ChapterStatisticScalarFieldEnum = (typeof ChapterStatisticScalarFieldEnum)[keyof typeof ChapterStatisticScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'NovelKind'
   */
  export type EnumNovelKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NovelKind'>
    


  /**
   * Reference to a field of type 'NovelKind[]'
   */
  export type ListEnumNovelKindFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NovelKind[]'>
    


  /**
   * Reference to a field of type 'NovelStatus'
   */
  export type EnumNovelStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NovelStatus'>
    


  /**
   * Reference to a field of type 'NovelStatus[]'
   */
  export type ListEnumNovelStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NovelStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    nickname?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    phone?: StringFilter<"User"> | string
    avatar?: StringFilter<"User"> | string
    coverImage?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    gender?: EnumGenderFilter<"User"> | $Enums.Gender
    bio?: StringFilter<"User"> | string
    birthDate?: DateTimeFilter<"User"> | Date | string
    socialLinks?: StringNullableListFilter<"User">
    keys?: IntFilter<"User"> | number
    tickets?: IntFilter<"User"> | number
    candies?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isTwoFactorAuth?: BoolFilter<"User"> | boolean
    notifications?: XOR<NotificationSettingsNullableScalarRelationFilter, NotificationSettingsWhereInput> | null
    reviews?: ReviewListRelationFilter
    comments?: CommentListRelationFilter
    authoredNovels?: NovelListRelationFilter
    sessions?: RefreshTokenListRelationFilter
    readings?: ReadingListRelationFilter
    favorites?: FavoriteListRelationFilter
    replies?: ReplyCommentListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    nickname?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    coverImage?: SortOrder
    role?: SortOrder
    gender?: SortOrder
    bio?: SortOrder
    birthDate?: SortOrder
    socialLinks?: SortOrder
    keys?: SortOrder
    tickets?: SortOrder
    candies?: SortOrder
    createdAt?: SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    isTwoFactorAuth?: SortOrder
    notifications?: NotificationSettingsOrderByWithRelationInput
    reviews?: ReviewOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    authoredNovels?: NovelOrderByRelationAggregateInput
    sessions?: RefreshTokenOrderByRelationAggregateInput
    readings?: ReadingOrderByRelationAggregateInput
    favorites?: FavoriteOrderByRelationAggregateInput
    replies?: ReplyCommentOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    nickname?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    phone?: StringFilter<"User"> | string
    avatar?: StringFilter<"User"> | string
    coverImage?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    gender?: EnumGenderFilter<"User"> | $Enums.Gender
    bio?: StringFilter<"User"> | string
    birthDate?: DateTimeFilter<"User"> | Date | string
    socialLinks?: StringNullableListFilter<"User">
    keys?: IntFilter<"User"> | number
    tickets?: IntFilter<"User"> | number
    candies?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    isTwoFactorAuth?: BoolFilter<"User"> | boolean
    notifications?: XOR<NotificationSettingsNullableScalarRelationFilter, NotificationSettingsWhereInput> | null
    reviews?: ReviewListRelationFilter
    comments?: CommentListRelationFilter
    authoredNovels?: NovelListRelationFilter
    sessions?: RefreshTokenListRelationFilter
    readings?: ReadingListRelationFilter
    favorites?: FavoriteListRelationFilter
    replies?: ReplyCommentListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    nickname?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    coverImage?: SortOrder
    role?: SortOrder
    gender?: SortOrder
    bio?: SortOrder
    birthDate?: SortOrder
    socialLinks?: SortOrder
    keys?: SortOrder
    tickets?: SortOrder
    candies?: SortOrder
    createdAt?: SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    isTwoFactorAuth?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    nickname?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringWithAggregatesFilter<"User"> | string
    coverImage?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    gender?: EnumGenderWithAggregatesFilter<"User"> | $Enums.Gender
    bio?: StringWithAggregatesFilter<"User"> | string
    birthDate?: DateTimeWithAggregatesFilter<"User"> | Date | string
    socialLinks?: StringNullableListFilter<"User">
    keys?: IntWithAggregatesFilter<"User"> | number
    tickets?: IntWithAggregatesFilter<"User"> | number
    candies?: IntWithAggregatesFilter<"User"> | number
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    emailVerifiedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    isTwoFactorAuth?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    token?: UuidFilter<"RefreshToken"> | string
    userId?: IntFilter<"RefreshToken"> | number
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: IntFilter<"RefreshToken"> | number
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _avg?: RefreshTokenAvgOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
    _sum?: RefreshTokenSumOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    token?: UuidWithAggregatesFilter<"RefreshToken"> | string
    userId?: IntWithAggregatesFilter<"RefreshToken"> | number
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type NotificationSettingsWhereInput = {
    AND?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    OR?: NotificationSettingsWhereInput[]
    NOT?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    userId?: IntFilter<"NotificationSettings"> | number
    enableNewChapter?: BoolFilter<"NotificationSettings"> | boolean
    enableInteractions?: BoolFilter<"NotificationSettings"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationSettingsOrderByWithRelationInput = {
    userId?: SortOrder
    enableNewChapter?: SortOrder
    enableInteractions?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationSettingsWhereUniqueInput = Prisma.AtLeast<{
    userId?: number
    AND?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    OR?: NotificationSettingsWhereInput[]
    NOT?: NotificationSettingsWhereInput | NotificationSettingsWhereInput[]
    enableNewChapter?: BoolFilter<"NotificationSettings"> | boolean
    enableInteractions?: BoolFilter<"NotificationSettings"> | boolean
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "userId" | "userId">

  export type NotificationSettingsOrderByWithAggregationInput = {
    userId?: SortOrder
    enableNewChapter?: SortOrder
    enableInteractions?: SortOrder
    _count?: NotificationSettingsCountOrderByAggregateInput
    _avg?: NotificationSettingsAvgOrderByAggregateInput
    _max?: NotificationSettingsMaxOrderByAggregateInput
    _min?: NotificationSettingsMinOrderByAggregateInput
    _sum?: NotificationSettingsSumOrderByAggregateInput
  }

  export type NotificationSettingsScalarWhereWithAggregatesInput = {
    AND?: NotificationSettingsScalarWhereWithAggregatesInput | NotificationSettingsScalarWhereWithAggregatesInput[]
    OR?: NotificationSettingsScalarWhereWithAggregatesInput[]
    NOT?: NotificationSettingsScalarWhereWithAggregatesInput | NotificationSettingsScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"NotificationSettings"> | number
    enableNewChapter?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
    enableInteractions?: BoolWithAggregatesFilter<"NotificationSettings"> | boolean
  }

  export type AuthorWhereInput = {
    AND?: AuthorWhereInput | AuthorWhereInput[]
    OR?: AuthorWhereInput[]
    NOT?: AuthorWhereInput | AuthorWhereInput[]
    id?: IntFilter<"Author"> | number
    name?: StringFilter<"Author"> | string
    originalName?: StringFilter<"Author"> | string
    country?: StringFilter<"Author"> | string
    novels?: NovelListRelationFilter
  }

  export type AuthorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    originalName?: SortOrder
    country?: SortOrder
    novels?: NovelOrderByRelationAggregateInput
  }

  export type AuthorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name_originalName?: AuthorNameOriginalNameCompoundUniqueInput
    AND?: AuthorWhereInput | AuthorWhereInput[]
    OR?: AuthorWhereInput[]
    NOT?: AuthorWhereInput | AuthorWhereInput[]
    name?: StringFilter<"Author"> | string
    originalName?: StringFilter<"Author"> | string
    country?: StringFilter<"Author"> | string
    novels?: NovelListRelationFilter
  }, "id" | "name_originalName">

  export type AuthorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    originalName?: SortOrder
    country?: SortOrder
    _count?: AuthorCountOrderByAggregateInput
    _avg?: AuthorAvgOrderByAggregateInput
    _max?: AuthorMaxOrderByAggregateInput
    _min?: AuthorMinOrderByAggregateInput
    _sum?: AuthorSumOrderByAggregateInput
  }

  export type AuthorScalarWhereWithAggregatesInput = {
    AND?: AuthorScalarWhereWithAggregatesInput | AuthorScalarWhereWithAggregatesInput[]
    OR?: AuthorScalarWhereWithAggregatesInput[]
    NOT?: AuthorScalarWhereWithAggregatesInput | AuthorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Author"> | number
    name?: StringWithAggregatesFilter<"Author"> | string
    originalName?: StringWithAggregatesFilter<"Author"> | string
    country?: StringWithAggregatesFilter<"Author"> | string
  }

  export type NovelWhereInput = {
    AND?: NovelWhereInput | NovelWhereInput[]
    OR?: NovelWhereInput[]
    NOT?: NovelWhereInput | NovelWhereInput[]
    id?: IntFilter<"Novel"> | number
    title?: StringFilter<"Novel"> | string
    originalTitle?: StringNullableFilter<"Novel"> | string | null
    authorId?: IntNullableFilter<"Novel"> | number | null
    createdById?: IntFilter<"Novel"> | number
    genreId?: IntFilter<"Novel"> | number
    kind?: EnumNovelKindFilter<"Novel"> | $Enums.NovelKind
    gender?: EnumGenderFilter<"Novel"> | $Enums.Gender
    status?: EnumNovelStatusFilter<"Novel"> | $Enums.NovelStatus
    synopsis?: StringFilter<"Novel"> | string
    coverImage?: StringFilter<"Novel"> | string
    wordCount?: IntFilter<"Novel"> | number
    totalChapters?: IntFilter<"Novel"> | number
    publishedAt?: DateTimeNullableFilter<"Novel"> | Date | string | null
    newChapterAt?: DateTimeFilter<"Novel"> | Date | string
    createdAt?: DateTimeFilter<"Novel"> | Date | string
    author?: XOR<AuthorNullableScalarRelationFilter, AuthorWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    genre?: XOR<GenreScalarRelationFilter, GenreWhereInput>
    chapters?: ChapterListRelationFilter
    novelTags?: NovelTagListRelationFilter
    reviews?: ReviewListRelationFilter
    statistics?: NovelStatisticListRelationFilter
    readers?: ReadingListRelationFilter
    favorites?: FavoriteListRelationFilter
    comments?: CommentListRelationFilter
  }

  export type NovelOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    originalTitle?: SortOrderInput | SortOrder
    authorId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    genreId?: SortOrder
    kind?: SortOrder
    gender?: SortOrder
    status?: SortOrder
    synopsis?: SortOrder
    coverImage?: SortOrder
    wordCount?: SortOrder
    totalChapters?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    newChapterAt?: SortOrder
    createdAt?: SortOrder
    author?: AuthorOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    genre?: GenreOrderByWithRelationInput
    chapters?: ChapterOrderByRelationAggregateInput
    novelTags?: NovelTagOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    statistics?: NovelStatisticOrderByRelationAggregateInput
    readers?: ReadingOrderByRelationAggregateInput
    favorites?: FavoriteOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
  }

  export type NovelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    title?: string
    createdById?: number
    AND?: NovelWhereInput | NovelWhereInput[]
    OR?: NovelWhereInput[]
    NOT?: NovelWhereInput | NovelWhereInput[]
    originalTitle?: StringNullableFilter<"Novel"> | string | null
    authorId?: IntNullableFilter<"Novel"> | number | null
    genreId?: IntFilter<"Novel"> | number
    kind?: EnumNovelKindFilter<"Novel"> | $Enums.NovelKind
    gender?: EnumGenderFilter<"Novel"> | $Enums.Gender
    status?: EnumNovelStatusFilter<"Novel"> | $Enums.NovelStatus
    synopsis?: StringFilter<"Novel"> | string
    coverImage?: StringFilter<"Novel"> | string
    wordCount?: IntFilter<"Novel"> | number
    totalChapters?: IntFilter<"Novel"> | number
    publishedAt?: DateTimeNullableFilter<"Novel"> | Date | string | null
    newChapterAt?: DateTimeFilter<"Novel"> | Date | string
    createdAt?: DateTimeFilter<"Novel"> | Date | string
    author?: XOR<AuthorNullableScalarRelationFilter, AuthorWhereInput> | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    genre?: XOR<GenreScalarRelationFilter, GenreWhereInput>
    chapters?: ChapterListRelationFilter
    novelTags?: NovelTagListRelationFilter
    reviews?: ReviewListRelationFilter
    statistics?: NovelStatisticListRelationFilter
    readers?: ReadingListRelationFilter
    favorites?: FavoriteListRelationFilter
    comments?: CommentListRelationFilter
  }, "id" | "title" | "createdById">

  export type NovelOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    originalTitle?: SortOrderInput | SortOrder
    authorId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    genreId?: SortOrder
    kind?: SortOrder
    gender?: SortOrder
    status?: SortOrder
    synopsis?: SortOrder
    coverImage?: SortOrder
    wordCount?: SortOrder
    totalChapters?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    newChapterAt?: SortOrder
    createdAt?: SortOrder
    _count?: NovelCountOrderByAggregateInput
    _avg?: NovelAvgOrderByAggregateInput
    _max?: NovelMaxOrderByAggregateInput
    _min?: NovelMinOrderByAggregateInput
    _sum?: NovelSumOrderByAggregateInput
  }

  export type NovelScalarWhereWithAggregatesInput = {
    AND?: NovelScalarWhereWithAggregatesInput | NovelScalarWhereWithAggregatesInput[]
    OR?: NovelScalarWhereWithAggregatesInput[]
    NOT?: NovelScalarWhereWithAggregatesInput | NovelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Novel"> | number
    title?: StringWithAggregatesFilter<"Novel"> | string
    originalTitle?: StringNullableWithAggregatesFilter<"Novel"> | string | null
    authorId?: IntNullableWithAggregatesFilter<"Novel"> | number | null
    createdById?: IntWithAggregatesFilter<"Novel"> | number
    genreId?: IntWithAggregatesFilter<"Novel"> | number
    kind?: EnumNovelKindWithAggregatesFilter<"Novel"> | $Enums.NovelKind
    gender?: EnumGenderWithAggregatesFilter<"Novel"> | $Enums.Gender
    status?: EnumNovelStatusWithAggregatesFilter<"Novel"> | $Enums.NovelStatus
    synopsis?: StringWithAggregatesFilter<"Novel"> | string
    coverImage?: StringWithAggregatesFilter<"Novel"> | string
    wordCount?: IntWithAggregatesFilter<"Novel"> | number
    totalChapters?: IntWithAggregatesFilter<"Novel"> | number
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Novel"> | Date | string | null
    newChapterAt?: DateTimeWithAggregatesFilter<"Novel"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Novel"> | Date | string
  }

  export type GenreWhereInput = {
    AND?: GenreWhereInput | GenreWhereInput[]
    OR?: GenreWhereInput[]
    NOT?: GenreWhereInput | GenreWhereInput[]
    id?: IntFilter<"Genre"> | number
    name?: StringFilter<"Genre"> | string
    novels?: NovelListRelationFilter
  }

  export type GenreOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    novels?: NovelOrderByRelationAggregateInput
  }

  export type GenreWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: GenreWhereInput | GenreWhereInput[]
    OR?: GenreWhereInput[]
    NOT?: GenreWhereInput | GenreWhereInput[]
    novels?: NovelListRelationFilter
  }, "id" | "name">

  export type GenreOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: GenreCountOrderByAggregateInput
    _avg?: GenreAvgOrderByAggregateInput
    _max?: GenreMaxOrderByAggregateInput
    _min?: GenreMinOrderByAggregateInput
    _sum?: GenreSumOrderByAggregateInput
  }

  export type GenreScalarWhereWithAggregatesInput = {
    AND?: GenreScalarWhereWithAggregatesInput | GenreScalarWhereWithAggregatesInput[]
    OR?: GenreScalarWhereWithAggregatesInput[]
    NOT?: GenreScalarWhereWithAggregatesInput | GenreScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Genre"> | number
    name?: StringWithAggregatesFilter<"Genre"> | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: IntFilter<"Tag"> | number
    name?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    tagGroupId?: IntFilter<"Tag"> | number
    tagGroup?: XOR<TagGroupScalarRelationFilter, TagGroupWhereInput>
    novels?: NovelTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    tagGroupId?: SortOrder
    tagGroup?: TagGroupOrderByWithRelationInput
    novels?: NovelTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    description?: StringNullableFilter<"Tag"> | string | null
    tagGroupId?: IntFilter<"Tag"> | number
    tagGroup?: XOR<TagGroupScalarRelationFilter, TagGroupWhereInput>
    novels?: NovelTagListRelationFilter
  }, "id" | "name">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    tagGroupId?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _avg?: TagAvgOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
    _sum?: TagSumOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tag"> | number
    name?: StringWithAggregatesFilter<"Tag"> | string
    description?: StringNullableWithAggregatesFilter<"Tag"> | string | null
    tagGroupId?: IntWithAggregatesFilter<"Tag"> | number
  }

  export type TagGroupWhereInput = {
    AND?: TagGroupWhereInput | TagGroupWhereInput[]
    OR?: TagGroupWhereInput[]
    NOT?: TagGroupWhereInput | TagGroupWhereInput[]
    id?: IntFilter<"TagGroup"> | number
    name?: StringFilter<"TagGroup"> | string
    color?: StringFilter<"TagGroup"> | string
    tags?: TagListRelationFilter
  }

  export type TagGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    tags?: TagOrderByRelationAggregateInput
  }

  export type TagGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: TagGroupWhereInput | TagGroupWhereInput[]
    OR?: TagGroupWhereInput[]
    NOT?: TagGroupWhereInput | TagGroupWhereInput[]
    color?: StringFilter<"TagGroup"> | string
    tags?: TagListRelationFilter
  }, "id" | "name">

  export type TagGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
    _count?: TagGroupCountOrderByAggregateInput
    _avg?: TagGroupAvgOrderByAggregateInput
    _max?: TagGroupMaxOrderByAggregateInput
    _min?: TagGroupMinOrderByAggregateInput
    _sum?: TagGroupSumOrderByAggregateInput
  }

  export type TagGroupScalarWhereWithAggregatesInput = {
    AND?: TagGroupScalarWhereWithAggregatesInput | TagGroupScalarWhereWithAggregatesInput[]
    OR?: TagGroupScalarWhereWithAggregatesInput[]
    NOT?: TagGroupScalarWhereWithAggregatesInput | TagGroupScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TagGroup"> | number
    name?: StringWithAggregatesFilter<"TagGroup"> | string
    color?: StringWithAggregatesFilter<"TagGroup"> | string
  }

  export type NovelTagWhereInput = {
    AND?: NovelTagWhereInput | NovelTagWhereInput[]
    OR?: NovelTagWhereInput[]
    NOT?: NovelTagWhereInput | NovelTagWhereInput[]
    novelId?: IntFilter<"NovelTag"> | number
    tagId?: IntFilter<"NovelTag"> | number
    novel?: XOR<NovelScalarRelationFilter, NovelWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type NovelTagOrderByWithRelationInput = {
    novelId?: SortOrder
    tagId?: SortOrder
    novel?: NovelOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type NovelTagWhereUniqueInput = Prisma.AtLeast<{
    novelId_tagId?: NovelTagNovelIdTagIdCompoundUniqueInput
    AND?: NovelTagWhereInput | NovelTagWhereInput[]
    OR?: NovelTagWhereInput[]
    NOT?: NovelTagWhereInput | NovelTagWhereInput[]
    novelId?: IntFilter<"NovelTag"> | number
    tagId?: IntFilter<"NovelTag"> | number
    novel?: XOR<NovelScalarRelationFilter, NovelWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "novelId_tagId">

  export type NovelTagOrderByWithAggregationInput = {
    novelId?: SortOrder
    tagId?: SortOrder
    _count?: NovelTagCountOrderByAggregateInput
    _avg?: NovelTagAvgOrderByAggregateInput
    _max?: NovelTagMaxOrderByAggregateInput
    _min?: NovelTagMinOrderByAggregateInput
    _sum?: NovelTagSumOrderByAggregateInput
  }

  export type NovelTagScalarWhereWithAggregatesInput = {
    AND?: NovelTagScalarWhereWithAggregatesInput | NovelTagScalarWhereWithAggregatesInput[]
    OR?: NovelTagScalarWhereWithAggregatesInput[]
    NOT?: NovelTagScalarWhereWithAggregatesInput | NovelTagScalarWhereWithAggregatesInput[]
    novelId?: IntWithAggregatesFilter<"NovelTag"> | number
    tagId?: IntWithAggregatesFilter<"NovelTag"> | number
  }

  export type ChapterWhereInput = {
    AND?: ChapterWhereInput | ChapterWhereInput[]
    OR?: ChapterWhereInput[]
    NOT?: ChapterWhereInput | ChapterWhereInput[]
    id?: IntFilter<"Chapter"> | number
    novelId?: IntFilter<"Chapter"> | number
    chapterNumber?: IntFilter<"Chapter"> | number
    title?: StringFilter<"Chapter"> | string
    content?: StringFilter<"Chapter"> | string
    isLocked?: BoolFilter<"Chapter"> | boolean
    unlockCost?: IntFilter<"Chapter"> | number
    publishedAt?: DateTimeFilter<"Chapter"> | Date | string
    createdAt?: DateTimeFilter<"Chapter"> | Date | string
    updatedAt?: DateTimeFilter<"Chapter"> | Date | string
    novel?: XOR<NovelScalarRelationFilter, NovelWhereInput>
    comments?: CommentListRelationFilter
    statistics?: ChapterStatisticListRelationFilter
    reading?: ReadingListRelationFilter
  }

  export type ChapterOrderByWithRelationInput = {
    id?: SortOrder
    novelId?: SortOrder
    chapterNumber?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isLocked?: SortOrder
    unlockCost?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    novel?: NovelOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
    statistics?: ChapterStatisticOrderByRelationAggregateInput
    reading?: ReadingOrderByRelationAggregateInput
  }

  export type ChapterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    novelId_chapterNumber?: ChapterNovelIdChapterNumberCompoundUniqueInput
    AND?: ChapterWhereInput | ChapterWhereInput[]
    OR?: ChapterWhereInput[]
    NOT?: ChapterWhereInput | ChapterWhereInput[]
    novelId?: IntFilter<"Chapter"> | number
    chapterNumber?: IntFilter<"Chapter"> | number
    title?: StringFilter<"Chapter"> | string
    content?: StringFilter<"Chapter"> | string
    isLocked?: BoolFilter<"Chapter"> | boolean
    unlockCost?: IntFilter<"Chapter"> | number
    publishedAt?: DateTimeFilter<"Chapter"> | Date | string
    createdAt?: DateTimeFilter<"Chapter"> | Date | string
    updatedAt?: DateTimeFilter<"Chapter"> | Date | string
    novel?: XOR<NovelScalarRelationFilter, NovelWhereInput>
    comments?: CommentListRelationFilter
    statistics?: ChapterStatisticListRelationFilter
    reading?: ReadingListRelationFilter
  }, "id" | "novelId_chapterNumber">

  export type ChapterOrderByWithAggregationInput = {
    id?: SortOrder
    novelId?: SortOrder
    chapterNumber?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isLocked?: SortOrder
    unlockCost?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChapterCountOrderByAggregateInput
    _avg?: ChapterAvgOrderByAggregateInput
    _max?: ChapterMaxOrderByAggregateInput
    _min?: ChapterMinOrderByAggregateInput
    _sum?: ChapterSumOrderByAggregateInput
  }

  export type ChapterScalarWhereWithAggregatesInput = {
    AND?: ChapterScalarWhereWithAggregatesInput | ChapterScalarWhereWithAggregatesInput[]
    OR?: ChapterScalarWhereWithAggregatesInput[]
    NOT?: ChapterScalarWhereWithAggregatesInput | ChapterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Chapter"> | number
    novelId?: IntWithAggregatesFilter<"Chapter"> | number
    chapterNumber?: IntWithAggregatesFilter<"Chapter"> | number
    title?: StringWithAggregatesFilter<"Chapter"> | string
    content?: StringWithAggregatesFilter<"Chapter"> | string
    isLocked?: BoolWithAggregatesFilter<"Chapter"> | boolean
    unlockCost?: IntWithAggregatesFilter<"Chapter"> | number
    publishedAt?: DateTimeWithAggregatesFilter<"Chapter"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Chapter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Chapter"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: IntFilter<"Review"> | number
    rating?: FloatFilter<"Review"> | number
    content?: StringFilter<"Review"> | string
    isSpoiler?: BoolFilter<"Review"> | boolean
    userId?: IntFilter<"Review"> | number
    novelId?: IntFilter<"Review"> | number
    createdAt?: DateTimeFilter<"Review"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    novel?: XOR<NovelScalarRelationFilter, NovelWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    rating?: SortOrder
    content?: SortOrder
    isSpoiler?: SortOrder
    userId?: SortOrder
    novelId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    novel?: NovelOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_novelId?: ReviewUserIdNovelIdCompoundUniqueInput
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    rating?: FloatFilter<"Review"> | number
    content?: StringFilter<"Review"> | string
    isSpoiler?: BoolFilter<"Review"> | boolean
    userId?: IntFilter<"Review"> | number
    novelId?: IntFilter<"Review"> | number
    createdAt?: DateTimeFilter<"Review"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    novel?: XOR<NovelScalarRelationFilter, NovelWhereInput>
  }, "id" | "userId_novelId">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    rating?: SortOrder
    content?: SortOrder
    isSpoiler?: SortOrder
    userId?: SortOrder
    novelId?: SortOrder
    createdAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Review"> | number
    rating?: FloatWithAggregatesFilter<"Review"> | number
    content?: StringWithAggregatesFilter<"Review"> | string
    isSpoiler?: BoolWithAggregatesFilter<"Review"> | boolean
    userId?: IntWithAggregatesFilter<"Review"> | number
    novelId?: IntWithAggregatesFilter<"Review"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: IntFilter<"Comment"> | number
    content?: StringFilter<"Comment"> | string
    likes?: IntFilter<"Comment"> | number
    userId?: IntFilter<"Comment"> | number
    chapterId?: IntFilter<"Comment"> | number
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    novelId?: IntNullableFilter<"Comment"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    chapter?: XOR<ChapterScalarRelationFilter, ChapterWhereInput>
    replies?: ReplyCommentListRelationFilter
    Novel?: XOR<NovelNullableScalarRelationFilter, NovelWhereInput> | null
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    likes?: SortOrder
    userId?: SortOrder
    chapterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    novelId?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    chapter?: ChapterOrderByWithRelationInput
    replies?: ReplyCommentOrderByRelationAggregateInput
    Novel?: NovelOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    content?: StringFilter<"Comment"> | string
    likes?: IntFilter<"Comment"> | number
    userId?: IntFilter<"Comment"> | number
    chapterId?: IntFilter<"Comment"> | number
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    novelId?: IntNullableFilter<"Comment"> | number | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    chapter?: XOR<ChapterScalarRelationFilter, ChapterWhereInput>
    replies?: ReplyCommentListRelationFilter
    Novel?: XOR<NovelNullableScalarRelationFilter, NovelWhereInput> | null
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    likes?: SortOrder
    userId?: SortOrder
    chapterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    novelId?: SortOrderInput | SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comment"> | number
    content?: StringWithAggregatesFilter<"Comment"> | string
    likes?: IntWithAggregatesFilter<"Comment"> | number
    userId?: IntWithAggregatesFilter<"Comment"> | number
    chapterId?: IntWithAggregatesFilter<"Comment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    novelId?: IntNullableWithAggregatesFilter<"Comment"> | number | null
  }

  export type ReplyCommentWhereInput = {
    AND?: ReplyCommentWhereInput | ReplyCommentWhereInput[]
    OR?: ReplyCommentWhereInput[]
    NOT?: ReplyCommentWhereInput | ReplyCommentWhereInput[]
    id?: IntFilter<"ReplyComment"> | number
    content?: StringFilter<"ReplyComment"> | string
    likes?: IntFilter<"ReplyComment"> | number
    userId?: IntFilter<"ReplyComment"> | number
    commentId?: IntFilter<"ReplyComment"> | number
    createdAt?: DateTimeFilter<"ReplyComment"> | Date | string
    updatedAt?: DateTimeFilter<"ReplyComment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
  }

  export type ReplyCommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    likes?: SortOrder
    userId?: SortOrder
    commentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    comment?: CommentOrderByWithRelationInput
  }

  export type ReplyCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReplyCommentWhereInput | ReplyCommentWhereInput[]
    OR?: ReplyCommentWhereInput[]
    NOT?: ReplyCommentWhereInput | ReplyCommentWhereInput[]
    content?: StringFilter<"ReplyComment"> | string
    likes?: IntFilter<"ReplyComment"> | number
    userId?: IntFilter<"ReplyComment"> | number
    commentId?: IntFilter<"ReplyComment"> | number
    createdAt?: DateTimeFilter<"ReplyComment"> | Date | string
    updatedAt?: DateTimeFilter<"ReplyComment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
  }, "id">

  export type ReplyCommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    likes?: SortOrder
    userId?: SortOrder
    commentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReplyCommentCountOrderByAggregateInput
    _avg?: ReplyCommentAvgOrderByAggregateInput
    _max?: ReplyCommentMaxOrderByAggregateInput
    _min?: ReplyCommentMinOrderByAggregateInput
    _sum?: ReplyCommentSumOrderByAggregateInput
  }

  export type ReplyCommentScalarWhereWithAggregatesInput = {
    AND?: ReplyCommentScalarWhereWithAggregatesInput | ReplyCommentScalarWhereWithAggregatesInput[]
    OR?: ReplyCommentScalarWhereWithAggregatesInput[]
    NOT?: ReplyCommentScalarWhereWithAggregatesInput | ReplyCommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ReplyComment"> | number
    content?: StringWithAggregatesFilter<"ReplyComment"> | string
    likes?: IntWithAggregatesFilter<"ReplyComment"> | number
    userId?: IntWithAggregatesFilter<"ReplyComment"> | number
    commentId?: IntWithAggregatesFilter<"ReplyComment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ReplyComment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReplyComment"> | Date | string
  }

  export type ReadingWhereInput = {
    AND?: ReadingWhereInput | ReadingWhereInput[]
    OR?: ReadingWhereInput[]
    NOT?: ReadingWhereInput | ReadingWhereInput[]
    userId?: IntFilter<"Reading"> | number
    novelId?: IntFilter<"Reading"> | number
    chapterId?: IntFilter<"Reading"> | number
    lastRead?: DateTimeFilter<"Reading"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    novel?: XOR<NovelScalarRelationFilter, NovelWhereInput>
    chapter?: XOR<ChapterScalarRelationFilter, ChapterWhereInput>
  }

  export type ReadingOrderByWithRelationInput = {
    userId?: SortOrder
    novelId?: SortOrder
    chapterId?: SortOrder
    lastRead?: SortOrder
    user?: UserOrderByWithRelationInput
    novel?: NovelOrderByWithRelationInput
    chapter?: ChapterOrderByWithRelationInput
  }

  export type ReadingWhereUniqueInput = Prisma.AtLeast<{
    userId_novelId?: ReadingUserIdNovelIdCompoundUniqueInput
    AND?: ReadingWhereInput | ReadingWhereInput[]
    OR?: ReadingWhereInput[]
    NOT?: ReadingWhereInput | ReadingWhereInput[]
    userId?: IntFilter<"Reading"> | number
    novelId?: IntFilter<"Reading"> | number
    chapterId?: IntFilter<"Reading"> | number
    lastRead?: DateTimeFilter<"Reading"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    novel?: XOR<NovelScalarRelationFilter, NovelWhereInput>
    chapter?: XOR<ChapterScalarRelationFilter, ChapterWhereInput>
  }, "userId_novelId">

  export type ReadingOrderByWithAggregationInput = {
    userId?: SortOrder
    novelId?: SortOrder
    chapterId?: SortOrder
    lastRead?: SortOrder
    _count?: ReadingCountOrderByAggregateInput
    _avg?: ReadingAvgOrderByAggregateInput
    _max?: ReadingMaxOrderByAggregateInput
    _min?: ReadingMinOrderByAggregateInput
    _sum?: ReadingSumOrderByAggregateInput
  }

  export type ReadingScalarWhereWithAggregatesInput = {
    AND?: ReadingScalarWhereWithAggregatesInput | ReadingScalarWhereWithAggregatesInput[]
    OR?: ReadingScalarWhereWithAggregatesInput[]
    NOT?: ReadingScalarWhereWithAggregatesInput | ReadingScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"Reading"> | number
    novelId?: IntWithAggregatesFilter<"Reading"> | number
    chapterId?: IntWithAggregatesFilter<"Reading"> | number
    lastRead?: DateTimeWithAggregatesFilter<"Reading"> | Date | string
  }

  export type FavoriteWhereInput = {
    AND?: FavoriteWhereInput | FavoriteWhereInput[]
    OR?: FavoriteWhereInput[]
    NOT?: FavoriteWhereInput | FavoriteWhereInput[]
    userId?: IntFilter<"Favorite"> | number
    novelId?: IntFilter<"Favorite"> | number
    createdAt?: DateTimeFilter<"Favorite"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    novel?: XOR<NovelScalarRelationFilter, NovelWhereInput>
  }

  export type FavoriteOrderByWithRelationInput = {
    userId?: SortOrder
    novelId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    novel?: NovelOrderByWithRelationInput
  }

  export type FavoriteWhereUniqueInput = Prisma.AtLeast<{
    userId_novelId?: FavoriteUserIdNovelIdCompoundUniqueInput
    AND?: FavoriteWhereInput | FavoriteWhereInput[]
    OR?: FavoriteWhereInput[]
    NOT?: FavoriteWhereInput | FavoriteWhereInput[]
    userId?: IntFilter<"Favorite"> | number
    novelId?: IntFilter<"Favorite"> | number
    createdAt?: DateTimeFilter<"Favorite"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    novel?: XOR<NovelScalarRelationFilter, NovelWhereInput>
  }, "userId_novelId">

  export type FavoriteOrderByWithAggregationInput = {
    userId?: SortOrder
    novelId?: SortOrder
    createdAt?: SortOrder
    _count?: FavoriteCountOrderByAggregateInput
    _avg?: FavoriteAvgOrderByAggregateInput
    _max?: FavoriteMaxOrderByAggregateInput
    _min?: FavoriteMinOrderByAggregateInput
    _sum?: FavoriteSumOrderByAggregateInput
  }

  export type FavoriteScalarWhereWithAggregatesInput = {
    AND?: FavoriteScalarWhereWithAggregatesInput | FavoriteScalarWhereWithAggregatesInput[]
    OR?: FavoriteScalarWhereWithAggregatesInput[]
    NOT?: FavoriteScalarWhereWithAggregatesInput | FavoriteScalarWhereWithAggregatesInput[]
    userId?: IntWithAggregatesFilter<"Favorite"> | number
    novelId?: IntWithAggregatesFilter<"Favorite"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Favorite"> | Date | string
  }

  export type NovelStatisticWhereInput = {
    AND?: NovelStatisticWhereInput | NovelStatisticWhereInput[]
    OR?: NovelStatisticWhereInput[]
    NOT?: NovelStatisticWhereInput | NovelStatisticWhereInput[]
    id?: IntFilter<"NovelStatistic"> | number
    novelId?: IntFilter<"NovelStatistic"> | number
    dailyViews?: IntFilter<"NovelStatistic"> | number
    totalViews?: IntFilter<"NovelStatistic"> | number
    reviews?: IntFilter<"NovelStatistic"> | number
    comments?: IntFilter<"NovelStatistic"> | number
    date?: DateTimeFilter<"NovelStatistic"> | Date | string
    novel?: XOR<NovelScalarRelationFilter, NovelWhereInput>
  }

  export type NovelStatisticOrderByWithRelationInput = {
    id?: SortOrder
    novelId?: SortOrder
    dailyViews?: SortOrder
    totalViews?: SortOrder
    reviews?: SortOrder
    comments?: SortOrder
    date?: SortOrder
    novel?: NovelOrderByWithRelationInput
  }

  export type NovelStatisticWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    novelId_date?: NovelStatisticNovelIdDateCompoundUniqueInput
    AND?: NovelStatisticWhereInput | NovelStatisticWhereInput[]
    OR?: NovelStatisticWhereInput[]
    NOT?: NovelStatisticWhereInput | NovelStatisticWhereInput[]
    novelId?: IntFilter<"NovelStatistic"> | number
    dailyViews?: IntFilter<"NovelStatistic"> | number
    totalViews?: IntFilter<"NovelStatistic"> | number
    reviews?: IntFilter<"NovelStatistic"> | number
    comments?: IntFilter<"NovelStatistic"> | number
    date?: DateTimeFilter<"NovelStatistic"> | Date | string
    novel?: XOR<NovelScalarRelationFilter, NovelWhereInput>
  }, "id" | "novelId_date">

  export type NovelStatisticOrderByWithAggregationInput = {
    id?: SortOrder
    novelId?: SortOrder
    dailyViews?: SortOrder
    totalViews?: SortOrder
    reviews?: SortOrder
    comments?: SortOrder
    date?: SortOrder
    _count?: NovelStatisticCountOrderByAggregateInput
    _avg?: NovelStatisticAvgOrderByAggregateInput
    _max?: NovelStatisticMaxOrderByAggregateInput
    _min?: NovelStatisticMinOrderByAggregateInput
    _sum?: NovelStatisticSumOrderByAggregateInput
  }

  export type NovelStatisticScalarWhereWithAggregatesInput = {
    AND?: NovelStatisticScalarWhereWithAggregatesInput | NovelStatisticScalarWhereWithAggregatesInput[]
    OR?: NovelStatisticScalarWhereWithAggregatesInput[]
    NOT?: NovelStatisticScalarWhereWithAggregatesInput | NovelStatisticScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NovelStatistic"> | number
    novelId?: IntWithAggregatesFilter<"NovelStatistic"> | number
    dailyViews?: IntWithAggregatesFilter<"NovelStatistic"> | number
    totalViews?: IntWithAggregatesFilter<"NovelStatistic"> | number
    reviews?: IntWithAggregatesFilter<"NovelStatistic"> | number
    comments?: IntWithAggregatesFilter<"NovelStatistic"> | number
    date?: DateTimeWithAggregatesFilter<"NovelStatistic"> | Date | string
  }

  export type ChapterStatisticWhereInput = {
    AND?: ChapterStatisticWhereInput | ChapterStatisticWhereInput[]
    OR?: ChapterStatisticWhereInput[]
    NOT?: ChapterStatisticWhereInput | ChapterStatisticWhereInput[]
    id?: IntFilter<"ChapterStatistic"> | number
    chapterId?: IntFilter<"ChapterStatistic"> | number
    views?: IntFilter<"ChapterStatistic"> | number
    date?: DateTimeFilter<"ChapterStatistic"> | Date | string
    chapter?: XOR<ChapterScalarRelationFilter, ChapterWhereInput>
  }

  export type ChapterStatisticOrderByWithRelationInput = {
    id?: SortOrder
    chapterId?: SortOrder
    views?: SortOrder
    date?: SortOrder
    chapter?: ChapterOrderByWithRelationInput
  }

  export type ChapterStatisticWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    chapterId_date?: ChapterStatisticChapterIdDateCompoundUniqueInput
    AND?: ChapterStatisticWhereInput | ChapterStatisticWhereInput[]
    OR?: ChapterStatisticWhereInput[]
    NOT?: ChapterStatisticWhereInput | ChapterStatisticWhereInput[]
    chapterId?: IntFilter<"ChapterStatistic"> | number
    views?: IntFilter<"ChapterStatistic"> | number
    date?: DateTimeFilter<"ChapterStatistic"> | Date | string
    chapter?: XOR<ChapterScalarRelationFilter, ChapterWhereInput>
  }, "id" | "chapterId_date">

  export type ChapterStatisticOrderByWithAggregationInput = {
    id?: SortOrder
    chapterId?: SortOrder
    views?: SortOrder
    date?: SortOrder
    _count?: ChapterStatisticCountOrderByAggregateInput
    _avg?: ChapterStatisticAvgOrderByAggregateInput
    _max?: ChapterStatisticMaxOrderByAggregateInput
    _min?: ChapterStatisticMinOrderByAggregateInput
    _sum?: ChapterStatisticSumOrderByAggregateInput
  }

  export type ChapterStatisticScalarWhereWithAggregatesInput = {
    AND?: ChapterStatisticScalarWhereWithAggregatesInput | ChapterStatisticScalarWhereWithAggregatesInput[]
    OR?: ChapterStatisticScalarWhereWithAggregatesInput[]
    NOT?: ChapterStatisticScalarWhereWithAggregatesInput | ChapterStatisticScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ChapterStatistic"> | number
    chapterId?: IntWithAggregatesFilter<"ChapterStatistic"> | number
    views?: IntWithAggregatesFilter<"ChapterStatistic"> | number
    date?: DateTimeWithAggregatesFilter<"ChapterStatistic"> | Date | string
  }

  export type UserCreateInput = {
    nickname: string
    email: string
    password?: string | null
    phone?: string
    avatar?: string
    coverImage?: string
    role?: $Enums.UserRole
    gender?: $Enums.Gender
    bio?: string
    birthDate?: Date | string
    socialLinks?: UserCreatesocialLinksInput | string[]
    keys?: number
    tickets?: number
    candies?: number
    createdAt?: Date | string
    emailVerifiedAt?: Date | string | null
    isTwoFactorAuth?: boolean
    notifications?: NotificationSettingsCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    authoredNovels?: NovelCreateNestedManyWithoutCreatedByInput
    sessions?: RefreshTokenCreateNestedManyWithoutUserInput
    readings?: ReadingCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    replies?: ReplyCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    nickname: string
    email: string
    password?: string | null
    phone?: string
    avatar?: string
    coverImage?: string
    role?: $Enums.UserRole
    gender?: $Enums.Gender
    bio?: string
    birthDate?: Date | string
    socialLinks?: UserCreatesocialLinksInput | string[]
    keys?: number
    tickets?: number
    candies?: number
    createdAt?: Date | string
    emailVerifiedAt?: Date | string | null
    isTwoFactorAuth?: boolean
    notifications?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    authoredNovels?: NovelUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    readings?: ReadingUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    bio?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: UserUpdatesocialLinksInput | string[]
    keys?: IntFieldUpdateOperationsInput | number
    tickets?: IntFieldUpdateOperationsInput | number
    candies?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTwoFactorAuth?: BoolFieldUpdateOperationsInput | boolean
    notifications?: NotificationSettingsUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    authoredNovels?: NovelUpdateManyWithoutCreatedByNestedInput
    sessions?: RefreshTokenUpdateManyWithoutUserNestedInput
    readings?: ReadingUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    replies?: ReplyCommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    bio?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: UserUpdatesocialLinksInput | string[]
    keys?: IntFieldUpdateOperationsInput | number
    tickets?: IntFieldUpdateOperationsInput | number
    candies?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTwoFactorAuth?: BoolFieldUpdateOperationsInput | boolean
    notifications?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    authoredNovels?: NovelUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    readings?: ReadingUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    nickname: string
    email: string
    password?: string | null
    phone?: string
    avatar?: string
    coverImage?: string
    role?: $Enums.UserRole
    gender?: $Enums.Gender
    bio?: string
    birthDate?: Date | string
    socialLinks?: UserCreatesocialLinksInput | string[]
    keys?: number
    tickets?: number
    candies?: number
    createdAt?: Date | string
    emailVerifiedAt?: Date | string | null
    isTwoFactorAuth?: boolean
  }

  export type UserUpdateManyMutationInput = {
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    bio?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: UserUpdatesocialLinksInput | string[]
    keys?: IntFieldUpdateOperationsInput | number
    tickets?: IntFieldUpdateOperationsInput | number
    candies?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTwoFactorAuth?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    bio?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: UserUpdatesocialLinksInput | string[]
    keys?: IntFieldUpdateOperationsInput | number
    tickets?: IntFieldUpdateOperationsInput | number
    candies?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTwoFactorAuth?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RefreshTokenCreateInput = {
    token?: string
    expiresAt: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    token?: string
    userId: number
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    token?: string
    userId: number
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    token?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSettingsCreateInput = {
    enableNewChapter?: boolean
    enableInteractions?: boolean
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationSettingsUncheckedCreateInput = {
    userId: number
    enableNewChapter?: boolean
    enableInteractions?: boolean
  }

  export type NotificationSettingsUpdateInput = {
    enableNewChapter?: BoolFieldUpdateOperationsInput | boolean
    enableInteractions?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationSettingsUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    enableNewChapter?: BoolFieldUpdateOperationsInput | boolean
    enableInteractions?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationSettingsCreateManyInput = {
    userId: number
    enableNewChapter?: boolean
    enableInteractions?: boolean
  }

  export type NotificationSettingsUpdateManyMutationInput = {
    enableNewChapter?: BoolFieldUpdateOperationsInput | boolean
    enableInteractions?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationSettingsUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    enableNewChapter?: BoolFieldUpdateOperationsInput | boolean
    enableInteractions?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuthorCreateInput = {
    name: string
    originalName: string
    country: string
    novels?: NovelCreateNestedManyWithoutAuthorInput
  }

  export type AuthorUncheckedCreateInput = {
    id?: number
    name: string
    originalName: string
    country: string
    novels?: NovelUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type AuthorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    novels?: NovelUpdateManyWithoutAuthorNestedInput
  }

  export type AuthorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    novels?: NovelUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type AuthorCreateManyInput = {
    id?: number
    name: string
    originalName: string
    country: string
  }

  export type AuthorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
  }

  export type AuthorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
  }

  export type NovelCreateInput = {
    title: string
    originalTitle?: string | null
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status?: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount?: number
    totalChapters?: number
    publishedAt?: Date | string | null
    newChapterAt?: Date | string
    createdAt?: Date | string
    author?: AuthorCreateNestedOneWithoutNovelsInput
    createdBy: UserCreateNestedOneWithoutAuthoredNovelsInput
    genre: GenreCreateNestedOneWithoutNovelsInput
    chapters?: ChapterCreateNestedManyWithoutNovelInput
    novelTags?: NovelTagCreateNestedManyWithoutNovelInput
    reviews?: ReviewCreateNestedManyWithoutNovelInput
    statistics?: NovelStatisticCreateNestedManyWithoutNovelInput
    readers?: ReadingCreateNestedManyWithoutNovelInput
    favorites?: FavoriteCreateNestedManyWithoutNovelInput
    comments?: CommentCreateNestedManyWithoutNovelInput
  }

  export type NovelUncheckedCreateInput = {
    id?: number
    title: string
    originalTitle?: string | null
    authorId?: number | null
    createdById: number
    genreId: number
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status?: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount?: number
    totalChapters?: number
    publishedAt?: Date | string | null
    newChapterAt?: Date | string
    createdAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutNovelInput
    novelTags?: NovelTagUncheckedCreateNestedManyWithoutNovelInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutNovelInput
    statistics?: NovelStatisticUncheckedCreateNestedManyWithoutNovelInput
    readers?: ReadingUncheckedCreateNestedManyWithoutNovelInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutNovelInput
    comments?: CommentUncheckedCreateNestedManyWithoutNovelInput
  }

  export type NovelUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AuthorUpdateOneWithoutNovelsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutAuthoredNovelsNestedInput
    genre?: GenreUpdateOneRequiredWithoutNovelsNestedInput
    chapters?: ChapterUpdateManyWithoutNovelNestedInput
    novelTags?: NovelTagUpdateManyWithoutNovelNestedInput
    reviews?: ReviewUpdateManyWithoutNovelNestedInput
    statistics?: NovelStatisticUpdateManyWithoutNovelNestedInput
    readers?: ReadingUpdateManyWithoutNovelNestedInput
    favorites?: FavoriteUpdateManyWithoutNovelNestedInput
    comments?: CommentUpdateManyWithoutNovelNestedInput
  }

  export type NovelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    genreId?: IntFieldUpdateOperationsInput | number
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutNovelNestedInput
    novelTags?: NovelTagUncheckedUpdateManyWithoutNovelNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutNovelNestedInput
    statistics?: NovelStatisticUncheckedUpdateManyWithoutNovelNestedInput
    readers?: ReadingUncheckedUpdateManyWithoutNovelNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutNovelNestedInput
    comments?: CommentUncheckedUpdateManyWithoutNovelNestedInput
  }

  export type NovelCreateManyInput = {
    id?: number
    title: string
    originalTitle?: string | null
    authorId?: number | null
    createdById: number
    genreId: number
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status?: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount?: number
    totalChapters?: number
    publishedAt?: Date | string | null
    newChapterAt?: Date | string
    createdAt?: Date | string
  }

  export type NovelUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NovelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    genreId?: IntFieldUpdateOperationsInput | number
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GenreCreateInput = {
    name: string
    novels?: NovelCreateNestedManyWithoutGenreInput
  }

  export type GenreUncheckedCreateInput = {
    id?: number
    name: string
    novels?: NovelUncheckedCreateNestedManyWithoutGenreInput
  }

  export type GenreUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    novels?: NovelUpdateManyWithoutGenreNestedInput
  }

  export type GenreUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    novels?: NovelUncheckedUpdateManyWithoutGenreNestedInput
  }

  export type GenreCreateManyInput = {
    id?: number
    name: string
  }

  export type GenreUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GenreUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TagCreateInput = {
    name: string
    description?: string | null
    tagGroup: TagGroupCreateNestedOneWithoutTagsInput
    novels?: NovelTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    tagGroupId: number
    novels?: NovelTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tagGroup?: TagGroupUpdateOneRequiredWithoutTagsNestedInput
    novels?: NovelTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tagGroupId?: IntFieldUpdateOperationsInput | number
    novels?: NovelTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    tagGroupId: number
  }

  export type TagUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tagGroupId?: IntFieldUpdateOperationsInput | number
  }

  export type TagGroupCreateInput = {
    name: string
    color: string
    tags?: TagCreateNestedManyWithoutTagGroupInput
  }

  export type TagGroupUncheckedCreateInput = {
    id?: number
    name: string
    color: string
    tags?: TagUncheckedCreateNestedManyWithoutTagGroupInput
  }

  export type TagGroupUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    tags?: TagUpdateManyWithoutTagGroupNestedInput
  }

  export type TagGroupUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
    tags?: TagUncheckedUpdateManyWithoutTagGroupNestedInput
  }

  export type TagGroupCreateManyInput = {
    id?: number
    name: string
    color: string
  }

  export type TagGroupUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type TagGroupUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type NovelTagCreateInput = {
    novel: NovelCreateNestedOneWithoutNovelTagsInput
    tag: TagCreateNestedOneWithoutNovelsInput
  }

  export type NovelTagUncheckedCreateInput = {
    novelId: number
    tagId: number
  }

  export type NovelTagUpdateInput = {
    novel?: NovelUpdateOneRequiredWithoutNovelTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutNovelsNestedInput
  }

  export type NovelTagUncheckedUpdateInput = {
    novelId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type NovelTagCreateManyInput = {
    novelId: number
    tagId: number
  }

  export type NovelTagUpdateManyMutationInput = {

  }

  export type NovelTagUncheckedUpdateManyInput = {
    novelId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type ChapterCreateInput = {
    chapterNumber: number
    title: string
    content: string
    isLocked?: boolean
    unlockCost?: number
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    novel: NovelCreateNestedOneWithoutChaptersInput
    comments?: CommentCreateNestedManyWithoutChapterInput
    statistics?: ChapterStatisticCreateNestedManyWithoutChapterInput
    reading?: ReadingCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateInput = {
    id?: number
    novelId: number
    chapterNumber: number
    title: string
    content: string
    isLocked?: boolean
    unlockCost?: number
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutChapterInput
    statistics?: ChapterStatisticUncheckedCreateNestedManyWithoutChapterInput
    reading?: ReadingUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterUpdateInput = {
    chapterNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    unlockCost?: IntFieldUpdateOperationsInput | number
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    novel?: NovelUpdateOneRequiredWithoutChaptersNestedInput
    comments?: CommentUpdateManyWithoutChapterNestedInput
    statistics?: ChapterStatisticUpdateManyWithoutChapterNestedInput
    reading?: ReadingUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    novelId?: IntFieldUpdateOperationsInput | number
    chapterNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    unlockCost?: IntFieldUpdateOperationsInput | number
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutChapterNestedInput
    statistics?: ChapterStatisticUncheckedUpdateManyWithoutChapterNestedInput
    reading?: ReadingUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type ChapterCreateManyInput = {
    id?: number
    novelId: number
    chapterNumber: number
    title: string
    content: string
    isLocked?: boolean
    unlockCost?: number
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChapterUpdateManyMutationInput = {
    chapterNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    unlockCost?: IntFieldUpdateOperationsInput | number
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    novelId?: IntFieldUpdateOperationsInput | number
    chapterNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    unlockCost?: IntFieldUpdateOperationsInput | number
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    rating: number
    content: string
    isSpoiler?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
    novel: NovelCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: number
    rating: number
    content: string
    isSpoiler?: boolean
    userId: number
    novelId: number
    createdAt?: Date | string
  }

  export type ReviewUpdateInput = {
    rating?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isSpoiler?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    novel?: NovelUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isSpoiler?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    novelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: number
    rating: number
    content: string
    isSpoiler?: boolean
    userId: number
    novelId: number
    createdAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    rating?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isSpoiler?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isSpoiler?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    novelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    content: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    chapter: ChapterCreateNestedOneWithoutCommentsInput
    replies?: ReplyCommentCreateNestedManyWithoutCommentInput
    Novel?: NovelCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: number
    content: string
    likes?: number
    userId: number
    chapterId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    novelId?: number | null
    replies?: ReplyCommentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    chapter?: ChapterUpdateOneRequiredWithoutCommentsNestedInput
    replies?: ReplyCommentUpdateManyWithoutCommentNestedInput
    Novel?: NovelUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    novelId?: NullableIntFieldUpdateOperationsInput | number | null
    replies?: ReplyCommentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: number
    content: string
    likes?: number
    userId: number
    chapterId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    novelId?: number | null
  }

  export type CommentUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    novelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReplyCommentCreateInput = {
    content: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRepliesInput
    comment: CommentCreateNestedOneWithoutRepliesInput
  }

  export type ReplyCommentUncheckedCreateInput = {
    id?: number
    content: string
    likes?: number
    userId: number
    commentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReplyCommentUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRepliesNestedInput
    comment?: CommentUpdateOneRequiredWithoutRepliesNestedInput
  }

  export type ReplyCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReplyCommentCreateManyInput = {
    id?: number
    content: string
    likes?: number
    userId: number
    commentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReplyCommentUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReplyCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadingCreateInput = {
    lastRead?: Date | string
    user: UserCreateNestedOneWithoutReadingsInput
    novel: NovelCreateNestedOneWithoutReadersInput
    chapter: ChapterCreateNestedOneWithoutReadingInput
  }

  export type ReadingUncheckedCreateInput = {
    userId: number
    novelId: number
    chapterId: number
    lastRead?: Date | string
  }

  export type ReadingUpdateInput = {
    lastRead?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReadingsNestedInput
    novel?: NovelUpdateOneRequiredWithoutReadersNestedInput
    chapter?: ChapterUpdateOneRequiredWithoutReadingNestedInput
  }

  export type ReadingUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    novelId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    lastRead?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadingCreateManyInput = {
    userId: number
    novelId: number
    chapterId: number
    lastRead?: Date | string
  }

  export type ReadingUpdateManyMutationInput = {
    lastRead?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadingUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    novelId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    lastRead?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteCreateInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFavoritesInput
    novel: NovelCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteUncheckedCreateInput = {
    userId: number
    novelId: number
    createdAt?: Date | string
  }

  export type FavoriteUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavoritesNestedInput
    novel?: NovelUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteUncheckedUpdateInput = {
    userId?: IntFieldUpdateOperationsInput | number
    novelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteCreateManyInput = {
    userId: number
    novelId: number
    createdAt?: Date | string
  }

  export type FavoriteUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateManyInput = {
    userId?: IntFieldUpdateOperationsInput | number
    novelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NovelStatisticCreateInput = {
    dailyViews?: number
    totalViews?: number
    reviews?: number
    comments?: number
    date: Date | string
    novel: NovelCreateNestedOneWithoutStatisticsInput
  }

  export type NovelStatisticUncheckedCreateInput = {
    id?: number
    novelId: number
    dailyViews?: number
    totalViews?: number
    reviews?: number
    comments?: number
    date: Date | string
  }

  export type NovelStatisticUpdateInput = {
    dailyViews?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    reviews?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    novel?: NovelUpdateOneRequiredWithoutStatisticsNestedInput
  }

  export type NovelStatisticUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    novelId?: IntFieldUpdateOperationsInput | number
    dailyViews?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    reviews?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NovelStatisticCreateManyInput = {
    id?: number
    novelId: number
    dailyViews?: number
    totalViews?: number
    reviews?: number
    comments?: number
    date: Date | string
  }

  export type NovelStatisticUpdateManyMutationInput = {
    dailyViews?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    reviews?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NovelStatisticUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    novelId?: IntFieldUpdateOperationsInput | number
    dailyViews?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    reviews?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterStatisticCreateInput = {
    views?: number
    date: Date | string
    chapter: ChapterCreateNestedOneWithoutStatisticsInput
  }

  export type ChapterStatisticUncheckedCreateInput = {
    id?: number
    chapterId: number
    views?: number
    date: Date | string
  }

  export type ChapterStatisticUpdateInput = {
    views?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneRequiredWithoutStatisticsNestedInput
  }

  export type ChapterStatisticUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterStatisticCreateManyInput = {
    id?: number
    chapterId: number
    views?: number
    date: Date | string
  }

  export type ChapterStatisticUpdateManyMutationInput = {
    views?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterStatisticUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NotificationSettingsNullableScalarRelationFilter = {
    is?: NotificationSettingsWhereInput | null
    isNot?: NotificationSettingsWhereInput | null
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type NovelListRelationFilter = {
    every?: NovelWhereInput
    some?: NovelWhereInput
    none?: NovelWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type ReadingListRelationFilter = {
    every?: ReadingWhereInput
    some?: ReadingWhereInput
    none?: ReadingWhereInput
  }

  export type FavoriteListRelationFilter = {
    every?: FavoriteWhereInput
    some?: FavoriteWhereInput
    none?: FavoriteWhereInput
  }

  export type ReplyCommentListRelationFilter = {
    every?: ReplyCommentWhereInput
    some?: ReplyCommentWhereInput
    none?: ReplyCommentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NovelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReadingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FavoriteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReplyCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    nickname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    coverImage?: SortOrder
    role?: SortOrder
    gender?: SortOrder
    bio?: SortOrder
    birthDate?: SortOrder
    socialLinks?: SortOrder
    keys?: SortOrder
    tickets?: SortOrder
    candies?: SortOrder
    createdAt?: SortOrder
    emailVerifiedAt?: SortOrder
    isTwoFactorAuth?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    keys?: SortOrder
    tickets?: SortOrder
    candies?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    nickname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    coverImage?: SortOrder
    role?: SortOrder
    gender?: SortOrder
    bio?: SortOrder
    birthDate?: SortOrder
    keys?: SortOrder
    tickets?: SortOrder
    candies?: SortOrder
    createdAt?: SortOrder
    emailVerifiedAt?: SortOrder
    isTwoFactorAuth?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    nickname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    phone?: SortOrder
    avatar?: SortOrder
    coverImage?: SortOrder
    role?: SortOrder
    gender?: SortOrder
    bio?: SortOrder
    birthDate?: SortOrder
    keys?: SortOrder
    tickets?: SortOrder
    candies?: SortOrder
    createdAt?: SortOrder
    emailVerifiedAt?: SortOrder
    isTwoFactorAuth?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    keys?: SortOrder
    tickets?: SortOrder
    candies?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NotificationSettingsCountOrderByAggregateInput = {
    userId?: SortOrder
    enableNewChapter?: SortOrder
    enableInteractions?: SortOrder
  }

  export type NotificationSettingsAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type NotificationSettingsMaxOrderByAggregateInput = {
    userId?: SortOrder
    enableNewChapter?: SortOrder
    enableInteractions?: SortOrder
  }

  export type NotificationSettingsMinOrderByAggregateInput = {
    userId?: SortOrder
    enableNewChapter?: SortOrder
    enableInteractions?: SortOrder
  }

  export type NotificationSettingsSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type AuthorNameOriginalNameCompoundUniqueInput = {
    name: string
    originalName: string
  }

  export type AuthorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    originalName?: SortOrder
    country?: SortOrder
  }

  export type AuthorAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AuthorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    originalName?: SortOrder
    country?: SortOrder
  }

  export type AuthorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    originalName?: SortOrder
    country?: SortOrder
  }

  export type AuthorSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumNovelKindFilter<$PrismaModel = never> = {
    equals?: $Enums.NovelKind | EnumNovelKindFieldRefInput<$PrismaModel>
    in?: $Enums.NovelKind[] | ListEnumNovelKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.NovelKind[] | ListEnumNovelKindFieldRefInput<$PrismaModel>
    not?: NestedEnumNovelKindFilter<$PrismaModel> | $Enums.NovelKind
  }

  export type EnumNovelStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NovelStatus | EnumNovelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NovelStatus[] | ListEnumNovelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NovelStatus[] | ListEnumNovelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNovelStatusFilter<$PrismaModel> | $Enums.NovelStatus
  }

  export type AuthorNullableScalarRelationFilter = {
    is?: AuthorWhereInput | null
    isNot?: AuthorWhereInput | null
  }

  export type GenreScalarRelationFilter = {
    is?: GenreWhereInput
    isNot?: GenreWhereInput
  }

  export type ChapterListRelationFilter = {
    every?: ChapterWhereInput
    some?: ChapterWhereInput
    none?: ChapterWhereInput
  }

  export type NovelTagListRelationFilter = {
    every?: NovelTagWhereInput
    some?: NovelTagWhereInput
    none?: NovelTagWhereInput
  }

  export type NovelStatisticListRelationFilter = {
    every?: NovelStatisticWhereInput
    some?: NovelStatisticWhereInput
    none?: NovelStatisticWhereInput
  }

  export type ChapterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NovelTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NovelStatisticOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NovelCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    originalTitle?: SortOrder
    authorId?: SortOrder
    createdById?: SortOrder
    genreId?: SortOrder
    kind?: SortOrder
    gender?: SortOrder
    status?: SortOrder
    synopsis?: SortOrder
    coverImage?: SortOrder
    wordCount?: SortOrder
    totalChapters?: SortOrder
    publishedAt?: SortOrder
    newChapterAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NovelAvgOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    createdById?: SortOrder
    genreId?: SortOrder
    wordCount?: SortOrder
    totalChapters?: SortOrder
  }

  export type NovelMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    originalTitle?: SortOrder
    authorId?: SortOrder
    createdById?: SortOrder
    genreId?: SortOrder
    kind?: SortOrder
    gender?: SortOrder
    status?: SortOrder
    synopsis?: SortOrder
    coverImage?: SortOrder
    wordCount?: SortOrder
    totalChapters?: SortOrder
    publishedAt?: SortOrder
    newChapterAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NovelMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    originalTitle?: SortOrder
    authorId?: SortOrder
    createdById?: SortOrder
    genreId?: SortOrder
    kind?: SortOrder
    gender?: SortOrder
    status?: SortOrder
    synopsis?: SortOrder
    coverImage?: SortOrder
    wordCount?: SortOrder
    totalChapters?: SortOrder
    publishedAt?: SortOrder
    newChapterAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NovelSumOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    createdById?: SortOrder
    genreId?: SortOrder
    wordCount?: SortOrder
    totalChapters?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumNovelKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NovelKind | EnumNovelKindFieldRefInput<$PrismaModel>
    in?: $Enums.NovelKind[] | ListEnumNovelKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.NovelKind[] | ListEnumNovelKindFieldRefInput<$PrismaModel>
    not?: NestedEnumNovelKindWithAggregatesFilter<$PrismaModel> | $Enums.NovelKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNovelKindFilter<$PrismaModel>
    _max?: NestedEnumNovelKindFilter<$PrismaModel>
  }

  export type EnumNovelStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NovelStatus | EnumNovelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NovelStatus[] | ListEnumNovelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NovelStatus[] | ListEnumNovelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNovelStatusWithAggregatesFilter<$PrismaModel> | $Enums.NovelStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNovelStatusFilter<$PrismaModel>
    _max?: NestedEnumNovelStatusFilter<$PrismaModel>
  }

  export type GenreCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type GenreAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GenreMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type GenreMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type GenreSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TagGroupScalarRelationFilter = {
    is?: TagGroupWhereInput
    isNot?: TagGroupWhereInput
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tagGroupId?: SortOrder
  }

  export type TagAvgOrderByAggregateInput = {
    id?: SortOrder
    tagGroupId?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tagGroupId?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tagGroupId?: SortOrder
  }

  export type TagSumOrderByAggregateInput = {
    id?: SortOrder
    tagGroupId?: SortOrder
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
  }

  export type TagGroupAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TagGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
  }

  export type TagGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    color?: SortOrder
  }

  export type TagGroupSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NovelScalarRelationFilter = {
    is?: NovelWhereInput
    isNot?: NovelWhereInput
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type NovelTagNovelIdTagIdCompoundUniqueInput = {
    novelId: number
    tagId: number
  }

  export type NovelTagCountOrderByAggregateInput = {
    novelId?: SortOrder
    tagId?: SortOrder
  }

  export type NovelTagAvgOrderByAggregateInput = {
    novelId?: SortOrder
    tagId?: SortOrder
  }

  export type NovelTagMaxOrderByAggregateInput = {
    novelId?: SortOrder
    tagId?: SortOrder
  }

  export type NovelTagMinOrderByAggregateInput = {
    novelId?: SortOrder
    tagId?: SortOrder
  }

  export type NovelTagSumOrderByAggregateInput = {
    novelId?: SortOrder
    tagId?: SortOrder
  }

  export type ChapterStatisticListRelationFilter = {
    every?: ChapterStatisticWhereInput
    some?: ChapterStatisticWhereInput
    none?: ChapterStatisticWhereInput
  }

  export type ChapterStatisticOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChapterNovelIdChapterNumberCompoundUniqueInput = {
    novelId: number
    chapterNumber: number
  }

  export type ChapterCountOrderByAggregateInput = {
    id?: SortOrder
    novelId?: SortOrder
    chapterNumber?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isLocked?: SortOrder
    unlockCost?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChapterAvgOrderByAggregateInput = {
    id?: SortOrder
    novelId?: SortOrder
    chapterNumber?: SortOrder
    unlockCost?: SortOrder
  }

  export type ChapterMaxOrderByAggregateInput = {
    id?: SortOrder
    novelId?: SortOrder
    chapterNumber?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isLocked?: SortOrder
    unlockCost?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChapterMinOrderByAggregateInput = {
    id?: SortOrder
    novelId?: SortOrder
    chapterNumber?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isLocked?: SortOrder
    unlockCost?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChapterSumOrderByAggregateInput = {
    id?: SortOrder
    novelId?: SortOrder
    chapterNumber?: SortOrder
    unlockCost?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ReviewUserIdNovelIdCompoundUniqueInput = {
    userId: number
    novelId: number
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    content?: SortOrder
    isSpoiler?: SortOrder
    userId?: SortOrder
    novelId?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    userId?: SortOrder
    novelId?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    content?: SortOrder
    isSpoiler?: SortOrder
    userId?: SortOrder
    novelId?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    content?: SortOrder
    isSpoiler?: SortOrder
    userId?: SortOrder
    novelId?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    id?: SortOrder
    rating?: SortOrder
    userId?: SortOrder
    novelId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ChapterScalarRelationFilter = {
    is?: ChapterWhereInput
    isNot?: ChapterWhereInput
  }

  export type NovelNullableScalarRelationFilter = {
    is?: NovelWhereInput | null
    isNot?: NovelWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    likes?: SortOrder
    userId?: SortOrder
    chapterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    novelId?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    id?: SortOrder
    likes?: SortOrder
    userId?: SortOrder
    chapterId?: SortOrder
    novelId?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    likes?: SortOrder
    userId?: SortOrder
    chapterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    novelId?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    likes?: SortOrder
    userId?: SortOrder
    chapterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    novelId?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    id?: SortOrder
    likes?: SortOrder
    userId?: SortOrder
    chapterId?: SortOrder
    novelId?: SortOrder
  }

  export type CommentScalarRelationFilter = {
    is?: CommentWhereInput
    isNot?: CommentWhereInput
  }

  export type ReplyCommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    likes?: SortOrder
    userId?: SortOrder
    commentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReplyCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    likes?: SortOrder
    userId?: SortOrder
    commentId?: SortOrder
  }

  export type ReplyCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    likes?: SortOrder
    userId?: SortOrder
    commentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReplyCommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    likes?: SortOrder
    userId?: SortOrder
    commentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReplyCommentSumOrderByAggregateInput = {
    id?: SortOrder
    likes?: SortOrder
    userId?: SortOrder
    commentId?: SortOrder
  }

  export type ReadingUserIdNovelIdCompoundUniqueInput = {
    userId: number
    novelId: number
  }

  export type ReadingCountOrderByAggregateInput = {
    userId?: SortOrder
    novelId?: SortOrder
    chapterId?: SortOrder
    lastRead?: SortOrder
  }

  export type ReadingAvgOrderByAggregateInput = {
    userId?: SortOrder
    novelId?: SortOrder
    chapterId?: SortOrder
  }

  export type ReadingMaxOrderByAggregateInput = {
    userId?: SortOrder
    novelId?: SortOrder
    chapterId?: SortOrder
    lastRead?: SortOrder
  }

  export type ReadingMinOrderByAggregateInput = {
    userId?: SortOrder
    novelId?: SortOrder
    chapterId?: SortOrder
    lastRead?: SortOrder
  }

  export type ReadingSumOrderByAggregateInput = {
    userId?: SortOrder
    novelId?: SortOrder
    chapterId?: SortOrder
  }

  export type FavoriteUserIdNovelIdCompoundUniqueInput = {
    userId: number
    novelId: number
  }

  export type FavoriteCountOrderByAggregateInput = {
    userId?: SortOrder
    novelId?: SortOrder
    createdAt?: SortOrder
  }

  export type FavoriteAvgOrderByAggregateInput = {
    userId?: SortOrder
    novelId?: SortOrder
  }

  export type FavoriteMaxOrderByAggregateInput = {
    userId?: SortOrder
    novelId?: SortOrder
    createdAt?: SortOrder
  }

  export type FavoriteMinOrderByAggregateInput = {
    userId?: SortOrder
    novelId?: SortOrder
    createdAt?: SortOrder
  }

  export type FavoriteSumOrderByAggregateInput = {
    userId?: SortOrder
    novelId?: SortOrder
  }

  export type NovelStatisticNovelIdDateCompoundUniqueInput = {
    novelId: number
    date: Date | string
  }

  export type NovelStatisticCountOrderByAggregateInput = {
    id?: SortOrder
    novelId?: SortOrder
    dailyViews?: SortOrder
    totalViews?: SortOrder
    reviews?: SortOrder
    comments?: SortOrder
    date?: SortOrder
  }

  export type NovelStatisticAvgOrderByAggregateInput = {
    id?: SortOrder
    novelId?: SortOrder
    dailyViews?: SortOrder
    totalViews?: SortOrder
    reviews?: SortOrder
    comments?: SortOrder
  }

  export type NovelStatisticMaxOrderByAggregateInput = {
    id?: SortOrder
    novelId?: SortOrder
    dailyViews?: SortOrder
    totalViews?: SortOrder
    reviews?: SortOrder
    comments?: SortOrder
    date?: SortOrder
  }

  export type NovelStatisticMinOrderByAggregateInput = {
    id?: SortOrder
    novelId?: SortOrder
    dailyViews?: SortOrder
    totalViews?: SortOrder
    reviews?: SortOrder
    comments?: SortOrder
    date?: SortOrder
  }

  export type NovelStatisticSumOrderByAggregateInput = {
    id?: SortOrder
    novelId?: SortOrder
    dailyViews?: SortOrder
    totalViews?: SortOrder
    reviews?: SortOrder
    comments?: SortOrder
  }

  export type ChapterStatisticChapterIdDateCompoundUniqueInput = {
    chapterId: number
    date: Date | string
  }

  export type ChapterStatisticCountOrderByAggregateInput = {
    id?: SortOrder
    chapterId?: SortOrder
    views?: SortOrder
    date?: SortOrder
  }

  export type ChapterStatisticAvgOrderByAggregateInput = {
    id?: SortOrder
    chapterId?: SortOrder
    views?: SortOrder
  }

  export type ChapterStatisticMaxOrderByAggregateInput = {
    id?: SortOrder
    chapterId?: SortOrder
    views?: SortOrder
    date?: SortOrder
  }

  export type ChapterStatisticMinOrderByAggregateInput = {
    id?: SortOrder
    chapterId?: SortOrder
    views?: SortOrder
    date?: SortOrder
  }

  export type ChapterStatisticSumOrderByAggregateInput = {
    id?: SortOrder
    chapterId?: SortOrder
    views?: SortOrder
  }

  export type UserCreatesocialLinksInput = {
    set: string[]
  }

  export type NotificationSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUserInput
    connect?: NotificationSettingsWhereUniqueInput
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type NovelCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<NovelCreateWithoutCreatedByInput, NovelUncheckedCreateWithoutCreatedByInput> | NovelCreateWithoutCreatedByInput[] | NovelUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: NovelCreateOrConnectWithoutCreatedByInput | NovelCreateOrConnectWithoutCreatedByInput[]
    createMany?: NovelCreateManyCreatedByInputEnvelope
    connect?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type ReadingCreateNestedManyWithoutUserInput = {
    create?: XOR<ReadingCreateWithoutUserInput, ReadingUncheckedCreateWithoutUserInput> | ReadingCreateWithoutUserInput[] | ReadingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReadingCreateOrConnectWithoutUserInput | ReadingCreateOrConnectWithoutUserInput[]
    createMany?: ReadingCreateManyUserInputEnvelope
    connect?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
  }

  export type FavoriteCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type ReplyCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<ReplyCommentCreateWithoutUserInput, ReplyCommentUncheckedCreateWithoutUserInput> | ReplyCommentCreateWithoutUserInput[] | ReplyCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReplyCommentCreateOrConnectWithoutUserInput | ReplyCommentCreateOrConnectWithoutUserInput[]
    createMany?: ReplyCommentCreateManyUserInputEnvelope
    connect?: ReplyCommentWhereUniqueInput | ReplyCommentWhereUniqueInput[]
  }

  export type NotificationSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUserInput
    connect?: NotificationSettingsWhereUniqueInput
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type NovelUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<NovelCreateWithoutCreatedByInput, NovelUncheckedCreateWithoutCreatedByInput> | NovelCreateWithoutCreatedByInput[] | NovelUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: NovelCreateOrConnectWithoutCreatedByInput | NovelCreateOrConnectWithoutCreatedByInput[]
    createMany?: NovelCreateManyCreatedByInputEnvelope
    connect?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type ReadingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReadingCreateWithoutUserInput, ReadingUncheckedCreateWithoutUserInput> | ReadingCreateWithoutUserInput[] | ReadingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReadingCreateOrConnectWithoutUserInput | ReadingCreateOrConnectWithoutUserInput[]
    createMany?: ReadingCreateManyUserInputEnvelope
    connect?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
  }

  export type FavoriteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type ReplyCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReplyCommentCreateWithoutUserInput, ReplyCommentUncheckedCreateWithoutUserInput> | ReplyCommentCreateWithoutUserInput[] | ReplyCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReplyCommentCreateOrConnectWithoutUserInput | ReplyCommentCreateOrConnectWithoutUserInput[]
    createMany?: ReplyCommentCreateManyUserInputEnvelope
    connect?: ReplyCommentWhereUniqueInput | ReplyCommentWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdatesocialLinksInput = {
    set?: string[]
    push?: string | string[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NotificationSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUserInput
    upsert?: NotificationSettingsUpsertWithoutUserInput
    disconnect?: NotificationSettingsWhereInput | boolean
    delete?: NotificationSettingsWhereInput | boolean
    connect?: NotificationSettingsWhereUniqueInput
    update?: XOR<XOR<NotificationSettingsUpdateToOneWithWhereWithoutUserInput, NotificationSettingsUpdateWithoutUserInput>, NotificationSettingsUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type NovelUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<NovelCreateWithoutCreatedByInput, NovelUncheckedCreateWithoutCreatedByInput> | NovelCreateWithoutCreatedByInput[] | NovelUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: NovelCreateOrConnectWithoutCreatedByInput | NovelCreateOrConnectWithoutCreatedByInput[]
    upsert?: NovelUpsertWithWhereUniqueWithoutCreatedByInput | NovelUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: NovelCreateManyCreatedByInputEnvelope
    set?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
    disconnect?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
    delete?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
    connect?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
    update?: NovelUpdateWithWhereUniqueWithoutCreatedByInput | NovelUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: NovelUpdateManyWithWhereWithoutCreatedByInput | NovelUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: NovelScalarWhereInput | NovelScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type ReadingUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReadingCreateWithoutUserInput, ReadingUncheckedCreateWithoutUserInput> | ReadingCreateWithoutUserInput[] | ReadingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReadingCreateOrConnectWithoutUserInput | ReadingCreateOrConnectWithoutUserInput[]
    upsert?: ReadingUpsertWithWhereUniqueWithoutUserInput | ReadingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReadingCreateManyUserInputEnvelope
    set?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
    disconnect?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
    delete?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
    connect?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
    update?: ReadingUpdateWithWhereUniqueWithoutUserInput | ReadingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReadingUpdateManyWithWhereWithoutUserInput | ReadingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReadingScalarWhereInput | ReadingScalarWhereInput[]
  }

  export type FavoriteUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutUserInput | FavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutUserInput | FavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutUserInput | FavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type ReplyCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReplyCommentCreateWithoutUserInput, ReplyCommentUncheckedCreateWithoutUserInput> | ReplyCommentCreateWithoutUserInput[] | ReplyCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReplyCommentCreateOrConnectWithoutUserInput | ReplyCommentCreateOrConnectWithoutUserInput[]
    upsert?: ReplyCommentUpsertWithWhereUniqueWithoutUserInput | ReplyCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReplyCommentCreateManyUserInputEnvelope
    set?: ReplyCommentWhereUniqueInput | ReplyCommentWhereUniqueInput[]
    disconnect?: ReplyCommentWhereUniqueInput | ReplyCommentWhereUniqueInput[]
    delete?: ReplyCommentWhereUniqueInput | ReplyCommentWhereUniqueInput[]
    connect?: ReplyCommentWhereUniqueInput | ReplyCommentWhereUniqueInput[]
    update?: ReplyCommentUpdateWithWhereUniqueWithoutUserInput | ReplyCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReplyCommentUpdateManyWithWhereWithoutUserInput | ReplyCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReplyCommentScalarWhereInput | ReplyCommentScalarWhereInput[]
  }

  export type NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: NotificationSettingsCreateOrConnectWithoutUserInput
    upsert?: NotificationSettingsUpsertWithoutUserInput
    disconnect?: NotificationSettingsWhereInput | boolean
    delete?: NotificationSettingsWhereInput | boolean
    connect?: NotificationSettingsWhereUniqueInput
    update?: XOR<XOR<NotificationSettingsUpdateToOneWithWhereWithoutUserInput, NotificationSettingsUpdateWithoutUserInput>, NotificationSettingsUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type NovelUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<NovelCreateWithoutCreatedByInput, NovelUncheckedCreateWithoutCreatedByInput> | NovelCreateWithoutCreatedByInput[] | NovelUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: NovelCreateOrConnectWithoutCreatedByInput | NovelCreateOrConnectWithoutCreatedByInput[]
    upsert?: NovelUpsertWithWhereUniqueWithoutCreatedByInput | NovelUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: NovelCreateManyCreatedByInputEnvelope
    set?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
    disconnect?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
    delete?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
    connect?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
    update?: NovelUpdateWithWhereUniqueWithoutCreatedByInput | NovelUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: NovelUpdateManyWithWhereWithoutCreatedByInput | NovelUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: NovelScalarWhereInput | NovelScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type ReadingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReadingCreateWithoutUserInput, ReadingUncheckedCreateWithoutUserInput> | ReadingCreateWithoutUserInput[] | ReadingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReadingCreateOrConnectWithoutUserInput | ReadingCreateOrConnectWithoutUserInput[]
    upsert?: ReadingUpsertWithWhereUniqueWithoutUserInput | ReadingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReadingCreateManyUserInputEnvelope
    set?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
    disconnect?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
    delete?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
    connect?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
    update?: ReadingUpdateWithWhereUniqueWithoutUserInput | ReadingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReadingUpdateManyWithWhereWithoutUserInput | ReadingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReadingScalarWhereInput | ReadingScalarWhereInput[]
  }

  export type FavoriteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput> | FavoriteCreateWithoutUserInput[] | FavoriteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutUserInput | FavoriteCreateOrConnectWithoutUserInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutUserInput | FavoriteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FavoriteCreateManyUserInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutUserInput | FavoriteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutUserInput | FavoriteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type ReplyCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReplyCommentCreateWithoutUserInput, ReplyCommentUncheckedCreateWithoutUserInput> | ReplyCommentCreateWithoutUserInput[] | ReplyCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReplyCommentCreateOrConnectWithoutUserInput | ReplyCommentCreateOrConnectWithoutUserInput[]
    upsert?: ReplyCommentUpsertWithWhereUniqueWithoutUserInput | ReplyCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReplyCommentCreateManyUserInputEnvelope
    set?: ReplyCommentWhereUniqueInput | ReplyCommentWhereUniqueInput[]
    disconnect?: ReplyCommentWhereUniqueInput | ReplyCommentWhereUniqueInput[]
    delete?: ReplyCommentWhereUniqueInput | ReplyCommentWhereUniqueInput[]
    connect?: ReplyCommentWhereUniqueInput | ReplyCommentWhereUniqueInput[]
    update?: ReplyCommentUpdateWithWhereUniqueWithoutUserInput | ReplyCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReplyCommentUpdateManyWithWhereWithoutUserInput | ReplyCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReplyCommentScalarWhereInput | ReplyCommentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type NovelCreateNestedManyWithoutAuthorInput = {
    create?: XOR<NovelCreateWithoutAuthorInput, NovelUncheckedCreateWithoutAuthorInput> | NovelCreateWithoutAuthorInput[] | NovelUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: NovelCreateOrConnectWithoutAuthorInput | NovelCreateOrConnectWithoutAuthorInput[]
    createMany?: NovelCreateManyAuthorInputEnvelope
    connect?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
  }

  export type NovelUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<NovelCreateWithoutAuthorInput, NovelUncheckedCreateWithoutAuthorInput> | NovelCreateWithoutAuthorInput[] | NovelUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: NovelCreateOrConnectWithoutAuthorInput | NovelCreateOrConnectWithoutAuthorInput[]
    createMany?: NovelCreateManyAuthorInputEnvelope
    connect?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
  }

  export type NovelUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<NovelCreateWithoutAuthorInput, NovelUncheckedCreateWithoutAuthorInput> | NovelCreateWithoutAuthorInput[] | NovelUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: NovelCreateOrConnectWithoutAuthorInput | NovelCreateOrConnectWithoutAuthorInput[]
    upsert?: NovelUpsertWithWhereUniqueWithoutAuthorInput | NovelUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: NovelCreateManyAuthorInputEnvelope
    set?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
    disconnect?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
    delete?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
    connect?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
    update?: NovelUpdateWithWhereUniqueWithoutAuthorInput | NovelUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: NovelUpdateManyWithWhereWithoutAuthorInput | NovelUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: NovelScalarWhereInput | NovelScalarWhereInput[]
  }

  export type NovelUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<NovelCreateWithoutAuthorInput, NovelUncheckedCreateWithoutAuthorInput> | NovelCreateWithoutAuthorInput[] | NovelUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: NovelCreateOrConnectWithoutAuthorInput | NovelCreateOrConnectWithoutAuthorInput[]
    upsert?: NovelUpsertWithWhereUniqueWithoutAuthorInput | NovelUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: NovelCreateManyAuthorInputEnvelope
    set?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
    disconnect?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
    delete?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
    connect?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
    update?: NovelUpdateWithWhereUniqueWithoutAuthorInput | NovelUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: NovelUpdateManyWithWhereWithoutAuthorInput | NovelUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: NovelScalarWhereInput | NovelScalarWhereInput[]
  }

  export type AuthorCreateNestedOneWithoutNovelsInput = {
    create?: XOR<AuthorCreateWithoutNovelsInput, AuthorUncheckedCreateWithoutNovelsInput>
    connectOrCreate?: AuthorCreateOrConnectWithoutNovelsInput
    connect?: AuthorWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuthoredNovelsInput = {
    create?: XOR<UserCreateWithoutAuthoredNovelsInput, UserUncheckedCreateWithoutAuthoredNovelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthoredNovelsInput
    connect?: UserWhereUniqueInput
  }

  export type GenreCreateNestedOneWithoutNovelsInput = {
    create?: XOR<GenreCreateWithoutNovelsInput, GenreUncheckedCreateWithoutNovelsInput>
    connectOrCreate?: GenreCreateOrConnectWithoutNovelsInput
    connect?: GenreWhereUniqueInput
  }

  export type ChapterCreateNestedManyWithoutNovelInput = {
    create?: XOR<ChapterCreateWithoutNovelInput, ChapterUncheckedCreateWithoutNovelInput> | ChapterCreateWithoutNovelInput[] | ChapterUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutNovelInput | ChapterCreateOrConnectWithoutNovelInput[]
    createMany?: ChapterCreateManyNovelInputEnvelope
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
  }

  export type NovelTagCreateNestedManyWithoutNovelInput = {
    create?: XOR<NovelTagCreateWithoutNovelInput, NovelTagUncheckedCreateWithoutNovelInput> | NovelTagCreateWithoutNovelInput[] | NovelTagUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: NovelTagCreateOrConnectWithoutNovelInput | NovelTagCreateOrConnectWithoutNovelInput[]
    createMany?: NovelTagCreateManyNovelInputEnvelope
    connect?: NovelTagWhereUniqueInput | NovelTagWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutNovelInput = {
    create?: XOR<ReviewCreateWithoutNovelInput, ReviewUncheckedCreateWithoutNovelInput> | ReviewCreateWithoutNovelInput[] | ReviewUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutNovelInput | ReviewCreateOrConnectWithoutNovelInput[]
    createMany?: ReviewCreateManyNovelInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type NovelStatisticCreateNestedManyWithoutNovelInput = {
    create?: XOR<NovelStatisticCreateWithoutNovelInput, NovelStatisticUncheckedCreateWithoutNovelInput> | NovelStatisticCreateWithoutNovelInput[] | NovelStatisticUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: NovelStatisticCreateOrConnectWithoutNovelInput | NovelStatisticCreateOrConnectWithoutNovelInput[]
    createMany?: NovelStatisticCreateManyNovelInputEnvelope
    connect?: NovelStatisticWhereUniqueInput | NovelStatisticWhereUniqueInput[]
  }

  export type ReadingCreateNestedManyWithoutNovelInput = {
    create?: XOR<ReadingCreateWithoutNovelInput, ReadingUncheckedCreateWithoutNovelInput> | ReadingCreateWithoutNovelInput[] | ReadingUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: ReadingCreateOrConnectWithoutNovelInput | ReadingCreateOrConnectWithoutNovelInput[]
    createMany?: ReadingCreateManyNovelInputEnvelope
    connect?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
  }

  export type FavoriteCreateNestedManyWithoutNovelInput = {
    create?: XOR<FavoriteCreateWithoutNovelInput, FavoriteUncheckedCreateWithoutNovelInput> | FavoriteCreateWithoutNovelInput[] | FavoriteUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutNovelInput | FavoriteCreateOrConnectWithoutNovelInput[]
    createMany?: FavoriteCreateManyNovelInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutNovelInput = {
    create?: XOR<CommentCreateWithoutNovelInput, CommentUncheckedCreateWithoutNovelInput> | CommentCreateWithoutNovelInput[] | CommentUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutNovelInput | CommentCreateOrConnectWithoutNovelInput[]
    createMany?: CommentCreateManyNovelInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ChapterUncheckedCreateNestedManyWithoutNovelInput = {
    create?: XOR<ChapterCreateWithoutNovelInput, ChapterUncheckedCreateWithoutNovelInput> | ChapterCreateWithoutNovelInput[] | ChapterUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutNovelInput | ChapterCreateOrConnectWithoutNovelInput[]
    createMany?: ChapterCreateManyNovelInputEnvelope
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
  }

  export type NovelTagUncheckedCreateNestedManyWithoutNovelInput = {
    create?: XOR<NovelTagCreateWithoutNovelInput, NovelTagUncheckedCreateWithoutNovelInput> | NovelTagCreateWithoutNovelInput[] | NovelTagUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: NovelTagCreateOrConnectWithoutNovelInput | NovelTagCreateOrConnectWithoutNovelInput[]
    createMany?: NovelTagCreateManyNovelInputEnvelope
    connect?: NovelTagWhereUniqueInput | NovelTagWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutNovelInput = {
    create?: XOR<ReviewCreateWithoutNovelInput, ReviewUncheckedCreateWithoutNovelInput> | ReviewCreateWithoutNovelInput[] | ReviewUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutNovelInput | ReviewCreateOrConnectWithoutNovelInput[]
    createMany?: ReviewCreateManyNovelInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type NovelStatisticUncheckedCreateNestedManyWithoutNovelInput = {
    create?: XOR<NovelStatisticCreateWithoutNovelInput, NovelStatisticUncheckedCreateWithoutNovelInput> | NovelStatisticCreateWithoutNovelInput[] | NovelStatisticUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: NovelStatisticCreateOrConnectWithoutNovelInput | NovelStatisticCreateOrConnectWithoutNovelInput[]
    createMany?: NovelStatisticCreateManyNovelInputEnvelope
    connect?: NovelStatisticWhereUniqueInput | NovelStatisticWhereUniqueInput[]
  }

  export type ReadingUncheckedCreateNestedManyWithoutNovelInput = {
    create?: XOR<ReadingCreateWithoutNovelInput, ReadingUncheckedCreateWithoutNovelInput> | ReadingCreateWithoutNovelInput[] | ReadingUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: ReadingCreateOrConnectWithoutNovelInput | ReadingCreateOrConnectWithoutNovelInput[]
    createMany?: ReadingCreateManyNovelInputEnvelope
    connect?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
  }

  export type FavoriteUncheckedCreateNestedManyWithoutNovelInput = {
    create?: XOR<FavoriteCreateWithoutNovelInput, FavoriteUncheckedCreateWithoutNovelInput> | FavoriteCreateWithoutNovelInput[] | FavoriteUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutNovelInput | FavoriteCreateOrConnectWithoutNovelInput[]
    createMany?: FavoriteCreateManyNovelInputEnvelope
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutNovelInput = {
    create?: XOR<CommentCreateWithoutNovelInput, CommentUncheckedCreateWithoutNovelInput> | CommentCreateWithoutNovelInput[] | CommentUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutNovelInput | CommentCreateOrConnectWithoutNovelInput[]
    createMany?: CommentCreateManyNovelInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type EnumNovelKindFieldUpdateOperationsInput = {
    set?: $Enums.NovelKind
  }

  export type EnumNovelStatusFieldUpdateOperationsInput = {
    set?: $Enums.NovelStatus
  }

  export type AuthorUpdateOneWithoutNovelsNestedInput = {
    create?: XOR<AuthorCreateWithoutNovelsInput, AuthorUncheckedCreateWithoutNovelsInput>
    connectOrCreate?: AuthorCreateOrConnectWithoutNovelsInput
    upsert?: AuthorUpsertWithoutNovelsInput
    disconnect?: AuthorWhereInput | boolean
    delete?: AuthorWhereInput | boolean
    connect?: AuthorWhereUniqueInput
    update?: XOR<XOR<AuthorUpdateToOneWithWhereWithoutNovelsInput, AuthorUpdateWithoutNovelsInput>, AuthorUncheckedUpdateWithoutNovelsInput>
  }

  export type UserUpdateOneRequiredWithoutAuthoredNovelsNestedInput = {
    create?: XOR<UserCreateWithoutAuthoredNovelsInput, UserUncheckedCreateWithoutAuthoredNovelsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthoredNovelsInput
    upsert?: UserUpsertWithoutAuthoredNovelsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuthoredNovelsInput, UserUpdateWithoutAuthoredNovelsInput>, UserUncheckedUpdateWithoutAuthoredNovelsInput>
  }

  export type GenreUpdateOneRequiredWithoutNovelsNestedInput = {
    create?: XOR<GenreCreateWithoutNovelsInput, GenreUncheckedCreateWithoutNovelsInput>
    connectOrCreate?: GenreCreateOrConnectWithoutNovelsInput
    upsert?: GenreUpsertWithoutNovelsInput
    connect?: GenreWhereUniqueInput
    update?: XOR<XOR<GenreUpdateToOneWithWhereWithoutNovelsInput, GenreUpdateWithoutNovelsInput>, GenreUncheckedUpdateWithoutNovelsInput>
  }

  export type ChapterUpdateManyWithoutNovelNestedInput = {
    create?: XOR<ChapterCreateWithoutNovelInput, ChapterUncheckedCreateWithoutNovelInput> | ChapterCreateWithoutNovelInput[] | ChapterUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutNovelInput | ChapterCreateOrConnectWithoutNovelInput[]
    upsert?: ChapterUpsertWithWhereUniqueWithoutNovelInput | ChapterUpsertWithWhereUniqueWithoutNovelInput[]
    createMany?: ChapterCreateManyNovelInputEnvelope
    set?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    disconnect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    delete?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    update?: ChapterUpdateWithWhereUniqueWithoutNovelInput | ChapterUpdateWithWhereUniqueWithoutNovelInput[]
    updateMany?: ChapterUpdateManyWithWhereWithoutNovelInput | ChapterUpdateManyWithWhereWithoutNovelInput[]
    deleteMany?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
  }

  export type NovelTagUpdateManyWithoutNovelNestedInput = {
    create?: XOR<NovelTagCreateWithoutNovelInput, NovelTagUncheckedCreateWithoutNovelInput> | NovelTagCreateWithoutNovelInput[] | NovelTagUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: NovelTagCreateOrConnectWithoutNovelInput | NovelTagCreateOrConnectWithoutNovelInput[]
    upsert?: NovelTagUpsertWithWhereUniqueWithoutNovelInput | NovelTagUpsertWithWhereUniqueWithoutNovelInput[]
    createMany?: NovelTagCreateManyNovelInputEnvelope
    set?: NovelTagWhereUniqueInput | NovelTagWhereUniqueInput[]
    disconnect?: NovelTagWhereUniqueInput | NovelTagWhereUniqueInput[]
    delete?: NovelTagWhereUniqueInput | NovelTagWhereUniqueInput[]
    connect?: NovelTagWhereUniqueInput | NovelTagWhereUniqueInput[]
    update?: NovelTagUpdateWithWhereUniqueWithoutNovelInput | NovelTagUpdateWithWhereUniqueWithoutNovelInput[]
    updateMany?: NovelTagUpdateManyWithWhereWithoutNovelInput | NovelTagUpdateManyWithWhereWithoutNovelInput[]
    deleteMany?: NovelTagScalarWhereInput | NovelTagScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutNovelNestedInput = {
    create?: XOR<ReviewCreateWithoutNovelInput, ReviewUncheckedCreateWithoutNovelInput> | ReviewCreateWithoutNovelInput[] | ReviewUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutNovelInput | ReviewCreateOrConnectWithoutNovelInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutNovelInput | ReviewUpsertWithWhereUniqueWithoutNovelInput[]
    createMany?: ReviewCreateManyNovelInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutNovelInput | ReviewUpdateWithWhereUniqueWithoutNovelInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutNovelInput | ReviewUpdateManyWithWhereWithoutNovelInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type NovelStatisticUpdateManyWithoutNovelNestedInput = {
    create?: XOR<NovelStatisticCreateWithoutNovelInput, NovelStatisticUncheckedCreateWithoutNovelInput> | NovelStatisticCreateWithoutNovelInput[] | NovelStatisticUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: NovelStatisticCreateOrConnectWithoutNovelInput | NovelStatisticCreateOrConnectWithoutNovelInput[]
    upsert?: NovelStatisticUpsertWithWhereUniqueWithoutNovelInput | NovelStatisticUpsertWithWhereUniqueWithoutNovelInput[]
    createMany?: NovelStatisticCreateManyNovelInputEnvelope
    set?: NovelStatisticWhereUniqueInput | NovelStatisticWhereUniqueInput[]
    disconnect?: NovelStatisticWhereUniqueInput | NovelStatisticWhereUniqueInput[]
    delete?: NovelStatisticWhereUniqueInput | NovelStatisticWhereUniqueInput[]
    connect?: NovelStatisticWhereUniqueInput | NovelStatisticWhereUniqueInput[]
    update?: NovelStatisticUpdateWithWhereUniqueWithoutNovelInput | NovelStatisticUpdateWithWhereUniqueWithoutNovelInput[]
    updateMany?: NovelStatisticUpdateManyWithWhereWithoutNovelInput | NovelStatisticUpdateManyWithWhereWithoutNovelInput[]
    deleteMany?: NovelStatisticScalarWhereInput | NovelStatisticScalarWhereInput[]
  }

  export type ReadingUpdateManyWithoutNovelNestedInput = {
    create?: XOR<ReadingCreateWithoutNovelInput, ReadingUncheckedCreateWithoutNovelInput> | ReadingCreateWithoutNovelInput[] | ReadingUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: ReadingCreateOrConnectWithoutNovelInput | ReadingCreateOrConnectWithoutNovelInput[]
    upsert?: ReadingUpsertWithWhereUniqueWithoutNovelInput | ReadingUpsertWithWhereUniqueWithoutNovelInput[]
    createMany?: ReadingCreateManyNovelInputEnvelope
    set?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
    disconnect?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
    delete?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
    connect?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
    update?: ReadingUpdateWithWhereUniqueWithoutNovelInput | ReadingUpdateWithWhereUniqueWithoutNovelInput[]
    updateMany?: ReadingUpdateManyWithWhereWithoutNovelInput | ReadingUpdateManyWithWhereWithoutNovelInput[]
    deleteMany?: ReadingScalarWhereInput | ReadingScalarWhereInput[]
  }

  export type FavoriteUpdateManyWithoutNovelNestedInput = {
    create?: XOR<FavoriteCreateWithoutNovelInput, FavoriteUncheckedCreateWithoutNovelInput> | FavoriteCreateWithoutNovelInput[] | FavoriteUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutNovelInput | FavoriteCreateOrConnectWithoutNovelInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutNovelInput | FavoriteUpsertWithWhereUniqueWithoutNovelInput[]
    createMany?: FavoriteCreateManyNovelInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutNovelInput | FavoriteUpdateWithWhereUniqueWithoutNovelInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutNovelInput | FavoriteUpdateManyWithWhereWithoutNovelInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutNovelNestedInput = {
    create?: XOR<CommentCreateWithoutNovelInput, CommentUncheckedCreateWithoutNovelInput> | CommentCreateWithoutNovelInput[] | CommentUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutNovelInput | CommentCreateOrConnectWithoutNovelInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutNovelInput | CommentUpsertWithWhereUniqueWithoutNovelInput[]
    createMany?: CommentCreateManyNovelInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutNovelInput | CommentUpdateWithWhereUniqueWithoutNovelInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutNovelInput | CommentUpdateManyWithWhereWithoutNovelInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ChapterUncheckedUpdateManyWithoutNovelNestedInput = {
    create?: XOR<ChapterCreateWithoutNovelInput, ChapterUncheckedCreateWithoutNovelInput> | ChapterCreateWithoutNovelInput[] | ChapterUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: ChapterCreateOrConnectWithoutNovelInput | ChapterCreateOrConnectWithoutNovelInput[]
    upsert?: ChapterUpsertWithWhereUniqueWithoutNovelInput | ChapterUpsertWithWhereUniqueWithoutNovelInput[]
    createMany?: ChapterCreateManyNovelInputEnvelope
    set?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    disconnect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    delete?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    connect?: ChapterWhereUniqueInput | ChapterWhereUniqueInput[]
    update?: ChapterUpdateWithWhereUniqueWithoutNovelInput | ChapterUpdateWithWhereUniqueWithoutNovelInput[]
    updateMany?: ChapterUpdateManyWithWhereWithoutNovelInput | ChapterUpdateManyWithWhereWithoutNovelInput[]
    deleteMany?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
  }

  export type NovelTagUncheckedUpdateManyWithoutNovelNestedInput = {
    create?: XOR<NovelTagCreateWithoutNovelInput, NovelTagUncheckedCreateWithoutNovelInput> | NovelTagCreateWithoutNovelInput[] | NovelTagUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: NovelTagCreateOrConnectWithoutNovelInput | NovelTagCreateOrConnectWithoutNovelInput[]
    upsert?: NovelTagUpsertWithWhereUniqueWithoutNovelInput | NovelTagUpsertWithWhereUniqueWithoutNovelInput[]
    createMany?: NovelTagCreateManyNovelInputEnvelope
    set?: NovelTagWhereUniqueInput | NovelTagWhereUniqueInput[]
    disconnect?: NovelTagWhereUniqueInput | NovelTagWhereUniqueInput[]
    delete?: NovelTagWhereUniqueInput | NovelTagWhereUniqueInput[]
    connect?: NovelTagWhereUniqueInput | NovelTagWhereUniqueInput[]
    update?: NovelTagUpdateWithWhereUniqueWithoutNovelInput | NovelTagUpdateWithWhereUniqueWithoutNovelInput[]
    updateMany?: NovelTagUpdateManyWithWhereWithoutNovelInput | NovelTagUpdateManyWithWhereWithoutNovelInput[]
    deleteMany?: NovelTagScalarWhereInput | NovelTagScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutNovelNestedInput = {
    create?: XOR<ReviewCreateWithoutNovelInput, ReviewUncheckedCreateWithoutNovelInput> | ReviewCreateWithoutNovelInput[] | ReviewUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutNovelInput | ReviewCreateOrConnectWithoutNovelInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutNovelInput | ReviewUpsertWithWhereUniqueWithoutNovelInput[]
    createMany?: ReviewCreateManyNovelInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutNovelInput | ReviewUpdateWithWhereUniqueWithoutNovelInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutNovelInput | ReviewUpdateManyWithWhereWithoutNovelInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type NovelStatisticUncheckedUpdateManyWithoutNovelNestedInput = {
    create?: XOR<NovelStatisticCreateWithoutNovelInput, NovelStatisticUncheckedCreateWithoutNovelInput> | NovelStatisticCreateWithoutNovelInput[] | NovelStatisticUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: NovelStatisticCreateOrConnectWithoutNovelInput | NovelStatisticCreateOrConnectWithoutNovelInput[]
    upsert?: NovelStatisticUpsertWithWhereUniqueWithoutNovelInput | NovelStatisticUpsertWithWhereUniqueWithoutNovelInput[]
    createMany?: NovelStatisticCreateManyNovelInputEnvelope
    set?: NovelStatisticWhereUniqueInput | NovelStatisticWhereUniqueInput[]
    disconnect?: NovelStatisticWhereUniqueInput | NovelStatisticWhereUniqueInput[]
    delete?: NovelStatisticWhereUniqueInput | NovelStatisticWhereUniqueInput[]
    connect?: NovelStatisticWhereUniqueInput | NovelStatisticWhereUniqueInput[]
    update?: NovelStatisticUpdateWithWhereUniqueWithoutNovelInput | NovelStatisticUpdateWithWhereUniqueWithoutNovelInput[]
    updateMany?: NovelStatisticUpdateManyWithWhereWithoutNovelInput | NovelStatisticUpdateManyWithWhereWithoutNovelInput[]
    deleteMany?: NovelStatisticScalarWhereInput | NovelStatisticScalarWhereInput[]
  }

  export type ReadingUncheckedUpdateManyWithoutNovelNestedInput = {
    create?: XOR<ReadingCreateWithoutNovelInput, ReadingUncheckedCreateWithoutNovelInput> | ReadingCreateWithoutNovelInput[] | ReadingUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: ReadingCreateOrConnectWithoutNovelInput | ReadingCreateOrConnectWithoutNovelInput[]
    upsert?: ReadingUpsertWithWhereUniqueWithoutNovelInput | ReadingUpsertWithWhereUniqueWithoutNovelInput[]
    createMany?: ReadingCreateManyNovelInputEnvelope
    set?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
    disconnect?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
    delete?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
    connect?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
    update?: ReadingUpdateWithWhereUniqueWithoutNovelInput | ReadingUpdateWithWhereUniqueWithoutNovelInput[]
    updateMany?: ReadingUpdateManyWithWhereWithoutNovelInput | ReadingUpdateManyWithWhereWithoutNovelInput[]
    deleteMany?: ReadingScalarWhereInput | ReadingScalarWhereInput[]
  }

  export type FavoriteUncheckedUpdateManyWithoutNovelNestedInput = {
    create?: XOR<FavoriteCreateWithoutNovelInput, FavoriteUncheckedCreateWithoutNovelInput> | FavoriteCreateWithoutNovelInput[] | FavoriteUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: FavoriteCreateOrConnectWithoutNovelInput | FavoriteCreateOrConnectWithoutNovelInput[]
    upsert?: FavoriteUpsertWithWhereUniqueWithoutNovelInput | FavoriteUpsertWithWhereUniqueWithoutNovelInput[]
    createMany?: FavoriteCreateManyNovelInputEnvelope
    set?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    disconnect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    delete?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    connect?: FavoriteWhereUniqueInput | FavoriteWhereUniqueInput[]
    update?: FavoriteUpdateWithWhereUniqueWithoutNovelInput | FavoriteUpdateWithWhereUniqueWithoutNovelInput[]
    updateMany?: FavoriteUpdateManyWithWhereWithoutNovelInput | FavoriteUpdateManyWithWhereWithoutNovelInput[]
    deleteMany?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutNovelNestedInput = {
    create?: XOR<CommentCreateWithoutNovelInput, CommentUncheckedCreateWithoutNovelInput> | CommentCreateWithoutNovelInput[] | CommentUncheckedCreateWithoutNovelInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutNovelInput | CommentCreateOrConnectWithoutNovelInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutNovelInput | CommentUpsertWithWhereUniqueWithoutNovelInput[]
    createMany?: CommentCreateManyNovelInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutNovelInput | CommentUpdateWithWhereUniqueWithoutNovelInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutNovelInput | CommentUpdateManyWithWhereWithoutNovelInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type NovelCreateNestedManyWithoutGenreInput = {
    create?: XOR<NovelCreateWithoutGenreInput, NovelUncheckedCreateWithoutGenreInput> | NovelCreateWithoutGenreInput[] | NovelUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: NovelCreateOrConnectWithoutGenreInput | NovelCreateOrConnectWithoutGenreInput[]
    createMany?: NovelCreateManyGenreInputEnvelope
    connect?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
  }

  export type NovelUncheckedCreateNestedManyWithoutGenreInput = {
    create?: XOR<NovelCreateWithoutGenreInput, NovelUncheckedCreateWithoutGenreInput> | NovelCreateWithoutGenreInput[] | NovelUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: NovelCreateOrConnectWithoutGenreInput | NovelCreateOrConnectWithoutGenreInput[]
    createMany?: NovelCreateManyGenreInputEnvelope
    connect?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
  }

  export type NovelUpdateManyWithoutGenreNestedInput = {
    create?: XOR<NovelCreateWithoutGenreInput, NovelUncheckedCreateWithoutGenreInput> | NovelCreateWithoutGenreInput[] | NovelUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: NovelCreateOrConnectWithoutGenreInput | NovelCreateOrConnectWithoutGenreInput[]
    upsert?: NovelUpsertWithWhereUniqueWithoutGenreInput | NovelUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: NovelCreateManyGenreInputEnvelope
    set?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
    disconnect?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
    delete?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
    connect?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
    update?: NovelUpdateWithWhereUniqueWithoutGenreInput | NovelUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: NovelUpdateManyWithWhereWithoutGenreInput | NovelUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: NovelScalarWhereInput | NovelScalarWhereInput[]
  }

  export type NovelUncheckedUpdateManyWithoutGenreNestedInput = {
    create?: XOR<NovelCreateWithoutGenreInput, NovelUncheckedCreateWithoutGenreInput> | NovelCreateWithoutGenreInput[] | NovelUncheckedCreateWithoutGenreInput[]
    connectOrCreate?: NovelCreateOrConnectWithoutGenreInput | NovelCreateOrConnectWithoutGenreInput[]
    upsert?: NovelUpsertWithWhereUniqueWithoutGenreInput | NovelUpsertWithWhereUniqueWithoutGenreInput[]
    createMany?: NovelCreateManyGenreInputEnvelope
    set?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
    disconnect?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
    delete?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
    connect?: NovelWhereUniqueInput | NovelWhereUniqueInput[]
    update?: NovelUpdateWithWhereUniqueWithoutGenreInput | NovelUpdateWithWhereUniqueWithoutGenreInput[]
    updateMany?: NovelUpdateManyWithWhereWithoutGenreInput | NovelUpdateManyWithWhereWithoutGenreInput[]
    deleteMany?: NovelScalarWhereInput | NovelScalarWhereInput[]
  }

  export type TagGroupCreateNestedOneWithoutTagsInput = {
    create?: XOR<TagGroupCreateWithoutTagsInput, TagGroupUncheckedCreateWithoutTagsInput>
    connectOrCreate?: TagGroupCreateOrConnectWithoutTagsInput
    connect?: TagGroupWhereUniqueInput
  }

  export type NovelTagCreateNestedManyWithoutTagInput = {
    create?: XOR<NovelTagCreateWithoutTagInput, NovelTagUncheckedCreateWithoutTagInput> | NovelTagCreateWithoutTagInput[] | NovelTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: NovelTagCreateOrConnectWithoutTagInput | NovelTagCreateOrConnectWithoutTagInput[]
    createMany?: NovelTagCreateManyTagInputEnvelope
    connect?: NovelTagWhereUniqueInput | NovelTagWhereUniqueInput[]
  }

  export type NovelTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<NovelTagCreateWithoutTagInput, NovelTagUncheckedCreateWithoutTagInput> | NovelTagCreateWithoutTagInput[] | NovelTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: NovelTagCreateOrConnectWithoutTagInput | NovelTagCreateOrConnectWithoutTagInput[]
    createMany?: NovelTagCreateManyTagInputEnvelope
    connect?: NovelTagWhereUniqueInput | NovelTagWhereUniqueInput[]
  }

  export type TagGroupUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<TagGroupCreateWithoutTagsInput, TagGroupUncheckedCreateWithoutTagsInput>
    connectOrCreate?: TagGroupCreateOrConnectWithoutTagsInput
    upsert?: TagGroupUpsertWithoutTagsInput
    connect?: TagGroupWhereUniqueInput
    update?: XOR<XOR<TagGroupUpdateToOneWithWhereWithoutTagsInput, TagGroupUpdateWithoutTagsInput>, TagGroupUncheckedUpdateWithoutTagsInput>
  }

  export type NovelTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<NovelTagCreateWithoutTagInput, NovelTagUncheckedCreateWithoutTagInput> | NovelTagCreateWithoutTagInput[] | NovelTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: NovelTagCreateOrConnectWithoutTagInput | NovelTagCreateOrConnectWithoutTagInput[]
    upsert?: NovelTagUpsertWithWhereUniqueWithoutTagInput | NovelTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: NovelTagCreateManyTagInputEnvelope
    set?: NovelTagWhereUniqueInput | NovelTagWhereUniqueInput[]
    disconnect?: NovelTagWhereUniqueInput | NovelTagWhereUniqueInput[]
    delete?: NovelTagWhereUniqueInput | NovelTagWhereUniqueInput[]
    connect?: NovelTagWhereUniqueInput | NovelTagWhereUniqueInput[]
    update?: NovelTagUpdateWithWhereUniqueWithoutTagInput | NovelTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: NovelTagUpdateManyWithWhereWithoutTagInput | NovelTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: NovelTagScalarWhereInput | NovelTagScalarWhereInput[]
  }

  export type NovelTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<NovelTagCreateWithoutTagInput, NovelTagUncheckedCreateWithoutTagInput> | NovelTagCreateWithoutTagInput[] | NovelTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: NovelTagCreateOrConnectWithoutTagInput | NovelTagCreateOrConnectWithoutTagInput[]
    upsert?: NovelTagUpsertWithWhereUniqueWithoutTagInput | NovelTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: NovelTagCreateManyTagInputEnvelope
    set?: NovelTagWhereUniqueInput | NovelTagWhereUniqueInput[]
    disconnect?: NovelTagWhereUniqueInput | NovelTagWhereUniqueInput[]
    delete?: NovelTagWhereUniqueInput | NovelTagWhereUniqueInput[]
    connect?: NovelTagWhereUniqueInput | NovelTagWhereUniqueInput[]
    update?: NovelTagUpdateWithWhereUniqueWithoutTagInput | NovelTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: NovelTagUpdateManyWithWhereWithoutTagInput | NovelTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: NovelTagScalarWhereInput | NovelTagScalarWhereInput[]
  }

  export type TagCreateNestedManyWithoutTagGroupInput = {
    create?: XOR<TagCreateWithoutTagGroupInput, TagUncheckedCreateWithoutTagGroupInput> | TagCreateWithoutTagGroupInput[] | TagUncheckedCreateWithoutTagGroupInput[]
    connectOrCreate?: TagCreateOrConnectWithoutTagGroupInput | TagCreateOrConnectWithoutTagGroupInput[]
    createMany?: TagCreateManyTagGroupInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutTagGroupInput = {
    create?: XOR<TagCreateWithoutTagGroupInput, TagUncheckedCreateWithoutTagGroupInput> | TagCreateWithoutTagGroupInput[] | TagUncheckedCreateWithoutTagGroupInput[]
    connectOrCreate?: TagCreateOrConnectWithoutTagGroupInput | TagCreateOrConnectWithoutTagGroupInput[]
    createMany?: TagCreateManyTagGroupInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type TagUpdateManyWithoutTagGroupNestedInput = {
    create?: XOR<TagCreateWithoutTagGroupInput, TagUncheckedCreateWithoutTagGroupInput> | TagCreateWithoutTagGroupInput[] | TagUncheckedCreateWithoutTagGroupInput[]
    connectOrCreate?: TagCreateOrConnectWithoutTagGroupInput | TagCreateOrConnectWithoutTagGroupInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutTagGroupInput | TagUpsertWithWhereUniqueWithoutTagGroupInput[]
    createMany?: TagCreateManyTagGroupInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutTagGroupInput | TagUpdateWithWhereUniqueWithoutTagGroupInput[]
    updateMany?: TagUpdateManyWithWhereWithoutTagGroupInput | TagUpdateManyWithWhereWithoutTagGroupInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutTagGroupNestedInput = {
    create?: XOR<TagCreateWithoutTagGroupInput, TagUncheckedCreateWithoutTagGroupInput> | TagCreateWithoutTagGroupInput[] | TagUncheckedCreateWithoutTagGroupInput[]
    connectOrCreate?: TagCreateOrConnectWithoutTagGroupInput | TagCreateOrConnectWithoutTagGroupInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutTagGroupInput | TagUpsertWithWhereUniqueWithoutTagGroupInput[]
    createMany?: TagCreateManyTagGroupInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutTagGroupInput | TagUpdateWithWhereUniqueWithoutTagGroupInput[]
    updateMany?: TagUpdateManyWithWhereWithoutTagGroupInput | TagUpdateManyWithWhereWithoutTagGroupInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type NovelCreateNestedOneWithoutNovelTagsInput = {
    create?: XOR<NovelCreateWithoutNovelTagsInput, NovelUncheckedCreateWithoutNovelTagsInput>
    connectOrCreate?: NovelCreateOrConnectWithoutNovelTagsInput
    connect?: NovelWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutNovelsInput = {
    create?: XOR<TagCreateWithoutNovelsInput, TagUncheckedCreateWithoutNovelsInput>
    connectOrCreate?: TagCreateOrConnectWithoutNovelsInput
    connect?: TagWhereUniqueInput
  }

  export type NovelUpdateOneRequiredWithoutNovelTagsNestedInput = {
    create?: XOR<NovelCreateWithoutNovelTagsInput, NovelUncheckedCreateWithoutNovelTagsInput>
    connectOrCreate?: NovelCreateOrConnectWithoutNovelTagsInput
    upsert?: NovelUpsertWithoutNovelTagsInput
    connect?: NovelWhereUniqueInput
    update?: XOR<XOR<NovelUpdateToOneWithWhereWithoutNovelTagsInput, NovelUpdateWithoutNovelTagsInput>, NovelUncheckedUpdateWithoutNovelTagsInput>
  }

  export type TagUpdateOneRequiredWithoutNovelsNestedInput = {
    create?: XOR<TagCreateWithoutNovelsInput, TagUncheckedCreateWithoutNovelsInput>
    connectOrCreate?: TagCreateOrConnectWithoutNovelsInput
    upsert?: TagUpsertWithoutNovelsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutNovelsInput, TagUpdateWithoutNovelsInput>, TagUncheckedUpdateWithoutNovelsInput>
  }

  export type NovelCreateNestedOneWithoutChaptersInput = {
    create?: XOR<NovelCreateWithoutChaptersInput, NovelUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: NovelCreateOrConnectWithoutChaptersInput
    connect?: NovelWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutChapterInput = {
    create?: XOR<CommentCreateWithoutChapterInput, CommentUncheckedCreateWithoutChapterInput> | CommentCreateWithoutChapterInput[] | CommentUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutChapterInput | CommentCreateOrConnectWithoutChapterInput[]
    createMany?: CommentCreateManyChapterInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ChapterStatisticCreateNestedManyWithoutChapterInput = {
    create?: XOR<ChapterStatisticCreateWithoutChapterInput, ChapterStatisticUncheckedCreateWithoutChapterInput> | ChapterStatisticCreateWithoutChapterInput[] | ChapterStatisticUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterStatisticCreateOrConnectWithoutChapterInput | ChapterStatisticCreateOrConnectWithoutChapterInput[]
    createMany?: ChapterStatisticCreateManyChapterInputEnvelope
    connect?: ChapterStatisticWhereUniqueInput | ChapterStatisticWhereUniqueInput[]
  }

  export type ReadingCreateNestedManyWithoutChapterInput = {
    create?: XOR<ReadingCreateWithoutChapterInput, ReadingUncheckedCreateWithoutChapterInput> | ReadingCreateWithoutChapterInput[] | ReadingUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ReadingCreateOrConnectWithoutChapterInput | ReadingCreateOrConnectWithoutChapterInput[]
    createMany?: ReadingCreateManyChapterInputEnvelope
    connect?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<CommentCreateWithoutChapterInput, CommentUncheckedCreateWithoutChapterInput> | CommentCreateWithoutChapterInput[] | CommentUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutChapterInput | CommentCreateOrConnectWithoutChapterInput[]
    createMany?: CommentCreateManyChapterInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ChapterStatisticUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<ChapterStatisticCreateWithoutChapterInput, ChapterStatisticUncheckedCreateWithoutChapterInput> | ChapterStatisticCreateWithoutChapterInput[] | ChapterStatisticUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterStatisticCreateOrConnectWithoutChapterInput | ChapterStatisticCreateOrConnectWithoutChapterInput[]
    createMany?: ChapterStatisticCreateManyChapterInputEnvelope
    connect?: ChapterStatisticWhereUniqueInput | ChapterStatisticWhereUniqueInput[]
  }

  export type ReadingUncheckedCreateNestedManyWithoutChapterInput = {
    create?: XOR<ReadingCreateWithoutChapterInput, ReadingUncheckedCreateWithoutChapterInput> | ReadingCreateWithoutChapterInput[] | ReadingUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ReadingCreateOrConnectWithoutChapterInput | ReadingCreateOrConnectWithoutChapterInput[]
    createMany?: ReadingCreateManyChapterInputEnvelope
    connect?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
  }

  export type NovelUpdateOneRequiredWithoutChaptersNestedInput = {
    create?: XOR<NovelCreateWithoutChaptersInput, NovelUncheckedCreateWithoutChaptersInput>
    connectOrCreate?: NovelCreateOrConnectWithoutChaptersInput
    upsert?: NovelUpsertWithoutChaptersInput
    connect?: NovelWhereUniqueInput
    update?: XOR<XOR<NovelUpdateToOneWithWhereWithoutChaptersInput, NovelUpdateWithoutChaptersInput>, NovelUncheckedUpdateWithoutChaptersInput>
  }

  export type CommentUpdateManyWithoutChapterNestedInput = {
    create?: XOR<CommentCreateWithoutChapterInput, CommentUncheckedCreateWithoutChapterInput> | CommentCreateWithoutChapterInput[] | CommentUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutChapterInput | CommentCreateOrConnectWithoutChapterInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutChapterInput | CommentUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: CommentCreateManyChapterInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutChapterInput | CommentUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutChapterInput | CommentUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ChapterStatisticUpdateManyWithoutChapterNestedInput = {
    create?: XOR<ChapterStatisticCreateWithoutChapterInput, ChapterStatisticUncheckedCreateWithoutChapterInput> | ChapterStatisticCreateWithoutChapterInput[] | ChapterStatisticUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterStatisticCreateOrConnectWithoutChapterInput | ChapterStatisticCreateOrConnectWithoutChapterInput[]
    upsert?: ChapterStatisticUpsertWithWhereUniqueWithoutChapterInput | ChapterStatisticUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: ChapterStatisticCreateManyChapterInputEnvelope
    set?: ChapterStatisticWhereUniqueInput | ChapterStatisticWhereUniqueInput[]
    disconnect?: ChapterStatisticWhereUniqueInput | ChapterStatisticWhereUniqueInput[]
    delete?: ChapterStatisticWhereUniqueInput | ChapterStatisticWhereUniqueInput[]
    connect?: ChapterStatisticWhereUniqueInput | ChapterStatisticWhereUniqueInput[]
    update?: ChapterStatisticUpdateWithWhereUniqueWithoutChapterInput | ChapterStatisticUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: ChapterStatisticUpdateManyWithWhereWithoutChapterInput | ChapterStatisticUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: ChapterStatisticScalarWhereInput | ChapterStatisticScalarWhereInput[]
  }

  export type ReadingUpdateManyWithoutChapterNestedInput = {
    create?: XOR<ReadingCreateWithoutChapterInput, ReadingUncheckedCreateWithoutChapterInput> | ReadingCreateWithoutChapterInput[] | ReadingUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ReadingCreateOrConnectWithoutChapterInput | ReadingCreateOrConnectWithoutChapterInput[]
    upsert?: ReadingUpsertWithWhereUniqueWithoutChapterInput | ReadingUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: ReadingCreateManyChapterInputEnvelope
    set?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
    disconnect?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
    delete?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
    connect?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
    update?: ReadingUpdateWithWhereUniqueWithoutChapterInput | ReadingUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: ReadingUpdateManyWithWhereWithoutChapterInput | ReadingUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: ReadingScalarWhereInput | ReadingScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<CommentCreateWithoutChapterInput, CommentUncheckedCreateWithoutChapterInput> | CommentCreateWithoutChapterInput[] | CommentUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutChapterInput | CommentCreateOrConnectWithoutChapterInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutChapterInput | CommentUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: CommentCreateManyChapterInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutChapterInput | CommentUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutChapterInput | CommentUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ChapterStatisticUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<ChapterStatisticCreateWithoutChapterInput, ChapterStatisticUncheckedCreateWithoutChapterInput> | ChapterStatisticCreateWithoutChapterInput[] | ChapterStatisticUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ChapterStatisticCreateOrConnectWithoutChapterInput | ChapterStatisticCreateOrConnectWithoutChapterInput[]
    upsert?: ChapterStatisticUpsertWithWhereUniqueWithoutChapterInput | ChapterStatisticUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: ChapterStatisticCreateManyChapterInputEnvelope
    set?: ChapterStatisticWhereUniqueInput | ChapterStatisticWhereUniqueInput[]
    disconnect?: ChapterStatisticWhereUniqueInput | ChapterStatisticWhereUniqueInput[]
    delete?: ChapterStatisticWhereUniqueInput | ChapterStatisticWhereUniqueInput[]
    connect?: ChapterStatisticWhereUniqueInput | ChapterStatisticWhereUniqueInput[]
    update?: ChapterStatisticUpdateWithWhereUniqueWithoutChapterInput | ChapterStatisticUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: ChapterStatisticUpdateManyWithWhereWithoutChapterInput | ChapterStatisticUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: ChapterStatisticScalarWhereInput | ChapterStatisticScalarWhereInput[]
  }

  export type ReadingUncheckedUpdateManyWithoutChapterNestedInput = {
    create?: XOR<ReadingCreateWithoutChapterInput, ReadingUncheckedCreateWithoutChapterInput> | ReadingCreateWithoutChapterInput[] | ReadingUncheckedCreateWithoutChapterInput[]
    connectOrCreate?: ReadingCreateOrConnectWithoutChapterInput | ReadingCreateOrConnectWithoutChapterInput[]
    upsert?: ReadingUpsertWithWhereUniqueWithoutChapterInput | ReadingUpsertWithWhereUniqueWithoutChapterInput[]
    createMany?: ReadingCreateManyChapterInputEnvelope
    set?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
    disconnect?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
    delete?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
    connect?: ReadingWhereUniqueInput | ReadingWhereUniqueInput[]
    update?: ReadingUpdateWithWhereUniqueWithoutChapterInput | ReadingUpdateWithWhereUniqueWithoutChapterInput[]
    updateMany?: ReadingUpdateManyWithWhereWithoutChapterInput | ReadingUpdateManyWithWhereWithoutChapterInput[]
    deleteMany?: ReadingScalarWhereInput | ReadingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type NovelCreateNestedOneWithoutReviewsInput = {
    create?: XOR<NovelCreateWithoutReviewsInput, NovelUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: NovelCreateOrConnectWithoutReviewsInput
    connect?: NovelWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type NovelUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<NovelCreateWithoutReviewsInput, NovelUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: NovelCreateOrConnectWithoutReviewsInput
    upsert?: NovelUpsertWithoutReviewsInput
    connect?: NovelWhereUniqueInput
    update?: XOR<XOR<NovelUpdateToOneWithWhereWithoutReviewsInput, NovelUpdateWithoutReviewsInput>, NovelUncheckedUpdateWithoutReviewsInput>
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type ChapterCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ChapterCreateWithoutCommentsInput, ChapterUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutCommentsInput
    connect?: ChapterWhereUniqueInput
  }

  export type ReplyCommentCreateNestedManyWithoutCommentInput = {
    create?: XOR<ReplyCommentCreateWithoutCommentInput, ReplyCommentUncheckedCreateWithoutCommentInput> | ReplyCommentCreateWithoutCommentInput[] | ReplyCommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ReplyCommentCreateOrConnectWithoutCommentInput | ReplyCommentCreateOrConnectWithoutCommentInput[]
    createMany?: ReplyCommentCreateManyCommentInputEnvelope
    connect?: ReplyCommentWhereUniqueInput | ReplyCommentWhereUniqueInput[]
  }

  export type NovelCreateNestedOneWithoutCommentsInput = {
    create?: XOR<NovelCreateWithoutCommentsInput, NovelUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: NovelCreateOrConnectWithoutCommentsInput
    connect?: NovelWhereUniqueInput
  }

  export type ReplyCommentUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<ReplyCommentCreateWithoutCommentInput, ReplyCommentUncheckedCreateWithoutCommentInput> | ReplyCommentCreateWithoutCommentInput[] | ReplyCommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ReplyCommentCreateOrConnectWithoutCommentInput | ReplyCommentCreateOrConnectWithoutCommentInput[]
    createMany?: ReplyCommentCreateManyCommentInputEnvelope
    connect?: ReplyCommentWhereUniqueInput | ReplyCommentWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type ChapterUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ChapterCreateWithoutCommentsInput, ChapterUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutCommentsInput
    upsert?: ChapterUpsertWithoutCommentsInput
    connect?: ChapterWhereUniqueInput
    update?: XOR<XOR<ChapterUpdateToOneWithWhereWithoutCommentsInput, ChapterUpdateWithoutCommentsInput>, ChapterUncheckedUpdateWithoutCommentsInput>
  }

  export type ReplyCommentUpdateManyWithoutCommentNestedInput = {
    create?: XOR<ReplyCommentCreateWithoutCommentInput, ReplyCommentUncheckedCreateWithoutCommentInput> | ReplyCommentCreateWithoutCommentInput[] | ReplyCommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ReplyCommentCreateOrConnectWithoutCommentInput | ReplyCommentCreateOrConnectWithoutCommentInput[]
    upsert?: ReplyCommentUpsertWithWhereUniqueWithoutCommentInput | ReplyCommentUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: ReplyCommentCreateManyCommentInputEnvelope
    set?: ReplyCommentWhereUniqueInput | ReplyCommentWhereUniqueInput[]
    disconnect?: ReplyCommentWhereUniqueInput | ReplyCommentWhereUniqueInput[]
    delete?: ReplyCommentWhereUniqueInput | ReplyCommentWhereUniqueInput[]
    connect?: ReplyCommentWhereUniqueInput | ReplyCommentWhereUniqueInput[]
    update?: ReplyCommentUpdateWithWhereUniqueWithoutCommentInput | ReplyCommentUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: ReplyCommentUpdateManyWithWhereWithoutCommentInput | ReplyCommentUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: ReplyCommentScalarWhereInput | ReplyCommentScalarWhereInput[]
  }

  export type NovelUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<NovelCreateWithoutCommentsInput, NovelUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: NovelCreateOrConnectWithoutCommentsInput
    upsert?: NovelUpsertWithoutCommentsInput
    disconnect?: NovelWhereInput | boolean
    delete?: NovelWhereInput | boolean
    connect?: NovelWhereUniqueInput
    update?: XOR<XOR<NovelUpdateToOneWithWhereWithoutCommentsInput, NovelUpdateWithoutCommentsInput>, NovelUncheckedUpdateWithoutCommentsInput>
  }

  export type ReplyCommentUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<ReplyCommentCreateWithoutCommentInput, ReplyCommentUncheckedCreateWithoutCommentInput> | ReplyCommentCreateWithoutCommentInput[] | ReplyCommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ReplyCommentCreateOrConnectWithoutCommentInput | ReplyCommentCreateOrConnectWithoutCommentInput[]
    upsert?: ReplyCommentUpsertWithWhereUniqueWithoutCommentInput | ReplyCommentUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: ReplyCommentCreateManyCommentInputEnvelope
    set?: ReplyCommentWhereUniqueInput | ReplyCommentWhereUniqueInput[]
    disconnect?: ReplyCommentWhereUniqueInput | ReplyCommentWhereUniqueInput[]
    delete?: ReplyCommentWhereUniqueInput | ReplyCommentWhereUniqueInput[]
    connect?: ReplyCommentWhereUniqueInput | ReplyCommentWhereUniqueInput[]
    update?: ReplyCommentUpdateWithWhereUniqueWithoutCommentInput | ReplyCommentUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: ReplyCommentUpdateManyWithWhereWithoutCommentInput | ReplyCommentUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: ReplyCommentScalarWhereInput | ReplyCommentScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRepliesInput = {
    create?: XOR<UserCreateWithoutRepliesInput, UserUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRepliesInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    connect?: CommentWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRepliesNestedInput = {
    create?: XOR<UserCreateWithoutRepliesInput, UserUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRepliesInput
    upsert?: UserUpsertWithoutRepliesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRepliesInput, UserUpdateWithoutRepliesInput>, UserUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateOneRequiredWithoutRepliesNestedInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    upsert?: CommentUpsertWithoutRepliesInput
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutRepliesInput, CommentUpdateWithoutRepliesInput>, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type UserCreateNestedOneWithoutReadingsInput = {
    create?: XOR<UserCreateWithoutReadingsInput, UserUncheckedCreateWithoutReadingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReadingsInput
    connect?: UserWhereUniqueInput
  }

  export type NovelCreateNestedOneWithoutReadersInput = {
    create?: XOR<NovelCreateWithoutReadersInput, NovelUncheckedCreateWithoutReadersInput>
    connectOrCreate?: NovelCreateOrConnectWithoutReadersInput
    connect?: NovelWhereUniqueInput
  }

  export type ChapterCreateNestedOneWithoutReadingInput = {
    create?: XOR<ChapterCreateWithoutReadingInput, ChapterUncheckedCreateWithoutReadingInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutReadingInput
    connect?: ChapterWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReadingsNestedInput = {
    create?: XOR<UserCreateWithoutReadingsInput, UserUncheckedCreateWithoutReadingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReadingsInput
    upsert?: UserUpsertWithoutReadingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReadingsInput, UserUpdateWithoutReadingsInput>, UserUncheckedUpdateWithoutReadingsInput>
  }

  export type NovelUpdateOneRequiredWithoutReadersNestedInput = {
    create?: XOR<NovelCreateWithoutReadersInput, NovelUncheckedCreateWithoutReadersInput>
    connectOrCreate?: NovelCreateOrConnectWithoutReadersInput
    upsert?: NovelUpsertWithoutReadersInput
    connect?: NovelWhereUniqueInput
    update?: XOR<XOR<NovelUpdateToOneWithWhereWithoutReadersInput, NovelUpdateWithoutReadersInput>, NovelUncheckedUpdateWithoutReadersInput>
  }

  export type ChapterUpdateOneRequiredWithoutReadingNestedInput = {
    create?: XOR<ChapterCreateWithoutReadingInput, ChapterUncheckedCreateWithoutReadingInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutReadingInput
    upsert?: ChapterUpsertWithoutReadingInput
    connect?: ChapterWhereUniqueInput
    update?: XOR<XOR<ChapterUpdateToOneWithWhereWithoutReadingInput, ChapterUpdateWithoutReadingInput>, ChapterUncheckedUpdateWithoutReadingInput>
  }

  export type UserCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoritesInput
    connect?: UserWhereUniqueInput
  }

  export type NovelCreateNestedOneWithoutFavoritesInput = {
    create?: XOR<NovelCreateWithoutFavoritesInput, NovelUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: NovelCreateOrConnectWithoutFavoritesInput
    connect?: NovelWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFavoritesInput
    upsert?: UserUpsertWithoutFavoritesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFavoritesInput, UserUpdateWithoutFavoritesInput>, UserUncheckedUpdateWithoutFavoritesInput>
  }

  export type NovelUpdateOneRequiredWithoutFavoritesNestedInput = {
    create?: XOR<NovelCreateWithoutFavoritesInput, NovelUncheckedCreateWithoutFavoritesInput>
    connectOrCreate?: NovelCreateOrConnectWithoutFavoritesInput
    upsert?: NovelUpsertWithoutFavoritesInput
    connect?: NovelWhereUniqueInput
    update?: XOR<XOR<NovelUpdateToOneWithWhereWithoutFavoritesInput, NovelUpdateWithoutFavoritesInput>, NovelUncheckedUpdateWithoutFavoritesInput>
  }

  export type NovelCreateNestedOneWithoutStatisticsInput = {
    create?: XOR<NovelCreateWithoutStatisticsInput, NovelUncheckedCreateWithoutStatisticsInput>
    connectOrCreate?: NovelCreateOrConnectWithoutStatisticsInput
    connect?: NovelWhereUniqueInput
  }

  export type NovelUpdateOneRequiredWithoutStatisticsNestedInput = {
    create?: XOR<NovelCreateWithoutStatisticsInput, NovelUncheckedCreateWithoutStatisticsInput>
    connectOrCreate?: NovelCreateOrConnectWithoutStatisticsInput
    upsert?: NovelUpsertWithoutStatisticsInput
    connect?: NovelWhereUniqueInput
    update?: XOR<XOR<NovelUpdateToOneWithWhereWithoutStatisticsInput, NovelUpdateWithoutStatisticsInput>, NovelUncheckedUpdateWithoutStatisticsInput>
  }

  export type ChapterCreateNestedOneWithoutStatisticsInput = {
    create?: XOR<ChapterCreateWithoutStatisticsInput, ChapterUncheckedCreateWithoutStatisticsInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutStatisticsInput
    connect?: ChapterWhereUniqueInput
  }

  export type ChapterUpdateOneRequiredWithoutStatisticsNestedInput = {
    create?: XOR<ChapterCreateWithoutStatisticsInput, ChapterUncheckedCreateWithoutStatisticsInput>
    connectOrCreate?: ChapterCreateOrConnectWithoutStatisticsInput
    upsert?: ChapterUpsertWithoutStatisticsInput
    connect?: ChapterWhereUniqueInput
    update?: XOR<XOR<ChapterUpdateToOneWithWhereWithoutStatisticsInput, ChapterUpdateWithoutStatisticsInput>, ChapterUncheckedUpdateWithoutStatisticsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumNovelKindFilter<$PrismaModel = never> = {
    equals?: $Enums.NovelKind | EnumNovelKindFieldRefInput<$PrismaModel>
    in?: $Enums.NovelKind[] | ListEnumNovelKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.NovelKind[] | ListEnumNovelKindFieldRefInput<$PrismaModel>
    not?: NestedEnumNovelKindFilter<$PrismaModel> | $Enums.NovelKind
  }

  export type NestedEnumNovelStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NovelStatus | EnumNovelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NovelStatus[] | ListEnumNovelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NovelStatus[] | ListEnumNovelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNovelStatusFilter<$PrismaModel> | $Enums.NovelStatus
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumNovelKindWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NovelKind | EnumNovelKindFieldRefInput<$PrismaModel>
    in?: $Enums.NovelKind[] | ListEnumNovelKindFieldRefInput<$PrismaModel>
    notIn?: $Enums.NovelKind[] | ListEnumNovelKindFieldRefInput<$PrismaModel>
    not?: NestedEnumNovelKindWithAggregatesFilter<$PrismaModel> | $Enums.NovelKind
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNovelKindFilter<$PrismaModel>
    _max?: NestedEnumNovelKindFilter<$PrismaModel>
  }

  export type NestedEnumNovelStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NovelStatus | EnumNovelStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NovelStatus[] | ListEnumNovelStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NovelStatus[] | ListEnumNovelStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNovelStatusWithAggregatesFilter<$PrismaModel> | $Enums.NovelStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNovelStatusFilter<$PrismaModel>
    _max?: NestedEnumNovelStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NotificationSettingsCreateWithoutUserInput = {
    enableNewChapter?: boolean
    enableInteractions?: boolean
  }

  export type NotificationSettingsUncheckedCreateWithoutUserInput = {
    enableNewChapter?: boolean
    enableInteractions?: boolean
  }

  export type NotificationSettingsCreateOrConnectWithoutUserInput = {
    where: NotificationSettingsWhereUniqueInput
    create: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateWithoutUserInput = {
    rating: number
    content: string
    isSpoiler?: boolean
    createdAt?: Date | string
    novel: NovelCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: number
    rating: number
    content: string
    isSpoiler?: boolean
    novelId: number
    createdAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    content: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    chapter: ChapterCreateNestedOneWithoutCommentsInput
    replies?: ReplyCommentCreateNestedManyWithoutCommentInput
    Novel?: NovelCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: number
    content: string
    likes?: number
    chapterId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    novelId?: number | null
    replies?: ReplyCommentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NovelCreateWithoutCreatedByInput = {
    title: string
    originalTitle?: string | null
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status?: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount?: number
    totalChapters?: number
    publishedAt?: Date | string | null
    newChapterAt?: Date | string
    createdAt?: Date | string
    author?: AuthorCreateNestedOneWithoutNovelsInput
    genre: GenreCreateNestedOneWithoutNovelsInput
    chapters?: ChapterCreateNestedManyWithoutNovelInput
    novelTags?: NovelTagCreateNestedManyWithoutNovelInput
    reviews?: ReviewCreateNestedManyWithoutNovelInput
    statistics?: NovelStatisticCreateNestedManyWithoutNovelInput
    readers?: ReadingCreateNestedManyWithoutNovelInput
    favorites?: FavoriteCreateNestedManyWithoutNovelInput
    comments?: CommentCreateNestedManyWithoutNovelInput
  }

  export type NovelUncheckedCreateWithoutCreatedByInput = {
    id?: number
    title: string
    originalTitle?: string | null
    authorId?: number | null
    genreId: number
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status?: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount?: number
    totalChapters?: number
    publishedAt?: Date | string | null
    newChapterAt?: Date | string
    createdAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutNovelInput
    novelTags?: NovelTagUncheckedCreateNestedManyWithoutNovelInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutNovelInput
    statistics?: NovelStatisticUncheckedCreateNestedManyWithoutNovelInput
    readers?: ReadingUncheckedCreateNestedManyWithoutNovelInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutNovelInput
    comments?: CommentUncheckedCreateNestedManyWithoutNovelInput
  }

  export type NovelCreateOrConnectWithoutCreatedByInput = {
    where: NovelWhereUniqueInput
    create: XOR<NovelCreateWithoutCreatedByInput, NovelUncheckedCreateWithoutCreatedByInput>
  }

  export type NovelCreateManyCreatedByInputEnvelope = {
    data: NovelCreateManyCreatedByInput | NovelCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    token?: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    token?: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReadingCreateWithoutUserInput = {
    lastRead?: Date | string
    novel: NovelCreateNestedOneWithoutReadersInput
    chapter: ChapterCreateNestedOneWithoutReadingInput
  }

  export type ReadingUncheckedCreateWithoutUserInput = {
    novelId: number
    chapterId: number
    lastRead?: Date | string
  }

  export type ReadingCreateOrConnectWithoutUserInput = {
    where: ReadingWhereUniqueInput
    create: XOR<ReadingCreateWithoutUserInput, ReadingUncheckedCreateWithoutUserInput>
  }

  export type ReadingCreateManyUserInputEnvelope = {
    data: ReadingCreateManyUserInput | ReadingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteCreateWithoutUserInput = {
    createdAt?: Date | string
    novel: NovelCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteUncheckedCreateWithoutUserInput = {
    novelId: number
    createdAt?: Date | string
  }

  export type FavoriteCreateOrConnectWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    create: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput>
  }

  export type FavoriteCreateManyUserInputEnvelope = {
    data: FavoriteCreateManyUserInput | FavoriteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReplyCommentCreateWithoutUserInput = {
    content: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comment: CommentCreateNestedOneWithoutRepliesInput
  }

  export type ReplyCommentUncheckedCreateWithoutUserInput = {
    id?: number
    content: string
    likes?: number
    commentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReplyCommentCreateOrConnectWithoutUserInput = {
    where: ReplyCommentWhereUniqueInput
    create: XOR<ReplyCommentCreateWithoutUserInput, ReplyCommentUncheckedCreateWithoutUserInput>
  }

  export type ReplyCommentCreateManyUserInputEnvelope = {
    data: ReplyCommentCreateManyUserInput | ReplyCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationSettingsUpsertWithoutUserInput = {
    update: XOR<NotificationSettingsUpdateWithoutUserInput, NotificationSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationSettingsCreateWithoutUserInput, NotificationSettingsUncheckedCreateWithoutUserInput>
    where?: NotificationSettingsWhereInput
  }

  export type NotificationSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: NotificationSettingsWhereInput
    data: XOR<NotificationSettingsUpdateWithoutUserInput, NotificationSettingsUncheckedUpdateWithoutUserInput>
  }

  export type NotificationSettingsUpdateWithoutUserInput = {
    enableNewChapter?: BoolFieldUpdateOperationsInput | boolean
    enableInteractions?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationSettingsUncheckedUpdateWithoutUserInput = {
    enableNewChapter?: BoolFieldUpdateOperationsInput | boolean
    enableInteractions?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: IntFilter<"Review"> | number
    rating?: FloatFilter<"Review"> | number
    content?: StringFilter<"Review"> | string
    isSpoiler?: BoolFilter<"Review"> | boolean
    userId?: IntFilter<"Review"> | number
    novelId?: IntFilter<"Review"> | number
    createdAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: IntFilter<"Comment"> | number
    content?: StringFilter<"Comment"> | string
    likes?: IntFilter<"Comment"> | number
    userId?: IntFilter<"Comment"> | number
    chapterId?: IntFilter<"Comment"> | number
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    novelId?: IntNullableFilter<"Comment"> | number | null
  }

  export type NovelUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: NovelWhereUniqueInput
    update: XOR<NovelUpdateWithoutCreatedByInput, NovelUncheckedUpdateWithoutCreatedByInput>
    create: XOR<NovelCreateWithoutCreatedByInput, NovelUncheckedCreateWithoutCreatedByInput>
  }

  export type NovelUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: NovelWhereUniqueInput
    data: XOR<NovelUpdateWithoutCreatedByInput, NovelUncheckedUpdateWithoutCreatedByInput>
  }

  export type NovelUpdateManyWithWhereWithoutCreatedByInput = {
    where: NovelScalarWhereInput
    data: XOR<NovelUpdateManyMutationInput, NovelUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type NovelScalarWhereInput = {
    AND?: NovelScalarWhereInput | NovelScalarWhereInput[]
    OR?: NovelScalarWhereInput[]
    NOT?: NovelScalarWhereInput | NovelScalarWhereInput[]
    id?: IntFilter<"Novel"> | number
    title?: StringFilter<"Novel"> | string
    originalTitle?: StringNullableFilter<"Novel"> | string | null
    authorId?: IntNullableFilter<"Novel"> | number | null
    createdById?: IntFilter<"Novel"> | number
    genreId?: IntFilter<"Novel"> | number
    kind?: EnumNovelKindFilter<"Novel"> | $Enums.NovelKind
    gender?: EnumGenderFilter<"Novel"> | $Enums.Gender
    status?: EnumNovelStatusFilter<"Novel"> | $Enums.NovelStatus
    synopsis?: StringFilter<"Novel"> | string
    coverImage?: StringFilter<"Novel"> | string
    wordCount?: IntFilter<"Novel"> | number
    totalChapters?: IntFilter<"Novel"> | number
    publishedAt?: DateTimeNullableFilter<"Novel"> | Date | string | null
    newChapterAt?: DateTimeFilter<"Novel"> | Date | string
    createdAt?: DateTimeFilter<"Novel"> | Date | string
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    token?: UuidFilter<"RefreshToken"> | string
    userId?: IntFilter<"RefreshToken"> | number
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type ReadingUpsertWithWhereUniqueWithoutUserInput = {
    where: ReadingWhereUniqueInput
    update: XOR<ReadingUpdateWithoutUserInput, ReadingUncheckedUpdateWithoutUserInput>
    create: XOR<ReadingCreateWithoutUserInput, ReadingUncheckedCreateWithoutUserInput>
  }

  export type ReadingUpdateWithWhereUniqueWithoutUserInput = {
    where: ReadingWhereUniqueInput
    data: XOR<ReadingUpdateWithoutUserInput, ReadingUncheckedUpdateWithoutUserInput>
  }

  export type ReadingUpdateManyWithWhereWithoutUserInput = {
    where: ReadingScalarWhereInput
    data: XOR<ReadingUpdateManyMutationInput, ReadingUncheckedUpdateManyWithoutUserInput>
  }

  export type ReadingScalarWhereInput = {
    AND?: ReadingScalarWhereInput | ReadingScalarWhereInput[]
    OR?: ReadingScalarWhereInput[]
    NOT?: ReadingScalarWhereInput | ReadingScalarWhereInput[]
    userId?: IntFilter<"Reading"> | number
    novelId?: IntFilter<"Reading"> | number
    chapterId?: IntFilter<"Reading"> | number
    lastRead?: DateTimeFilter<"Reading"> | Date | string
  }

  export type FavoriteUpsertWithWhereUniqueWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    update: XOR<FavoriteUpdateWithoutUserInput, FavoriteUncheckedUpdateWithoutUserInput>
    create: XOR<FavoriteCreateWithoutUserInput, FavoriteUncheckedCreateWithoutUserInput>
  }

  export type FavoriteUpdateWithWhereUniqueWithoutUserInput = {
    where: FavoriteWhereUniqueInput
    data: XOR<FavoriteUpdateWithoutUserInput, FavoriteUncheckedUpdateWithoutUserInput>
  }

  export type FavoriteUpdateManyWithWhereWithoutUserInput = {
    where: FavoriteScalarWhereInput
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyWithoutUserInput>
  }

  export type FavoriteScalarWhereInput = {
    AND?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
    OR?: FavoriteScalarWhereInput[]
    NOT?: FavoriteScalarWhereInput | FavoriteScalarWhereInput[]
    userId?: IntFilter<"Favorite"> | number
    novelId?: IntFilter<"Favorite"> | number
    createdAt?: DateTimeFilter<"Favorite"> | Date | string
  }

  export type ReplyCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: ReplyCommentWhereUniqueInput
    update: XOR<ReplyCommentUpdateWithoutUserInput, ReplyCommentUncheckedUpdateWithoutUserInput>
    create: XOR<ReplyCommentCreateWithoutUserInput, ReplyCommentUncheckedCreateWithoutUserInput>
  }

  export type ReplyCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: ReplyCommentWhereUniqueInput
    data: XOR<ReplyCommentUpdateWithoutUserInput, ReplyCommentUncheckedUpdateWithoutUserInput>
  }

  export type ReplyCommentUpdateManyWithWhereWithoutUserInput = {
    where: ReplyCommentScalarWhereInput
    data: XOR<ReplyCommentUpdateManyMutationInput, ReplyCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type ReplyCommentScalarWhereInput = {
    AND?: ReplyCommentScalarWhereInput | ReplyCommentScalarWhereInput[]
    OR?: ReplyCommentScalarWhereInput[]
    NOT?: ReplyCommentScalarWhereInput | ReplyCommentScalarWhereInput[]
    id?: IntFilter<"ReplyComment"> | number
    content?: StringFilter<"ReplyComment"> | string
    likes?: IntFilter<"ReplyComment"> | number
    userId?: IntFilter<"ReplyComment"> | number
    commentId?: IntFilter<"ReplyComment"> | number
    createdAt?: DateTimeFilter<"ReplyComment"> | Date | string
    updatedAt?: DateTimeFilter<"ReplyComment"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    nickname: string
    email: string
    password?: string | null
    phone?: string
    avatar?: string
    coverImage?: string
    role?: $Enums.UserRole
    gender?: $Enums.Gender
    bio?: string
    birthDate?: Date | string
    socialLinks?: UserCreatesocialLinksInput | string[]
    keys?: number
    tickets?: number
    candies?: number
    createdAt?: Date | string
    emailVerifiedAt?: Date | string | null
    isTwoFactorAuth?: boolean
    notifications?: NotificationSettingsCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    authoredNovels?: NovelCreateNestedManyWithoutCreatedByInput
    readings?: ReadingCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    replies?: ReplyCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: number
    nickname: string
    email: string
    password?: string | null
    phone?: string
    avatar?: string
    coverImage?: string
    role?: $Enums.UserRole
    gender?: $Enums.Gender
    bio?: string
    birthDate?: Date | string
    socialLinks?: UserCreatesocialLinksInput | string[]
    keys?: number
    tickets?: number
    candies?: number
    createdAt?: Date | string
    emailVerifiedAt?: Date | string | null
    isTwoFactorAuth?: boolean
    notifications?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    authoredNovels?: NovelUncheckedCreateNestedManyWithoutCreatedByInput
    readings?: ReadingUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    bio?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: UserUpdatesocialLinksInput | string[]
    keys?: IntFieldUpdateOperationsInput | number
    tickets?: IntFieldUpdateOperationsInput | number
    candies?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTwoFactorAuth?: BoolFieldUpdateOperationsInput | boolean
    notifications?: NotificationSettingsUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    authoredNovels?: NovelUpdateManyWithoutCreatedByNestedInput
    readings?: ReadingUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    replies?: ReplyCommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    bio?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: UserUpdatesocialLinksInput | string[]
    keys?: IntFieldUpdateOperationsInput | number
    tickets?: IntFieldUpdateOperationsInput | number
    candies?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTwoFactorAuth?: BoolFieldUpdateOperationsInput | boolean
    notifications?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    authoredNovels?: NovelUncheckedUpdateManyWithoutCreatedByNestedInput
    readings?: ReadingUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    nickname: string
    email: string
    password?: string | null
    phone?: string
    avatar?: string
    coverImage?: string
    role?: $Enums.UserRole
    gender?: $Enums.Gender
    bio?: string
    birthDate?: Date | string
    socialLinks?: UserCreatesocialLinksInput | string[]
    keys?: number
    tickets?: number
    candies?: number
    createdAt?: Date | string
    emailVerifiedAt?: Date | string | null
    isTwoFactorAuth?: boolean
    reviews?: ReviewCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    authoredNovels?: NovelCreateNestedManyWithoutCreatedByInput
    sessions?: RefreshTokenCreateNestedManyWithoutUserInput
    readings?: ReadingCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    replies?: ReplyCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    nickname: string
    email: string
    password?: string | null
    phone?: string
    avatar?: string
    coverImage?: string
    role?: $Enums.UserRole
    gender?: $Enums.Gender
    bio?: string
    birthDate?: Date | string
    socialLinks?: UserCreatesocialLinksInput | string[]
    keys?: number
    tickets?: number
    candies?: number
    createdAt?: Date | string
    emailVerifiedAt?: Date | string | null
    isTwoFactorAuth?: boolean
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    authoredNovels?: NovelUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    readings?: ReadingUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    bio?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: UserUpdatesocialLinksInput | string[]
    keys?: IntFieldUpdateOperationsInput | number
    tickets?: IntFieldUpdateOperationsInput | number
    candies?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTwoFactorAuth?: BoolFieldUpdateOperationsInput | boolean
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    authoredNovels?: NovelUpdateManyWithoutCreatedByNestedInput
    sessions?: RefreshTokenUpdateManyWithoutUserNestedInput
    readings?: ReadingUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    replies?: ReplyCommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    bio?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: UserUpdatesocialLinksInput | string[]
    keys?: IntFieldUpdateOperationsInput | number
    tickets?: IntFieldUpdateOperationsInput | number
    candies?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTwoFactorAuth?: BoolFieldUpdateOperationsInput | boolean
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    authoredNovels?: NovelUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    readings?: ReadingUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NovelCreateWithoutAuthorInput = {
    title: string
    originalTitle?: string | null
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status?: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount?: number
    totalChapters?: number
    publishedAt?: Date | string | null
    newChapterAt?: Date | string
    createdAt?: Date | string
    createdBy: UserCreateNestedOneWithoutAuthoredNovelsInput
    genre: GenreCreateNestedOneWithoutNovelsInput
    chapters?: ChapterCreateNestedManyWithoutNovelInput
    novelTags?: NovelTagCreateNestedManyWithoutNovelInput
    reviews?: ReviewCreateNestedManyWithoutNovelInput
    statistics?: NovelStatisticCreateNestedManyWithoutNovelInput
    readers?: ReadingCreateNestedManyWithoutNovelInput
    favorites?: FavoriteCreateNestedManyWithoutNovelInput
    comments?: CommentCreateNestedManyWithoutNovelInput
  }

  export type NovelUncheckedCreateWithoutAuthorInput = {
    id?: number
    title: string
    originalTitle?: string | null
    createdById: number
    genreId: number
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status?: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount?: number
    totalChapters?: number
    publishedAt?: Date | string | null
    newChapterAt?: Date | string
    createdAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutNovelInput
    novelTags?: NovelTagUncheckedCreateNestedManyWithoutNovelInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutNovelInput
    statistics?: NovelStatisticUncheckedCreateNestedManyWithoutNovelInput
    readers?: ReadingUncheckedCreateNestedManyWithoutNovelInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutNovelInput
    comments?: CommentUncheckedCreateNestedManyWithoutNovelInput
  }

  export type NovelCreateOrConnectWithoutAuthorInput = {
    where: NovelWhereUniqueInput
    create: XOR<NovelCreateWithoutAuthorInput, NovelUncheckedCreateWithoutAuthorInput>
  }

  export type NovelCreateManyAuthorInputEnvelope = {
    data: NovelCreateManyAuthorInput | NovelCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type NovelUpsertWithWhereUniqueWithoutAuthorInput = {
    where: NovelWhereUniqueInput
    update: XOR<NovelUpdateWithoutAuthorInput, NovelUncheckedUpdateWithoutAuthorInput>
    create: XOR<NovelCreateWithoutAuthorInput, NovelUncheckedCreateWithoutAuthorInput>
  }

  export type NovelUpdateWithWhereUniqueWithoutAuthorInput = {
    where: NovelWhereUniqueInput
    data: XOR<NovelUpdateWithoutAuthorInput, NovelUncheckedUpdateWithoutAuthorInput>
  }

  export type NovelUpdateManyWithWhereWithoutAuthorInput = {
    where: NovelScalarWhereInput
    data: XOR<NovelUpdateManyMutationInput, NovelUncheckedUpdateManyWithoutAuthorInput>
  }

  export type AuthorCreateWithoutNovelsInput = {
    name: string
    originalName: string
    country: string
  }

  export type AuthorUncheckedCreateWithoutNovelsInput = {
    id?: number
    name: string
    originalName: string
    country: string
  }

  export type AuthorCreateOrConnectWithoutNovelsInput = {
    where: AuthorWhereUniqueInput
    create: XOR<AuthorCreateWithoutNovelsInput, AuthorUncheckedCreateWithoutNovelsInput>
  }

  export type UserCreateWithoutAuthoredNovelsInput = {
    nickname: string
    email: string
    password?: string | null
    phone?: string
    avatar?: string
    coverImage?: string
    role?: $Enums.UserRole
    gender?: $Enums.Gender
    bio?: string
    birthDate?: Date | string
    socialLinks?: UserCreatesocialLinksInput | string[]
    keys?: number
    tickets?: number
    candies?: number
    createdAt?: Date | string
    emailVerifiedAt?: Date | string | null
    isTwoFactorAuth?: boolean
    notifications?: NotificationSettingsCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    sessions?: RefreshTokenCreateNestedManyWithoutUserInput
    readings?: ReadingCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    replies?: ReplyCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuthoredNovelsInput = {
    id?: number
    nickname: string
    email: string
    password?: string | null
    phone?: string
    avatar?: string
    coverImage?: string
    role?: $Enums.UserRole
    gender?: $Enums.Gender
    bio?: string
    birthDate?: Date | string
    socialLinks?: UserCreatesocialLinksInput | string[]
    keys?: number
    tickets?: number
    candies?: number
    createdAt?: Date | string
    emailVerifiedAt?: Date | string | null
    isTwoFactorAuth?: boolean
    notifications?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    sessions?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    readings?: ReadingUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuthoredNovelsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuthoredNovelsInput, UserUncheckedCreateWithoutAuthoredNovelsInput>
  }

  export type GenreCreateWithoutNovelsInput = {
    name: string
  }

  export type GenreUncheckedCreateWithoutNovelsInput = {
    id?: number
    name: string
  }

  export type GenreCreateOrConnectWithoutNovelsInput = {
    where: GenreWhereUniqueInput
    create: XOR<GenreCreateWithoutNovelsInput, GenreUncheckedCreateWithoutNovelsInput>
  }

  export type ChapterCreateWithoutNovelInput = {
    chapterNumber: number
    title: string
    content: string
    isLocked?: boolean
    unlockCost?: number
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutChapterInput
    statistics?: ChapterStatisticCreateNestedManyWithoutChapterInput
    reading?: ReadingCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutNovelInput = {
    id?: number
    chapterNumber: number
    title: string
    content: string
    isLocked?: boolean
    unlockCost?: number
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutChapterInput
    statistics?: ChapterStatisticUncheckedCreateNestedManyWithoutChapterInput
    reading?: ReadingUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutNovelInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutNovelInput, ChapterUncheckedCreateWithoutNovelInput>
  }

  export type ChapterCreateManyNovelInputEnvelope = {
    data: ChapterCreateManyNovelInput | ChapterCreateManyNovelInput[]
    skipDuplicates?: boolean
  }

  export type NovelTagCreateWithoutNovelInput = {
    tag: TagCreateNestedOneWithoutNovelsInput
  }

  export type NovelTagUncheckedCreateWithoutNovelInput = {
    tagId: number
  }

  export type NovelTagCreateOrConnectWithoutNovelInput = {
    where: NovelTagWhereUniqueInput
    create: XOR<NovelTagCreateWithoutNovelInput, NovelTagUncheckedCreateWithoutNovelInput>
  }

  export type NovelTagCreateManyNovelInputEnvelope = {
    data: NovelTagCreateManyNovelInput | NovelTagCreateManyNovelInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutNovelInput = {
    rating: number
    content: string
    isSpoiler?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutNovelInput = {
    id?: number
    rating: number
    content: string
    isSpoiler?: boolean
    userId: number
    createdAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutNovelInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutNovelInput, ReviewUncheckedCreateWithoutNovelInput>
  }

  export type ReviewCreateManyNovelInputEnvelope = {
    data: ReviewCreateManyNovelInput | ReviewCreateManyNovelInput[]
    skipDuplicates?: boolean
  }

  export type NovelStatisticCreateWithoutNovelInput = {
    dailyViews?: number
    totalViews?: number
    reviews?: number
    comments?: number
    date: Date | string
  }

  export type NovelStatisticUncheckedCreateWithoutNovelInput = {
    id?: number
    dailyViews?: number
    totalViews?: number
    reviews?: number
    comments?: number
    date: Date | string
  }

  export type NovelStatisticCreateOrConnectWithoutNovelInput = {
    where: NovelStatisticWhereUniqueInput
    create: XOR<NovelStatisticCreateWithoutNovelInput, NovelStatisticUncheckedCreateWithoutNovelInput>
  }

  export type NovelStatisticCreateManyNovelInputEnvelope = {
    data: NovelStatisticCreateManyNovelInput | NovelStatisticCreateManyNovelInput[]
    skipDuplicates?: boolean
  }

  export type ReadingCreateWithoutNovelInput = {
    lastRead?: Date | string
    user: UserCreateNestedOneWithoutReadingsInput
    chapter: ChapterCreateNestedOneWithoutReadingInput
  }

  export type ReadingUncheckedCreateWithoutNovelInput = {
    userId: number
    chapterId: number
    lastRead?: Date | string
  }

  export type ReadingCreateOrConnectWithoutNovelInput = {
    where: ReadingWhereUniqueInput
    create: XOR<ReadingCreateWithoutNovelInput, ReadingUncheckedCreateWithoutNovelInput>
  }

  export type ReadingCreateManyNovelInputEnvelope = {
    data: ReadingCreateManyNovelInput | ReadingCreateManyNovelInput[]
    skipDuplicates?: boolean
  }

  export type FavoriteCreateWithoutNovelInput = {
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutFavoritesInput
  }

  export type FavoriteUncheckedCreateWithoutNovelInput = {
    userId: number
    createdAt?: Date | string
  }

  export type FavoriteCreateOrConnectWithoutNovelInput = {
    where: FavoriteWhereUniqueInput
    create: XOR<FavoriteCreateWithoutNovelInput, FavoriteUncheckedCreateWithoutNovelInput>
  }

  export type FavoriteCreateManyNovelInputEnvelope = {
    data: FavoriteCreateManyNovelInput | FavoriteCreateManyNovelInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutNovelInput = {
    content: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    chapter: ChapterCreateNestedOneWithoutCommentsInput
    replies?: ReplyCommentCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutNovelInput = {
    id?: number
    content: string
    likes?: number
    userId: number
    chapterId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ReplyCommentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutNovelInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutNovelInput, CommentUncheckedCreateWithoutNovelInput>
  }

  export type CommentCreateManyNovelInputEnvelope = {
    data: CommentCreateManyNovelInput | CommentCreateManyNovelInput[]
    skipDuplicates?: boolean
  }

  export type AuthorUpsertWithoutNovelsInput = {
    update: XOR<AuthorUpdateWithoutNovelsInput, AuthorUncheckedUpdateWithoutNovelsInput>
    create: XOR<AuthorCreateWithoutNovelsInput, AuthorUncheckedCreateWithoutNovelsInput>
    where?: AuthorWhereInput
  }

  export type AuthorUpdateToOneWithWhereWithoutNovelsInput = {
    where?: AuthorWhereInput
    data: XOR<AuthorUpdateWithoutNovelsInput, AuthorUncheckedUpdateWithoutNovelsInput>
  }

  export type AuthorUpdateWithoutNovelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
  }

  export type AuthorUncheckedUpdateWithoutNovelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutAuthoredNovelsInput = {
    update: XOR<UserUpdateWithoutAuthoredNovelsInput, UserUncheckedUpdateWithoutAuthoredNovelsInput>
    create: XOR<UserCreateWithoutAuthoredNovelsInput, UserUncheckedCreateWithoutAuthoredNovelsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuthoredNovelsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuthoredNovelsInput, UserUncheckedUpdateWithoutAuthoredNovelsInput>
  }

  export type UserUpdateWithoutAuthoredNovelsInput = {
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    bio?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: UserUpdatesocialLinksInput | string[]
    keys?: IntFieldUpdateOperationsInput | number
    tickets?: IntFieldUpdateOperationsInput | number
    candies?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTwoFactorAuth?: BoolFieldUpdateOperationsInput | boolean
    notifications?: NotificationSettingsUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    sessions?: RefreshTokenUpdateManyWithoutUserNestedInput
    readings?: ReadingUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    replies?: ReplyCommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuthoredNovelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    bio?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: UserUpdatesocialLinksInput | string[]
    keys?: IntFieldUpdateOperationsInput | number
    tickets?: IntFieldUpdateOperationsInput | number
    candies?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTwoFactorAuth?: BoolFieldUpdateOperationsInput | boolean
    notifications?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    sessions?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    readings?: ReadingUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type GenreUpsertWithoutNovelsInput = {
    update: XOR<GenreUpdateWithoutNovelsInput, GenreUncheckedUpdateWithoutNovelsInput>
    create: XOR<GenreCreateWithoutNovelsInput, GenreUncheckedCreateWithoutNovelsInput>
    where?: GenreWhereInput
  }

  export type GenreUpdateToOneWithWhereWithoutNovelsInput = {
    where?: GenreWhereInput
    data: XOR<GenreUpdateWithoutNovelsInput, GenreUncheckedUpdateWithoutNovelsInput>
  }

  export type GenreUpdateWithoutNovelsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type GenreUncheckedUpdateWithoutNovelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ChapterUpsertWithWhereUniqueWithoutNovelInput = {
    where: ChapterWhereUniqueInput
    update: XOR<ChapterUpdateWithoutNovelInput, ChapterUncheckedUpdateWithoutNovelInput>
    create: XOR<ChapterCreateWithoutNovelInput, ChapterUncheckedCreateWithoutNovelInput>
  }

  export type ChapterUpdateWithWhereUniqueWithoutNovelInput = {
    where: ChapterWhereUniqueInput
    data: XOR<ChapterUpdateWithoutNovelInput, ChapterUncheckedUpdateWithoutNovelInput>
  }

  export type ChapterUpdateManyWithWhereWithoutNovelInput = {
    where: ChapterScalarWhereInput
    data: XOR<ChapterUpdateManyMutationInput, ChapterUncheckedUpdateManyWithoutNovelInput>
  }

  export type ChapterScalarWhereInput = {
    AND?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
    OR?: ChapterScalarWhereInput[]
    NOT?: ChapterScalarWhereInput | ChapterScalarWhereInput[]
    id?: IntFilter<"Chapter"> | number
    novelId?: IntFilter<"Chapter"> | number
    chapterNumber?: IntFilter<"Chapter"> | number
    title?: StringFilter<"Chapter"> | string
    content?: StringFilter<"Chapter"> | string
    isLocked?: BoolFilter<"Chapter"> | boolean
    unlockCost?: IntFilter<"Chapter"> | number
    publishedAt?: DateTimeFilter<"Chapter"> | Date | string
    createdAt?: DateTimeFilter<"Chapter"> | Date | string
    updatedAt?: DateTimeFilter<"Chapter"> | Date | string
  }

  export type NovelTagUpsertWithWhereUniqueWithoutNovelInput = {
    where: NovelTagWhereUniqueInput
    update: XOR<NovelTagUpdateWithoutNovelInput, NovelTagUncheckedUpdateWithoutNovelInput>
    create: XOR<NovelTagCreateWithoutNovelInput, NovelTagUncheckedCreateWithoutNovelInput>
  }

  export type NovelTagUpdateWithWhereUniqueWithoutNovelInput = {
    where: NovelTagWhereUniqueInput
    data: XOR<NovelTagUpdateWithoutNovelInput, NovelTagUncheckedUpdateWithoutNovelInput>
  }

  export type NovelTagUpdateManyWithWhereWithoutNovelInput = {
    where: NovelTagScalarWhereInput
    data: XOR<NovelTagUpdateManyMutationInput, NovelTagUncheckedUpdateManyWithoutNovelInput>
  }

  export type NovelTagScalarWhereInput = {
    AND?: NovelTagScalarWhereInput | NovelTagScalarWhereInput[]
    OR?: NovelTagScalarWhereInput[]
    NOT?: NovelTagScalarWhereInput | NovelTagScalarWhereInput[]
    novelId?: IntFilter<"NovelTag"> | number
    tagId?: IntFilter<"NovelTag"> | number
  }

  export type ReviewUpsertWithWhereUniqueWithoutNovelInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutNovelInput, ReviewUncheckedUpdateWithoutNovelInput>
    create: XOR<ReviewCreateWithoutNovelInput, ReviewUncheckedCreateWithoutNovelInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutNovelInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutNovelInput, ReviewUncheckedUpdateWithoutNovelInput>
  }

  export type ReviewUpdateManyWithWhereWithoutNovelInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutNovelInput>
  }

  export type NovelStatisticUpsertWithWhereUniqueWithoutNovelInput = {
    where: NovelStatisticWhereUniqueInput
    update: XOR<NovelStatisticUpdateWithoutNovelInput, NovelStatisticUncheckedUpdateWithoutNovelInput>
    create: XOR<NovelStatisticCreateWithoutNovelInput, NovelStatisticUncheckedCreateWithoutNovelInput>
  }

  export type NovelStatisticUpdateWithWhereUniqueWithoutNovelInput = {
    where: NovelStatisticWhereUniqueInput
    data: XOR<NovelStatisticUpdateWithoutNovelInput, NovelStatisticUncheckedUpdateWithoutNovelInput>
  }

  export type NovelStatisticUpdateManyWithWhereWithoutNovelInput = {
    where: NovelStatisticScalarWhereInput
    data: XOR<NovelStatisticUpdateManyMutationInput, NovelStatisticUncheckedUpdateManyWithoutNovelInput>
  }

  export type NovelStatisticScalarWhereInput = {
    AND?: NovelStatisticScalarWhereInput | NovelStatisticScalarWhereInput[]
    OR?: NovelStatisticScalarWhereInput[]
    NOT?: NovelStatisticScalarWhereInput | NovelStatisticScalarWhereInput[]
    id?: IntFilter<"NovelStatistic"> | number
    novelId?: IntFilter<"NovelStatistic"> | number
    dailyViews?: IntFilter<"NovelStatistic"> | number
    totalViews?: IntFilter<"NovelStatistic"> | number
    reviews?: IntFilter<"NovelStatistic"> | number
    comments?: IntFilter<"NovelStatistic"> | number
    date?: DateTimeFilter<"NovelStatistic"> | Date | string
  }

  export type ReadingUpsertWithWhereUniqueWithoutNovelInput = {
    where: ReadingWhereUniqueInput
    update: XOR<ReadingUpdateWithoutNovelInput, ReadingUncheckedUpdateWithoutNovelInput>
    create: XOR<ReadingCreateWithoutNovelInput, ReadingUncheckedCreateWithoutNovelInput>
  }

  export type ReadingUpdateWithWhereUniqueWithoutNovelInput = {
    where: ReadingWhereUniqueInput
    data: XOR<ReadingUpdateWithoutNovelInput, ReadingUncheckedUpdateWithoutNovelInput>
  }

  export type ReadingUpdateManyWithWhereWithoutNovelInput = {
    where: ReadingScalarWhereInput
    data: XOR<ReadingUpdateManyMutationInput, ReadingUncheckedUpdateManyWithoutNovelInput>
  }

  export type FavoriteUpsertWithWhereUniqueWithoutNovelInput = {
    where: FavoriteWhereUniqueInput
    update: XOR<FavoriteUpdateWithoutNovelInput, FavoriteUncheckedUpdateWithoutNovelInput>
    create: XOR<FavoriteCreateWithoutNovelInput, FavoriteUncheckedCreateWithoutNovelInput>
  }

  export type FavoriteUpdateWithWhereUniqueWithoutNovelInput = {
    where: FavoriteWhereUniqueInput
    data: XOR<FavoriteUpdateWithoutNovelInput, FavoriteUncheckedUpdateWithoutNovelInput>
  }

  export type FavoriteUpdateManyWithWhereWithoutNovelInput = {
    where: FavoriteScalarWhereInput
    data: XOR<FavoriteUpdateManyMutationInput, FavoriteUncheckedUpdateManyWithoutNovelInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutNovelInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutNovelInput, CommentUncheckedUpdateWithoutNovelInput>
    create: XOR<CommentCreateWithoutNovelInput, CommentUncheckedCreateWithoutNovelInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutNovelInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutNovelInput, CommentUncheckedUpdateWithoutNovelInput>
  }

  export type CommentUpdateManyWithWhereWithoutNovelInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutNovelInput>
  }

  export type NovelCreateWithoutGenreInput = {
    title: string
    originalTitle?: string | null
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status?: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount?: number
    totalChapters?: number
    publishedAt?: Date | string | null
    newChapterAt?: Date | string
    createdAt?: Date | string
    author?: AuthorCreateNestedOneWithoutNovelsInput
    createdBy: UserCreateNestedOneWithoutAuthoredNovelsInput
    chapters?: ChapterCreateNestedManyWithoutNovelInput
    novelTags?: NovelTagCreateNestedManyWithoutNovelInput
    reviews?: ReviewCreateNestedManyWithoutNovelInput
    statistics?: NovelStatisticCreateNestedManyWithoutNovelInput
    readers?: ReadingCreateNestedManyWithoutNovelInput
    favorites?: FavoriteCreateNestedManyWithoutNovelInput
    comments?: CommentCreateNestedManyWithoutNovelInput
  }

  export type NovelUncheckedCreateWithoutGenreInput = {
    id?: number
    title: string
    originalTitle?: string | null
    authorId?: number | null
    createdById: number
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status?: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount?: number
    totalChapters?: number
    publishedAt?: Date | string | null
    newChapterAt?: Date | string
    createdAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutNovelInput
    novelTags?: NovelTagUncheckedCreateNestedManyWithoutNovelInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutNovelInput
    statistics?: NovelStatisticUncheckedCreateNestedManyWithoutNovelInput
    readers?: ReadingUncheckedCreateNestedManyWithoutNovelInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutNovelInput
    comments?: CommentUncheckedCreateNestedManyWithoutNovelInput
  }

  export type NovelCreateOrConnectWithoutGenreInput = {
    where: NovelWhereUniqueInput
    create: XOR<NovelCreateWithoutGenreInput, NovelUncheckedCreateWithoutGenreInput>
  }

  export type NovelCreateManyGenreInputEnvelope = {
    data: NovelCreateManyGenreInput | NovelCreateManyGenreInput[]
    skipDuplicates?: boolean
  }

  export type NovelUpsertWithWhereUniqueWithoutGenreInput = {
    where: NovelWhereUniqueInput
    update: XOR<NovelUpdateWithoutGenreInput, NovelUncheckedUpdateWithoutGenreInput>
    create: XOR<NovelCreateWithoutGenreInput, NovelUncheckedCreateWithoutGenreInput>
  }

  export type NovelUpdateWithWhereUniqueWithoutGenreInput = {
    where: NovelWhereUniqueInput
    data: XOR<NovelUpdateWithoutGenreInput, NovelUncheckedUpdateWithoutGenreInput>
  }

  export type NovelUpdateManyWithWhereWithoutGenreInput = {
    where: NovelScalarWhereInput
    data: XOR<NovelUpdateManyMutationInput, NovelUncheckedUpdateManyWithoutGenreInput>
  }

  export type TagGroupCreateWithoutTagsInput = {
    name: string
    color: string
  }

  export type TagGroupUncheckedCreateWithoutTagsInput = {
    id?: number
    name: string
    color: string
  }

  export type TagGroupCreateOrConnectWithoutTagsInput = {
    where: TagGroupWhereUniqueInput
    create: XOR<TagGroupCreateWithoutTagsInput, TagGroupUncheckedCreateWithoutTagsInput>
  }

  export type NovelTagCreateWithoutTagInput = {
    novel: NovelCreateNestedOneWithoutNovelTagsInput
  }

  export type NovelTagUncheckedCreateWithoutTagInput = {
    novelId: number
  }

  export type NovelTagCreateOrConnectWithoutTagInput = {
    where: NovelTagWhereUniqueInput
    create: XOR<NovelTagCreateWithoutTagInput, NovelTagUncheckedCreateWithoutTagInput>
  }

  export type NovelTagCreateManyTagInputEnvelope = {
    data: NovelTagCreateManyTagInput | NovelTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type TagGroupUpsertWithoutTagsInput = {
    update: XOR<TagGroupUpdateWithoutTagsInput, TagGroupUncheckedUpdateWithoutTagsInput>
    create: XOR<TagGroupCreateWithoutTagsInput, TagGroupUncheckedCreateWithoutTagsInput>
    where?: TagGroupWhereInput
  }

  export type TagGroupUpdateToOneWithWhereWithoutTagsInput = {
    where?: TagGroupWhereInput
    data: XOR<TagGroupUpdateWithoutTagsInput, TagGroupUncheckedUpdateWithoutTagsInput>
  }

  export type TagGroupUpdateWithoutTagsInput = {
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type TagGroupUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    color?: StringFieldUpdateOperationsInput | string
  }

  export type NovelTagUpsertWithWhereUniqueWithoutTagInput = {
    where: NovelTagWhereUniqueInput
    update: XOR<NovelTagUpdateWithoutTagInput, NovelTagUncheckedUpdateWithoutTagInput>
    create: XOR<NovelTagCreateWithoutTagInput, NovelTagUncheckedCreateWithoutTagInput>
  }

  export type NovelTagUpdateWithWhereUniqueWithoutTagInput = {
    where: NovelTagWhereUniqueInput
    data: XOR<NovelTagUpdateWithoutTagInput, NovelTagUncheckedUpdateWithoutTagInput>
  }

  export type NovelTagUpdateManyWithWhereWithoutTagInput = {
    where: NovelTagScalarWhereInput
    data: XOR<NovelTagUpdateManyMutationInput, NovelTagUncheckedUpdateManyWithoutTagInput>
  }

  export type TagCreateWithoutTagGroupInput = {
    name: string
    description?: string | null
    novels?: NovelTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateWithoutTagGroupInput = {
    id?: number
    name: string
    description?: string | null
    novels?: NovelTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagCreateOrConnectWithoutTagGroupInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutTagGroupInput, TagUncheckedCreateWithoutTagGroupInput>
  }

  export type TagCreateManyTagGroupInputEnvelope = {
    data: TagCreateManyTagGroupInput | TagCreateManyTagGroupInput[]
    skipDuplicates?: boolean
  }

  export type TagUpsertWithWhereUniqueWithoutTagGroupInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutTagGroupInput, TagUncheckedUpdateWithoutTagGroupInput>
    create: XOR<TagCreateWithoutTagGroupInput, TagUncheckedCreateWithoutTagGroupInput>
  }

  export type TagUpdateWithWhereUniqueWithoutTagGroupInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutTagGroupInput, TagUncheckedUpdateWithoutTagGroupInput>
  }

  export type TagUpdateManyWithWhereWithoutTagGroupInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutTagGroupInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    id?: IntFilter<"Tag"> | number
    name?: StringFilter<"Tag"> | string
    description?: StringNullableFilter<"Tag"> | string | null
    tagGroupId?: IntFilter<"Tag"> | number
  }

  export type NovelCreateWithoutNovelTagsInput = {
    title: string
    originalTitle?: string | null
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status?: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount?: number
    totalChapters?: number
    publishedAt?: Date | string | null
    newChapterAt?: Date | string
    createdAt?: Date | string
    author?: AuthorCreateNestedOneWithoutNovelsInput
    createdBy: UserCreateNestedOneWithoutAuthoredNovelsInput
    genre: GenreCreateNestedOneWithoutNovelsInput
    chapters?: ChapterCreateNestedManyWithoutNovelInput
    reviews?: ReviewCreateNestedManyWithoutNovelInput
    statistics?: NovelStatisticCreateNestedManyWithoutNovelInput
    readers?: ReadingCreateNestedManyWithoutNovelInput
    favorites?: FavoriteCreateNestedManyWithoutNovelInput
    comments?: CommentCreateNestedManyWithoutNovelInput
  }

  export type NovelUncheckedCreateWithoutNovelTagsInput = {
    id?: number
    title: string
    originalTitle?: string | null
    authorId?: number | null
    createdById: number
    genreId: number
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status?: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount?: number
    totalChapters?: number
    publishedAt?: Date | string | null
    newChapterAt?: Date | string
    createdAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutNovelInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutNovelInput
    statistics?: NovelStatisticUncheckedCreateNestedManyWithoutNovelInput
    readers?: ReadingUncheckedCreateNestedManyWithoutNovelInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutNovelInput
    comments?: CommentUncheckedCreateNestedManyWithoutNovelInput
  }

  export type NovelCreateOrConnectWithoutNovelTagsInput = {
    where: NovelWhereUniqueInput
    create: XOR<NovelCreateWithoutNovelTagsInput, NovelUncheckedCreateWithoutNovelTagsInput>
  }

  export type TagCreateWithoutNovelsInput = {
    name: string
    description?: string | null
    tagGroup: TagGroupCreateNestedOneWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutNovelsInput = {
    id?: number
    name: string
    description?: string | null
    tagGroupId: number
  }

  export type TagCreateOrConnectWithoutNovelsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutNovelsInput, TagUncheckedCreateWithoutNovelsInput>
  }

  export type NovelUpsertWithoutNovelTagsInput = {
    update: XOR<NovelUpdateWithoutNovelTagsInput, NovelUncheckedUpdateWithoutNovelTagsInput>
    create: XOR<NovelCreateWithoutNovelTagsInput, NovelUncheckedCreateWithoutNovelTagsInput>
    where?: NovelWhereInput
  }

  export type NovelUpdateToOneWithWhereWithoutNovelTagsInput = {
    where?: NovelWhereInput
    data: XOR<NovelUpdateWithoutNovelTagsInput, NovelUncheckedUpdateWithoutNovelTagsInput>
  }

  export type NovelUpdateWithoutNovelTagsInput = {
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AuthorUpdateOneWithoutNovelsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutAuthoredNovelsNestedInput
    genre?: GenreUpdateOneRequiredWithoutNovelsNestedInput
    chapters?: ChapterUpdateManyWithoutNovelNestedInput
    reviews?: ReviewUpdateManyWithoutNovelNestedInput
    statistics?: NovelStatisticUpdateManyWithoutNovelNestedInput
    readers?: ReadingUpdateManyWithoutNovelNestedInput
    favorites?: FavoriteUpdateManyWithoutNovelNestedInput
    comments?: CommentUpdateManyWithoutNovelNestedInput
  }

  export type NovelUncheckedUpdateWithoutNovelTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    genreId?: IntFieldUpdateOperationsInput | number
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutNovelNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutNovelNestedInput
    statistics?: NovelStatisticUncheckedUpdateManyWithoutNovelNestedInput
    readers?: ReadingUncheckedUpdateManyWithoutNovelNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutNovelNestedInput
    comments?: CommentUncheckedUpdateManyWithoutNovelNestedInput
  }

  export type TagUpsertWithoutNovelsInput = {
    update: XOR<TagUpdateWithoutNovelsInput, TagUncheckedUpdateWithoutNovelsInput>
    create: XOR<TagCreateWithoutNovelsInput, TagUncheckedCreateWithoutNovelsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutNovelsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutNovelsInput, TagUncheckedUpdateWithoutNovelsInput>
  }

  export type TagUpdateWithoutNovelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tagGroup?: TagGroupUpdateOneRequiredWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutNovelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tagGroupId?: IntFieldUpdateOperationsInput | number
  }

  export type NovelCreateWithoutChaptersInput = {
    title: string
    originalTitle?: string | null
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status?: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount?: number
    totalChapters?: number
    publishedAt?: Date | string | null
    newChapterAt?: Date | string
    createdAt?: Date | string
    author?: AuthorCreateNestedOneWithoutNovelsInput
    createdBy: UserCreateNestedOneWithoutAuthoredNovelsInput
    genre: GenreCreateNestedOneWithoutNovelsInput
    novelTags?: NovelTagCreateNestedManyWithoutNovelInput
    reviews?: ReviewCreateNestedManyWithoutNovelInput
    statistics?: NovelStatisticCreateNestedManyWithoutNovelInput
    readers?: ReadingCreateNestedManyWithoutNovelInput
    favorites?: FavoriteCreateNestedManyWithoutNovelInput
    comments?: CommentCreateNestedManyWithoutNovelInput
  }

  export type NovelUncheckedCreateWithoutChaptersInput = {
    id?: number
    title: string
    originalTitle?: string | null
    authorId?: number | null
    createdById: number
    genreId: number
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status?: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount?: number
    totalChapters?: number
    publishedAt?: Date | string | null
    newChapterAt?: Date | string
    createdAt?: Date | string
    novelTags?: NovelTagUncheckedCreateNestedManyWithoutNovelInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutNovelInput
    statistics?: NovelStatisticUncheckedCreateNestedManyWithoutNovelInput
    readers?: ReadingUncheckedCreateNestedManyWithoutNovelInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutNovelInput
    comments?: CommentUncheckedCreateNestedManyWithoutNovelInput
  }

  export type NovelCreateOrConnectWithoutChaptersInput = {
    where: NovelWhereUniqueInput
    create: XOR<NovelCreateWithoutChaptersInput, NovelUncheckedCreateWithoutChaptersInput>
  }

  export type CommentCreateWithoutChapterInput = {
    content: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    replies?: ReplyCommentCreateNestedManyWithoutCommentInput
    Novel?: NovelCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutChapterInput = {
    id?: number
    content: string
    likes?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    novelId?: number | null
    replies?: ReplyCommentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutChapterInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutChapterInput, CommentUncheckedCreateWithoutChapterInput>
  }

  export type CommentCreateManyChapterInputEnvelope = {
    data: CommentCreateManyChapterInput | CommentCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type ChapterStatisticCreateWithoutChapterInput = {
    views?: number
    date: Date | string
  }

  export type ChapterStatisticUncheckedCreateWithoutChapterInput = {
    id?: number
    views?: number
    date: Date | string
  }

  export type ChapterStatisticCreateOrConnectWithoutChapterInput = {
    where: ChapterStatisticWhereUniqueInput
    create: XOR<ChapterStatisticCreateWithoutChapterInput, ChapterStatisticUncheckedCreateWithoutChapterInput>
  }

  export type ChapterStatisticCreateManyChapterInputEnvelope = {
    data: ChapterStatisticCreateManyChapterInput | ChapterStatisticCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type ReadingCreateWithoutChapterInput = {
    lastRead?: Date | string
    user: UserCreateNestedOneWithoutReadingsInput
    novel: NovelCreateNestedOneWithoutReadersInput
  }

  export type ReadingUncheckedCreateWithoutChapterInput = {
    userId: number
    novelId: number
    lastRead?: Date | string
  }

  export type ReadingCreateOrConnectWithoutChapterInput = {
    where: ReadingWhereUniqueInput
    create: XOR<ReadingCreateWithoutChapterInput, ReadingUncheckedCreateWithoutChapterInput>
  }

  export type ReadingCreateManyChapterInputEnvelope = {
    data: ReadingCreateManyChapterInput | ReadingCreateManyChapterInput[]
    skipDuplicates?: boolean
  }

  export type NovelUpsertWithoutChaptersInput = {
    update: XOR<NovelUpdateWithoutChaptersInput, NovelUncheckedUpdateWithoutChaptersInput>
    create: XOR<NovelCreateWithoutChaptersInput, NovelUncheckedCreateWithoutChaptersInput>
    where?: NovelWhereInput
  }

  export type NovelUpdateToOneWithWhereWithoutChaptersInput = {
    where?: NovelWhereInput
    data: XOR<NovelUpdateWithoutChaptersInput, NovelUncheckedUpdateWithoutChaptersInput>
  }

  export type NovelUpdateWithoutChaptersInput = {
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AuthorUpdateOneWithoutNovelsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutAuthoredNovelsNestedInput
    genre?: GenreUpdateOneRequiredWithoutNovelsNestedInput
    novelTags?: NovelTagUpdateManyWithoutNovelNestedInput
    reviews?: ReviewUpdateManyWithoutNovelNestedInput
    statistics?: NovelStatisticUpdateManyWithoutNovelNestedInput
    readers?: ReadingUpdateManyWithoutNovelNestedInput
    favorites?: FavoriteUpdateManyWithoutNovelNestedInput
    comments?: CommentUpdateManyWithoutNovelNestedInput
  }

  export type NovelUncheckedUpdateWithoutChaptersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    genreId?: IntFieldUpdateOperationsInput | number
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    novelTags?: NovelTagUncheckedUpdateManyWithoutNovelNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutNovelNestedInput
    statistics?: NovelStatisticUncheckedUpdateManyWithoutNovelNestedInput
    readers?: ReadingUncheckedUpdateManyWithoutNovelNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutNovelNestedInput
    comments?: CommentUncheckedUpdateManyWithoutNovelNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutChapterInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutChapterInput, CommentUncheckedUpdateWithoutChapterInput>
    create: XOR<CommentCreateWithoutChapterInput, CommentUncheckedCreateWithoutChapterInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutChapterInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutChapterInput, CommentUncheckedUpdateWithoutChapterInput>
  }

  export type CommentUpdateManyWithWhereWithoutChapterInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutChapterInput>
  }

  export type ChapterStatisticUpsertWithWhereUniqueWithoutChapterInput = {
    where: ChapterStatisticWhereUniqueInput
    update: XOR<ChapterStatisticUpdateWithoutChapterInput, ChapterStatisticUncheckedUpdateWithoutChapterInput>
    create: XOR<ChapterStatisticCreateWithoutChapterInput, ChapterStatisticUncheckedCreateWithoutChapterInput>
  }

  export type ChapterStatisticUpdateWithWhereUniqueWithoutChapterInput = {
    where: ChapterStatisticWhereUniqueInput
    data: XOR<ChapterStatisticUpdateWithoutChapterInput, ChapterStatisticUncheckedUpdateWithoutChapterInput>
  }

  export type ChapterStatisticUpdateManyWithWhereWithoutChapterInput = {
    where: ChapterStatisticScalarWhereInput
    data: XOR<ChapterStatisticUpdateManyMutationInput, ChapterStatisticUncheckedUpdateManyWithoutChapterInput>
  }

  export type ChapterStatisticScalarWhereInput = {
    AND?: ChapterStatisticScalarWhereInput | ChapterStatisticScalarWhereInput[]
    OR?: ChapterStatisticScalarWhereInput[]
    NOT?: ChapterStatisticScalarWhereInput | ChapterStatisticScalarWhereInput[]
    id?: IntFilter<"ChapterStatistic"> | number
    chapterId?: IntFilter<"ChapterStatistic"> | number
    views?: IntFilter<"ChapterStatistic"> | number
    date?: DateTimeFilter<"ChapterStatistic"> | Date | string
  }

  export type ReadingUpsertWithWhereUniqueWithoutChapterInput = {
    where: ReadingWhereUniqueInput
    update: XOR<ReadingUpdateWithoutChapterInput, ReadingUncheckedUpdateWithoutChapterInput>
    create: XOR<ReadingCreateWithoutChapterInput, ReadingUncheckedCreateWithoutChapterInput>
  }

  export type ReadingUpdateWithWhereUniqueWithoutChapterInput = {
    where: ReadingWhereUniqueInput
    data: XOR<ReadingUpdateWithoutChapterInput, ReadingUncheckedUpdateWithoutChapterInput>
  }

  export type ReadingUpdateManyWithWhereWithoutChapterInput = {
    where: ReadingScalarWhereInput
    data: XOR<ReadingUpdateManyMutationInput, ReadingUncheckedUpdateManyWithoutChapterInput>
  }

  export type UserCreateWithoutReviewsInput = {
    nickname: string
    email: string
    password?: string | null
    phone?: string
    avatar?: string
    coverImage?: string
    role?: $Enums.UserRole
    gender?: $Enums.Gender
    bio?: string
    birthDate?: Date | string
    socialLinks?: UserCreatesocialLinksInput | string[]
    keys?: number
    tickets?: number
    candies?: number
    createdAt?: Date | string
    emailVerifiedAt?: Date | string | null
    isTwoFactorAuth?: boolean
    notifications?: NotificationSettingsCreateNestedOneWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    authoredNovels?: NovelCreateNestedManyWithoutCreatedByInput
    sessions?: RefreshTokenCreateNestedManyWithoutUserInput
    readings?: ReadingCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    replies?: ReplyCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: number
    nickname: string
    email: string
    password?: string | null
    phone?: string
    avatar?: string
    coverImage?: string
    role?: $Enums.UserRole
    gender?: $Enums.Gender
    bio?: string
    birthDate?: Date | string
    socialLinks?: UserCreatesocialLinksInput | string[]
    keys?: number
    tickets?: number
    candies?: number
    createdAt?: Date | string
    emailVerifiedAt?: Date | string | null
    isTwoFactorAuth?: boolean
    notifications?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    authoredNovels?: NovelUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    readings?: ReadingUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type NovelCreateWithoutReviewsInput = {
    title: string
    originalTitle?: string | null
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status?: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount?: number
    totalChapters?: number
    publishedAt?: Date | string | null
    newChapterAt?: Date | string
    createdAt?: Date | string
    author?: AuthorCreateNestedOneWithoutNovelsInput
    createdBy: UserCreateNestedOneWithoutAuthoredNovelsInput
    genre: GenreCreateNestedOneWithoutNovelsInput
    chapters?: ChapterCreateNestedManyWithoutNovelInput
    novelTags?: NovelTagCreateNestedManyWithoutNovelInput
    statistics?: NovelStatisticCreateNestedManyWithoutNovelInput
    readers?: ReadingCreateNestedManyWithoutNovelInput
    favorites?: FavoriteCreateNestedManyWithoutNovelInput
    comments?: CommentCreateNestedManyWithoutNovelInput
  }

  export type NovelUncheckedCreateWithoutReviewsInput = {
    id?: number
    title: string
    originalTitle?: string | null
    authorId?: number | null
    createdById: number
    genreId: number
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status?: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount?: number
    totalChapters?: number
    publishedAt?: Date | string | null
    newChapterAt?: Date | string
    createdAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutNovelInput
    novelTags?: NovelTagUncheckedCreateNestedManyWithoutNovelInput
    statistics?: NovelStatisticUncheckedCreateNestedManyWithoutNovelInput
    readers?: ReadingUncheckedCreateNestedManyWithoutNovelInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutNovelInput
    comments?: CommentUncheckedCreateNestedManyWithoutNovelInput
  }

  export type NovelCreateOrConnectWithoutReviewsInput = {
    where: NovelWhereUniqueInput
    create: XOR<NovelCreateWithoutReviewsInput, NovelUncheckedCreateWithoutReviewsInput>
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    bio?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: UserUpdatesocialLinksInput | string[]
    keys?: IntFieldUpdateOperationsInput | number
    tickets?: IntFieldUpdateOperationsInput | number
    candies?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTwoFactorAuth?: BoolFieldUpdateOperationsInput | boolean
    notifications?: NotificationSettingsUpdateOneWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    authoredNovels?: NovelUpdateManyWithoutCreatedByNestedInput
    sessions?: RefreshTokenUpdateManyWithoutUserNestedInput
    readings?: ReadingUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    replies?: ReplyCommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    bio?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: UserUpdatesocialLinksInput | string[]
    keys?: IntFieldUpdateOperationsInput | number
    tickets?: IntFieldUpdateOperationsInput | number
    candies?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTwoFactorAuth?: BoolFieldUpdateOperationsInput | boolean
    notifications?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    authoredNovels?: NovelUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    readings?: ReadingUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NovelUpsertWithoutReviewsInput = {
    update: XOR<NovelUpdateWithoutReviewsInput, NovelUncheckedUpdateWithoutReviewsInput>
    create: XOR<NovelCreateWithoutReviewsInput, NovelUncheckedCreateWithoutReviewsInput>
    where?: NovelWhereInput
  }

  export type NovelUpdateToOneWithWhereWithoutReviewsInput = {
    where?: NovelWhereInput
    data: XOR<NovelUpdateWithoutReviewsInput, NovelUncheckedUpdateWithoutReviewsInput>
  }

  export type NovelUpdateWithoutReviewsInput = {
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AuthorUpdateOneWithoutNovelsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutAuthoredNovelsNestedInput
    genre?: GenreUpdateOneRequiredWithoutNovelsNestedInput
    chapters?: ChapterUpdateManyWithoutNovelNestedInput
    novelTags?: NovelTagUpdateManyWithoutNovelNestedInput
    statistics?: NovelStatisticUpdateManyWithoutNovelNestedInput
    readers?: ReadingUpdateManyWithoutNovelNestedInput
    favorites?: FavoriteUpdateManyWithoutNovelNestedInput
    comments?: CommentUpdateManyWithoutNovelNestedInput
  }

  export type NovelUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    genreId?: IntFieldUpdateOperationsInput | number
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutNovelNestedInput
    novelTags?: NovelTagUncheckedUpdateManyWithoutNovelNestedInput
    statistics?: NovelStatisticUncheckedUpdateManyWithoutNovelNestedInput
    readers?: ReadingUncheckedUpdateManyWithoutNovelNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutNovelNestedInput
    comments?: CommentUncheckedUpdateManyWithoutNovelNestedInput
  }

  export type UserCreateWithoutCommentsInput = {
    nickname: string
    email: string
    password?: string | null
    phone?: string
    avatar?: string
    coverImage?: string
    role?: $Enums.UserRole
    gender?: $Enums.Gender
    bio?: string
    birthDate?: Date | string
    socialLinks?: UserCreatesocialLinksInput | string[]
    keys?: number
    tickets?: number
    candies?: number
    createdAt?: Date | string
    emailVerifiedAt?: Date | string | null
    isTwoFactorAuth?: boolean
    notifications?: NotificationSettingsCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    authoredNovels?: NovelCreateNestedManyWithoutCreatedByInput
    sessions?: RefreshTokenCreateNestedManyWithoutUserInput
    readings?: ReadingCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    replies?: ReplyCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: number
    nickname: string
    email: string
    password?: string | null
    phone?: string
    avatar?: string
    coverImage?: string
    role?: $Enums.UserRole
    gender?: $Enums.Gender
    bio?: string
    birthDate?: Date | string
    socialLinks?: UserCreatesocialLinksInput | string[]
    keys?: number
    tickets?: number
    candies?: number
    createdAt?: Date | string
    emailVerifiedAt?: Date | string | null
    isTwoFactorAuth?: boolean
    notifications?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    authoredNovels?: NovelUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    readings?: ReadingUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type ChapterCreateWithoutCommentsInput = {
    chapterNumber: number
    title: string
    content: string
    isLocked?: boolean
    unlockCost?: number
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    novel: NovelCreateNestedOneWithoutChaptersInput
    statistics?: ChapterStatisticCreateNestedManyWithoutChapterInput
    reading?: ReadingCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutCommentsInput = {
    id?: number
    novelId: number
    chapterNumber: number
    title: string
    content: string
    isLocked?: boolean
    unlockCost?: number
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    statistics?: ChapterStatisticUncheckedCreateNestedManyWithoutChapterInput
    reading?: ReadingUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutCommentsInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutCommentsInput, ChapterUncheckedCreateWithoutCommentsInput>
  }

  export type ReplyCommentCreateWithoutCommentInput = {
    content: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRepliesInput
  }

  export type ReplyCommentUncheckedCreateWithoutCommentInput = {
    id?: number
    content: string
    likes?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReplyCommentCreateOrConnectWithoutCommentInput = {
    where: ReplyCommentWhereUniqueInput
    create: XOR<ReplyCommentCreateWithoutCommentInput, ReplyCommentUncheckedCreateWithoutCommentInput>
  }

  export type ReplyCommentCreateManyCommentInputEnvelope = {
    data: ReplyCommentCreateManyCommentInput | ReplyCommentCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type NovelCreateWithoutCommentsInput = {
    title: string
    originalTitle?: string | null
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status?: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount?: number
    totalChapters?: number
    publishedAt?: Date | string | null
    newChapterAt?: Date | string
    createdAt?: Date | string
    author?: AuthorCreateNestedOneWithoutNovelsInput
    createdBy: UserCreateNestedOneWithoutAuthoredNovelsInput
    genre: GenreCreateNestedOneWithoutNovelsInput
    chapters?: ChapterCreateNestedManyWithoutNovelInput
    novelTags?: NovelTagCreateNestedManyWithoutNovelInput
    reviews?: ReviewCreateNestedManyWithoutNovelInput
    statistics?: NovelStatisticCreateNestedManyWithoutNovelInput
    readers?: ReadingCreateNestedManyWithoutNovelInput
    favorites?: FavoriteCreateNestedManyWithoutNovelInput
  }

  export type NovelUncheckedCreateWithoutCommentsInput = {
    id?: number
    title: string
    originalTitle?: string | null
    authorId?: number | null
    createdById: number
    genreId: number
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status?: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount?: number
    totalChapters?: number
    publishedAt?: Date | string | null
    newChapterAt?: Date | string
    createdAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutNovelInput
    novelTags?: NovelTagUncheckedCreateNestedManyWithoutNovelInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutNovelInput
    statistics?: NovelStatisticUncheckedCreateNestedManyWithoutNovelInput
    readers?: ReadingUncheckedCreateNestedManyWithoutNovelInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutNovelInput
  }

  export type NovelCreateOrConnectWithoutCommentsInput = {
    where: NovelWhereUniqueInput
    create: XOR<NovelCreateWithoutCommentsInput, NovelUncheckedCreateWithoutCommentsInput>
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    bio?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: UserUpdatesocialLinksInput | string[]
    keys?: IntFieldUpdateOperationsInput | number
    tickets?: IntFieldUpdateOperationsInput | number
    candies?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTwoFactorAuth?: BoolFieldUpdateOperationsInput | boolean
    notifications?: NotificationSettingsUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    authoredNovels?: NovelUpdateManyWithoutCreatedByNestedInput
    sessions?: RefreshTokenUpdateManyWithoutUserNestedInput
    readings?: ReadingUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    replies?: ReplyCommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    bio?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: UserUpdatesocialLinksInput | string[]
    keys?: IntFieldUpdateOperationsInput | number
    tickets?: IntFieldUpdateOperationsInput | number
    candies?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTwoFactorAuth?: BoolFieldUpdateOperationsInput | boolean
    notifications?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    authoredNovels?: NovelUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    readings?: ReadingUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ChapterUpsertWithoutCommentsInput = {
    update: XOR<ChapterUpdateWithoutCommentsInput, ChapterUncheckedUpdateWithoutCommentsInput>
    create: XOR<ChapterCreateWithoutCommentsInput, ChapterUncheckedCreateWithoutCommentsInput>
    where?: ChapterWhereInput
  }

  export type ChapterUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ChapterWhereInput
    data: XOR<ChapterUpdateWithoutCommentsInput, ChapterUncheckedUpdateWithoutCommentsInput>
  }

  export type ChapterUpdateWithoutCommentsInput = {
    chapterNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    unlockCost?: IntFieldUpdateOperationsInput | number
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    novel?: NovelUpdateOneRequiredWithoutChaptersNestedInput
    statistics?: ChapterStatisticUpdateManyWithoutChapterNestedInput
    reading?: ReadingUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    novelId?: IntFieldUpdateOperationsInput | number
    chapterNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    unlockCost?: IntFieldUpdateOperationsInput | number
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    statistics?: ChapterStatisticUncheckedUpdateManyWithoutChapterNestedInput
    reading?: ReadingUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type ReplyCommentUpsertWithWhereUniqueWithoutCommentInput = {
    where: ReplyCommentWhereUniqueInput
    update: XOR<ReplyCommentUpdateWithoutCommentInput, ReplyCommentUncheckedUpdateWithoutCommentInput>
    create: XOR<ReplyCommentCreateWithoutCommentInput, ReplyCommentUncheckedCreateWithoutCommentInput>
  }

  export type ReplyCommentUpdateWithWhereUniqueWithoutCommentInput = {
    where: ReplyCommentWhereUniqueInput
    data: XOR<ReplyCommentUpdateWithoutCommentInput, ReplyCommentUncheckedUpdateWithoutCommentInput>
  }

  export type ReplyCommentUpdateManyWithWhereWithoutCommentInput = {
    where: ReplyCommentScalarWhereInput
    data: XOR<ReplyCommentUpdateManyMutationInput, ReplyCommentUncheckedUpdateManyWithoutCommentInput>
  }

  export type NovelUpsertWithoutCommentsInput = {
    update: XOR<NovelUpdateWithoutCommentsInput, NovelUncheckedUpdateWithoutCommentsInput>
    create: XOR<NovelCreateWithoutCommentsInput, NovelUncheckedCreateWithoutCommentsInput>
    where?: NovelWhereInput
  }

  export type NovelUpdateToOneWithWhereWithoutCommentsInput = {
    where?: NovelWhereInput
    data: XOR<NovelUpdateWithoutCommentsInput, NovelUncheckedUpdateWithoutCommentsInput>
  }

  export type NovelUpdateWithoutCommentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AuthorUpdateOneWithoutNovelsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutAuthoredNovelsNestedInput
    genre?: GenreUpdateOneRequiredWithoutNovelsNestedInput
    chapters?: ChapterUpdateManyWithoutNovelNestedInput
    novelTags?: NovelTagUpdateManyWithoutNovelNestedInput
    reviews?: ReviewUpdateManyWithoutNovelNestedInput
    statistics?: NovelStatisticUpdateManyWithoutNovelNestedInput
    readers?: ReadingUpdateManyWithoutNovelNestedInput
    favorites?: FavoriteUpdateManyWithoutNovelNestedInput
  }

  export type NovelUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    genreId?: IntFieldUpdateOperationsInput | number
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutNovelNestedInput
    novelTags?: NovelTagUncheckedUpdateManyWithoutNovelNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutNovelNestedInput
    statistics?: NovelStatisticUncheckedUpdateManyWithoutNovelNestedInput
    readers?: ReadingUncheckedUpdateManyWithoutNovelNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutNovelNestedInput
  }

  export type UserCreateWithoutRepliesInput = {
    nickname: string
    email: string
    password?: string | null
    phone?: string
    avatar?: string
    coverImage?: string
    role?: $Enums.UserRole
    gender?: $Enums.Gender
    bio?: string
    birthDate?: Date | string
    socialLinks?: UserCreatesocialLinksInput | string[]
    keys?: number
    tickets?: number
    candies?: number
    createdAt?: Date | string
    emailVerifiedAt?: Date | string | null
    isTwoFactorAuth?: boolean
    notifications?: NotificationSettingsCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    authoredNovels?: NovelCreateNestedManyWithoutCreatedByInput
    sessions?: RefreshTokenCreateNestedManyWithoutUserInput
    readings?: ReadingCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRepliesInput = {
    id?: number
    nickname: string
    email: string
    password?: string | null
    phone?: string
    avatar?: string
    coverImage?: string
    role?: $Enums.UserRole
    gender?: $Enums.Gender
    bio?: string
    birthDate?: Date | string
    socialLinks?: UserCreatesocialLinksInput | string[]
    keys?: number
    tickets?: number
    candies?: number
    createdAt?: Date | string
    emailVerifiedAt?: Date | string | null
    isTwoFactorAuth?: boolean
    notifications?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    authoredNovels?: NovelUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    readings?: ReadingUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRepliesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRepliesInput, UserUncheckedCreateWithoutRepliesInput>
  }

  export type CommentCreateWithoutRepliesInput = {
    content: string
    likes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCommentsInput
    chapter: ChapterCreateNestedOneWithoutCommentsInput
    Novel?: NovelCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateWithoutRepliesInput = {
    id?: number
    content: string
    likes?: number
    userId: number
    chapterId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    novelId?: number | null
  }

  export type CommentCreateOrConnectWithoutRepliesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
  }

  export type UserUpsertWithoutRepliesInput = {
    update: XOR<UserUpdateWithoutRepliesInput, UserUncheckedUpdateWithoutRepliesInput>
    create: XOR<UserCreateWithoutRepliesInput, UserUncheckedCreateWithoutRepliesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRepliesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRepliesInput, UserUncheckedUpdateWithoutRepliesInput>
  }

  export type UserUpdateWithoutRepliesInput = {
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    bio?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: UserUpdatesocialLinksInput | string[]
    keys?: IntFieldUpdateOperationsInput | number
    tickets?: IntFieldUpdateOperationsInput | number
    candies?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTwoFactorAuth?: BoolFieldUpdateOperationsInput | boolean
    notifications?: NotificationSettingsUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    authoredNovels?: NovelUpdateManyWithoutCreatedByNestedInput
    sessions?: RefreshTokenUpdateManyWithoutUserNestedInput
    readings?: ReadingUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRepliesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    bio?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: UserUpdatesocialLinksInput | string[]
    keys?: IntFieldUpdateOperationsInput | number
    tickets?: IntFieldUpdateOperationsInput | number
    candies?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTwoFactorAuth?: BoolFieldUpdateOperationsInput | boolean
    notifications?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    authoredNovels?: NovelUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    readings?: ReadingUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentUpsertWithoutRepliesInput = {
    update: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateWithoutRepliesInput = {
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    chapter?: ChapterUpdateOneRequiredWithoutCommentsNestedInput
    Novel?: NovelUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutRepliesInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    novelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCreateWithoutReadingsInput = {
    nickname: string
    email: string
    password?: string | null
    phone?: string
    avatar?: string
    coverImage?: string
    role?: $Enums.UserRole
    gender?: $Enums.Gender
    bio?: string
    birthDate?: Date | string
    socialLinks?: UserCreatesocialLinksInput | string[]
    keys?: number
    tickets?: number
    candies?: number
    createdAt?: Date | string
    emailVerifiedAt?: Date | string | null
    isTwoFactorAuth?: boolean
    notifications?: NotificationSettingsCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    authoredNovels?: NovelCreateNestedManyWithoutCreatedByInput
    sessions?: RefreshTokenCreateNestedManyWithoutUserInput
    favorites?: FavoriteCreateNestedManyWithoutUserInput
    replies?: ReplyCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReadingsInput = {
    id?: number
    nickname: string
    email: string
    password?: string | null
    phone?: string
    avatar?: string
    coverImage?: string
    role?: $Enums.UserRole
    gender?: $Enums.Gender
    bio?: string
    birthDate?: Date | string
    socialLinks?: UserCreatesocialLinksInput | string[]
    keys?: number
    tickets?: number
    candies?: number
    createdAt?: Date | string
    emailVerifiedAt?: Date | string | null
    isTwoFactorAuth?: boolean
    notifications?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    authoredNovels?: NovelUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReadingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReadingsInput, UserUncheckedCreateWithoutReadingsInput>
  }

  export type NovelCreateWithoutReadersInput = {
    title: string
    originalTitle?: string | null
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status?: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount?: number
    totalChapters?: number
    publishedAt?: Date | string | null
    newChapterAt?: Date | string
    createdAt?: Date | string
    author?: AuthorCreateNestedOneWithoutNovelsInput
    createdBy: UserCreateNestedOneWithoutAuthoredNovelsInput
    genre: GenreCreateNestedOneWithoutNovelsInput
    chapters?: ChapterCreateNestedManyWithoutNovelInput
    novelTags?: NovelTagCreateNestedManyWithoutNovelInput
    reviews?: ReviewCreateNestedManyWithoutNovelInput
    statistics?: NovelStatisticCreateNestedManyWithoutNovelInput
    favorites?: FavoriteCreateNestedManyWithoutNovelInput
    comments?: CommentCreateNestedManyWithoutNovelInput
  }

  export type NovelUncheckedCreateWithoutReadersInput = {
    id?: number
    title: string
    originalTitle?: string | null
    authorId?: number | null
    createdById: number
    genreId: number
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status?: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount?: number
    totalChapters?: number
    publishedAt?: Date | string | null
    newChapterAt?: Date | string
    createdAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutNovelInput
    novelTags?: NovelTagUncheckedCreateNestedManyWithoutNovelInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutNovelInput
    statistics?: NovelStatisticUncheckedCreateNestedManyWithoutNovelInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutNovelInput
    comments?: CommentUncheckedCreateNestedManyWithoutNovelInput
  }

  export type NovelCreateOrConnectWithoutReadersInput = {
    where: NovelWhereUniqueInput
    create: XOR<NovelCreateWithoutReadersInput, NovelUncheckedCreateWithoutReadersInput>
  }

  export type ChapterCreateWithoutReadingInput = {
    chapterNumber: number
    title: string
    content: string
    isLocked?: boolean
    unlockCost?: number
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    novel: NovelCreateNestedOneWithoutChaptersInput
    comments?: CommentCreateNestedManyWithoutChapterInput
    statistics?: ChapterStatisticCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutReadingInput = {
    id?: number
    novelId: number
    chapterNumber: number
    title: string
    content: string
    isLocked?: boolean
    unlockCost?: number
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutChapterInput
    statistics?: ChapterStatisticUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutReadingInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutReadingInput, ChapterUncheckedCreateWithoutReadingInput>
  }

  export type UserUpsertWithoutReadingsInput = {
    update: XOR<UserUpdateWithoutReadingsInput, UserUncheckedUpdateWithoutReadingsInput>
    create: XOR<UserCreateWithoutReadingsInput, UserUncheckedCreateWithoutReadingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReadingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReadingsInput, UserUncheckedUpdateWithoutReadingsInput>
  }

  export type UserUpdateWithoutReadingsInput = {
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    bio?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: UserUpdatesocialLinksInput | string[]
    keys?: IntFieldUpdateOperationsInput | number
    tickets?: IntFieldUpdateOperationsInput | number
    candies?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTwoFactorAuth?: BoolFieldUpdateOperationsInput | boolean
    notifications?: NotificationSettingsUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    authoredNovels?: NovelUpdateManyWithoutCreatedByNestedInput
    sessions?: RefreshTokenUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUpdateManyWithoutUserNestedInput
    replies?: ReplyCommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReadingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    bio?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: UserUpdatesocialLinksInput | string[]
    keys?: IntFieldUpdateOperationsInput | number
    tickets?: IntFieldUpdateOperationsInput | number
    candies?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTwoFactorAuth?: BoolFieldUpdateOperationsInput | boolean
    notifications?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    authoredNovels?: NovelUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NovelUpsertWithoutReadersInput = {
    update: XOR<NovelUpdateWithoutReadersInput, NovelUncheckedUpdateWithoutReadersInput>
    create: XOR<NovelCreateWithoutReadersInput, NovelUncheckedCreateWithoutReadersInput>
    where?: NovelWhereInput
  }

  export type NovelUpdateToOneWithWhereWithoutReadersInput = {
    where?: NovelWhereInput
    data: XOR<NovelUpdateWithoutReadersInput, NovelUncheckedUpdateWithoutReadersInput>
  }

  export type NovelUpdateWithoutReadersInput = {
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AuthorUpdateOneWithoutNovelsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutAuthoredNovelsNestedInput
    genre?: GenreUpdateOneRequiredWithoutNovelsNestedInput
    chapters?: ChapterUpdateManyWithoutNovelNestedInput
    novelTags?: NovelTagUpdateManyWithoutNovelNestedInput
    reviews?: ReviewUpdateManyWithoutNovelNestedInput
    statistics?: NovelStatisticUpdateManyWithoutNovelNestedInput
    favorites?: FavoriteUpdateManyWithoutNovelNestedInput
    comments?: CommentUpdateManyWithoutNovelNestedInput
  }

  export type NovelUncheckedUpdateWithoutReadersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    genreId?: IntFieldUpdateOperationsInput | number
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutNovelNestedInput
    novelTags?: NovelTagUncheckedUpdateManyWithoutNovelNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutNovelNestedInput
    statistics?: NovelStatisticUncheckedUpdateManyWithoutNovelNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutNovelNestedInput
    comments?: CommentUncheckedUpdateManyWithoutNovelNestedInput
  }

  export type ChapterUpsertWithoutReadingInput = {
    update: XOR<ChapterUpdateWithoutReadingInput, ChapterUncheckedUpdateWithoutReadingInput>
    create: XOR<ChapterCreateWithoutReadingInput, ChapterUncheckedCreateWithoutReadingInput>
    where?: ChapterWhereInput
  }

  export type ChapterUpdateToOneWithWhereWithoutReadingInput = {
    where?: ChapterWhereInput
    data: XOR<ChapterUpdateWithoutReadingInput, ChapterUncheckedUpdateWithoutReadingInput>
  }

  export type ChapterUpdateWithoutReadingInput = {
    chapterNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    unlockCost?: IntFieldUpdateOperationsInput | number
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    novel?: NovelUpdateOneRequiredWithoutChaptersNestedInput
    comments?: CommentUpdateManyWithoutChapterNestedInput
    statistics?: ChapterStatisticUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutReadingInput = {
    id?: IntFieldUpdateOperationsInput | number
    novelId?: IntFieldUpdateOperationsInput | number
    chapterNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    unlockCost?: IntFieldUpdateOperationsInput | number
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutChapterNestedInput
    statistics?: ChapterStatisticUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type UserCreateWithoutFavoritesInput = {
    nickname: string
    email: string
    password?: string | null
    phone?: string
    avatar?: string
    coverImage?: string
    role?: $Enums.UserRole
    gender?: $Enums.Gender
    bio?: string
    birthDate?: Date | string
    socialLinks?: UserCreatesocialLinksInput | string[]
    keys?: number
    tickets?: number
    candies?: number
    createdAt?: Date | string
    emailVerifiedAt?: Date | string | null
    isTwoFactorAuth?: boolean
    notifications?: NotificationSettingsCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutUserInput
    authoredNovels?: NovelCreateNestedManyWithoutCreatedByInput
    sessions?: RefreshTokenCreateNestedManyWithoutUserInput
    readings?: ReadingCreateNestedManyWithoutUserInput
    replies?: ReplyCommentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFavoritesInput = {
    id?: number
    nickname: string
    email: string
    password?: string | null
    phone?: string
    avatar?: string
    coverImage?: string
    role?: $Enums.UserRole
    gender?: $Enums.Gender
    bio?: string
    birthDate?: Date | string
    socialLinks?: UserCreatesocialLinksInput | string[]
    keys?: number
    tickets?: number
    candies?: number
    createdAt?: Date | string
    emailVerifiedAt?: Date | string | null
    isTwoFactorAuth?: boolean
    notifications?: NotificationSettingsUncheckedCreateNestedOneWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutUserInput
    authoredNovels?: NovelUncheckedCreateNestedManyWithoutCreatedByInput
    sessions?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    readings?: ReadingUncheckedCreateNestedManyWithoutUserInput
    replies?: ReplyCommentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFavoritesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
  }

  export type NovelCreateWithoutFavoritesInput = {
    title: string
    originalTitle?: string | null
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status?: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount?: number
    totalChapters?: number
    publishedAt?: Date | string | null
    newChapterAt?: Date | string
    createdAt?: Date | string
    author?: AuthorCreateNestedOneWithoutNovelsInput
    createdBy: UserCreateNestedOneWithoutAuthoredNovelsInput
    genre: GenreCreateNestedOneWithoutNovelsInput
    chapters?: ChapterCreateNestedManyWithoutNovelInput
    novelTags?: NovelTagCreateNestedManyWithoutNovelInput
    reviews?: ReviewCreateNestedManyWithoutNovelInput
    statistics?: NovelStatisticCreateNestedManyWithoutNovelInput
    readers?: ReadingCreateNestedManyWithoutNovelInput
    comments?: CommentCreateNestedManyWithoutNovelInput
  }

  export type NovelUncheckedCreateWithoutFavoritesInput = {
    id?: number
    title: string
    originalTitle?: string | null
    authorId?: number | null
    createdById: number
    genreId: number
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status?: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount?: number
    totalChapters?: number
    publishedAt?: Date | string | null
    newChapterAt?: Date | string
    createdAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutNovelInput
    novelTags?: NovelTagUncheckedCreateNestedManyWithoutNovelInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutNovelInput
    statistics?: NovelStatisticUncheckedCreateNestedManyWithoutNovelInput
    readers?: ReadingUncheckedCreateNestedManyWithoutNovelInput
    comments?: CommentUncheckedCreateNestedManyWithoutNovelInput
  }

  export type NovelCreateOrConnectWithoutFavoritesInput = {
    where: NovelWhereUniqueInput
    create: XOR<NovelCreateWithoutFavoritesInput, NovelUncheckedCreateWithoutFavoritesInput>
  }

  export type UserUpsertWithoutFavoritesInput = {
    update: XOR<UserUpdateWithoutFavoritesInput, UserUncheckedUpdateWithoutFavoritesInput>
    create: XOR<UserCreateWithoutFavoritesInput, UserUncheckedCreateWithoutFavoritesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFavoritesInput, UserUncheckedUpdateWithoutFavoritesInput>
  }

  export type UserUpdateWithoutFavoritesInput = {
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    bio?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: UserUpdatesocialLinksInput | string[]
    keys?: IntFieldUpdateOperationsInput | number
    tickets?: IntFieldUpdateOperationsInput | number
    candies?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTwoFactorAuth?: BoolFieldUpdateOperationsInput | boolean
    notifications?: NotificationSettingsUpdateOneWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutUserNestedInput
    authoredNovels?: NovelUpdateManyWithoutCreatedByNestedInput
    sessions?: RefreshTokenUpdateManyWithoutUserNestedInput
    readings?: ReadingUpdateManyWithoutUserNestedInput
    replies?: ReplyCommentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFavoritesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nickname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    bio?: StringFieldUpdateOperationsInput | string
    birthDate?: DateTimeFieldUpdateOperationsInput | Date | string
    socialLinks?: UserUpdatesocialLinksInput | string[]
    keys?: IntFieldUpdateOperationsInput | number
    tickets?: IntFieldUpdateOperationsInput | number
    candies?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isTwoFactorAuth?: BoolFieldUpdateOperationsInput | boolean
    notifications?: NotificationSettingsUncheckedUpdateOneWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutUserNestedInput
    authoredNovels?: NovelUncheckedUpdateManyWithoutCreatedByNestedInput
    sessions?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    readings?: ReadingUncheckedUpdateManyWithoutUserNestedInput
    replies?: ReplyCommentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NovelUpsertWithoutFavoritesInput = {
    update: XOR<NovelUpdateWithoutFavoritesInput, NovelUncheckedUpdateWithoutFavoritesInput>
    create: XOR<NovelCreateWithoutFavoritesInput, NovelUncheckedCreateWithoutFavoritesInput>
    where?: NovelWhereInput
  }

  export type NovelUpdateToOneWithWhereWithoutFavoritesInput = {
    where?: NovelWhereInput
    data: XOR<NovelUpdateWithoutFavoritesInput, NovelUncheckedUpdateWithoutFavoritesInput>
  }

  export type NovelUpdateWithoutFavoritesInput = {
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AuthorUpdateOneWithoutNovelsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutAuthoredNovelsNestedInput
    genre?: GenreUpdateOneRequiredWithoutNovelsNestedInput
    chapters?: ChapterUpdateManyWithoutNovelNestedInput
    novelTags?: NovelTagUpdateManyWithoutNovelNestedInput
    reviews?: ReviewUpdateManyWithoutNovelNestedInput
    statistics?: NovelStatisticUpdateManyWithoutNovelNestedInput
    readers?: ReadingUpdateManyWithoutNovelNestedInput
    comments?: CommentUpdateManyWithoutNovelNestedInput
  }

  export type NovelUncheckedUpdateWithoutFavoritesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    genreId?: IntFieldUpdateOperationsInput | number
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutNovelNestedInput
    novelTags?: NovelTagUncheckedUpdateManyWithoutNovelNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutNovelNestedInput
    statistics?: NovelStatisticUncheckedUpdateManyWithoutNovelNestedInput
    readers?: ReadingUncheckedUpdateManyWithoutNovelNestedInput
    comments?: CommentUncheckedUpdateManyWithoutNovelNestedInput
  }

  export type NovelCreateWithoutStatisticsInput = {
    title: string
    originalTitle?: string | null
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status?: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount?: number
    totalChapters?: number
    publishedAt?: Date | string | null
    newChapterAt?: Date | string
    createdAt?: Date | string
    author?: AuthorCreateNestedOneWithoutNovelsInput
    createdBy: UserCreateNestedOneWithoutAuthoredNovelsInput
    genre: GenreCreateNestedOneWithoutNovelsInput
    chapters?: ChapterCreateNestedManyWithoutNovelInput
    novelTags?: NovelTagCreateNestedManyWithoutNovelInput
    reviews?: ReviewCreateNestedManyWithoutNovelInput
    readers?: ReadingCreateNestedManyWithoutNovelInput
    favorites?: FavoriteCreateNestedManyWithoutNovelInput
    comments?: CommentCreateNestedManyWithoutNovelInput
  }

  export type NovelUncheckedCreateWithoutStatisticsInput = {
    id?: number
    title: string
    originalTitle?: string | null
    authorId?: number | null
    createdById: number
    genreId: number
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status?: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount?: number
    totalChapters?: number
    publishedAt?: Date | string | null
    newChapterAt?: Date | string
    createdAt?: Date | string
    chapters?: ChapterUncheckedCreateNestedManyWithoutNovelInput
    novelTags?: NovelTagUncheckedCreateNestedManyWithoutNovelInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutNovelInput
    readers?: ReadingUncheckedCreateNestedManyWithoutNovelInput
    favorites?: FavoriteUncheckedCreateNestedManyWithoutNovelInput
    comments?: CommentUncheckedCreateNestedManyWithoutNovelInput
  }

  export type NovelCreateOrConnectWithoutStatisticsInput = {
    where: NovelWhereUniqueInput
    create: XOR<NovelCreateWithoutStatisticsInput, NovelUncheckedCreateWithoutStatisticsInput>
  }

  export type NovelUpsertWithoutStatisticsInput = {
    update: XOR<NovelUpdateWithoutStatisticsInput, NovelUncheckedUpdateWithoutStatisticsInput>
    create: XOR<NovelCreateWithoutStatisticsInput, NovelUncheckedCreateWithoutStatisticsInput>
    where?: NovelWhereInput
  }

  export type NovelUpdateToOneWithWhereWithoutStatisticsInput = {
    where?: NovelWhereInput
    data: XOR<NovelUpdateWithoutStatisticsInput, NovelUncheckedUpdateWithoutStatisticsInput>
  }

  export type NovelUpdateWithoutStatisticsInput = {
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AuthorUpdateOneWithoutNovelsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutAuthoredNovelsNestedInput
    genre?: GenreUpdateOneRequiredWithoutNovelsNestedInput
    chapters?: ChapterUpdateManyWithoutNovelNestedInput
    novelTags?: NovelTagUpdateManyWithoutNovelNestedInput
    reviews?: ReviewUpdateManyWithoutNovelNestedInput
    readers?: ReadingUpdateManyWithoutNovelNestedInput
    favorites?: FavoriteUpdateManyWithoutNovelNestedInput
    comments?: CommentUpdateManyWithoutNovelNestedInput
  }

  export type NovelUncheckedUpdateWithoutStatisticsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    genreId?: IntFieldUpdateOperationsInput | number
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutNovelNestedInput
    novelTags?: NovelTagUncheckedUpdateManyWithoutNovelNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutNovelNestedInput
    readers?: ReadingUncheckedUpdateManyWithoutNovelNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutNovelNestedInput
    comments?: CommentUncheckedUpdateManyWithoutNovelNestedInput
  }

  export type ChapterCreateWithoutStatisticsInput = {
    chapterNumber: number
    title: string
    content: string
    isLocked?: boolean
    unlockCost?: number
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    novel: NovelCreateNestedOneWithoutChaptersInput
    comments?: CommentCreateNestedManyWithoutChapterInput
    reading?: ReadingCreateNestedManyWithoutChapterInput
  }

  export type ChapterUncheckedCreateWithoutStatisticsInput = {
    id?: number
    novelId: number
    chapterNumber: number
    title: string
    content: string
    isLocked?: boolean
    unlockCost?: number
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutChapterInput
    reading?: ReadingUncheckedCreateNestedManyWithoutChapterInput
  }

  export type ChapterCreateOrConnectWithoutStatisticsInput = {
    where: ChapterWhereUniqueInput
    create: XOR<ChapterCreateWithoutStatisticsInput, ChapterUncheckedCreateWithoutStatisticsInput>
  }

  export type ChapterUpsertWithoutStatisticsInput = {
    update: XOR<ChapterUpdateWithoutStatisticsInput, ChapterUncheckedUpdateWithoutStatisticsInput>
    create: XOR<ChapterCreateWithoutStatisticsInput, ChapterUncheckedCreateWithoutStatisticsInput>
    where?: ChapterWhereInput
  }

  export type ChapterUpdateToOneWithWhereWithoutStatisticsInput = {
    where?: ChapterWhereInput
    data: XOR<ChapterUpdateWithoutStatisticsInput, ChapterUncheckedUpdateWithoutStatisticsInput>
  }

  export type ChapterUpdateWithoutStatisticsInput = {
    chapterNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    unlockCost?: IntFieldUpdateOperationsInput | number
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    novel?: NovelUpdateOneRequiredWithoutChaptersNestedInput
    comments?: CommentUpdateManyWithoutChapterNestedInput
    reading?: ReadingUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutStatisticsInput = {
    id?: IntFieldUpdateOperationsInput | number
    novelId?: IntFieldUpdateOperationsInput | number
    chapterNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    unlockCost?: IntFieldUpdateOperationsInput | number
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutChapterNestedInput
    reading?: ReadingUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type ReviewCreateManyUserInput = {
    id?: number
    rating: number
    content: string
    isSpoiler?: boolean
    novelId: number
    createdAt?: Date | string
  }

  export type CommentCreateManyUserInput = {
    id?: number
    content: string
    likes?: number
    chapterId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    novelId?: number | null
  }

  export type NovelCreateManyCreatedByInput = {
    id?: number
    title: string
    originalTitle?: string | null
    authorId?: number | null
    genreId: number
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status?: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount?: number
    totalChapters?: number
    publishedAt?: Date | string | null
    newChapterAt?: Date | string
    createdAt?: Date | string
  }

  export type RefreshTokenCreateManyUserInput = {
    token?: string
    expiresAt: Date | string
    createdAt?: Date | string
  }

  export type ReadingCreateManyUserInput = {
    novelId: number
    chapterId: number
    lastRead?: Date | string
  }

  export type FavoriteCreateManyUserInput = {
    novelId: number
    createdAt?: Date | string
  }

  export type ReplyCommentCreateManyUserInput = {
    id?: number
    content: string
    likes?: number
    commentId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateWithoutUserInput = {
    rating?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isSpoiler?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    novel?: NovelUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isSpoiler?: BoolFieldUpdateOperationsInput | boolean
    novelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isSpoiler?: BoolFieldUpdateOperationsInput | boolean
    novelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapter?: ChapterUpdateOneRequiredWithoutCommentsNestedInput
    replies?: ReplyCommentUpdateManyWithoutCommentNestedInput
    Novel?: NovelUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    novelId?: NullableIntFieldUpdateOperationsInput | number | null
    replies?: ReplyCommentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    novelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NovelUpdateWithoutCreatedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AuthorUpdateOneWithoutNovelsNestedInput
    genre?: GenreUpdateOneRequiredWithoutNovelsNestedInput
    chapters?: ChapterUpdateManyWithoutNovelNestedInput
    novelTags?: NovelTagUpdateManyWithoutNovelNestedInput
    reviews?: ReviewUpdateManyWithoutNovelNestedInput
    statistics?: NovelStatisticUpdateManyWithoutNovelNestedInput
    readers?: ReadingUpdateManyWithoutNovelNestedInput
    favorites?: FavoriteUpdateManyWithoutNovelNestedInput
    comments?: CommentUpdateManyWithoutNovelNestedInput
  }

  export type NovelUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    genreId?: IntFieldUpdateOperationsInput | number
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutNovelNestedInput
    novelTags?: NovelTagUncheckedUpdateManyWithoutNovelNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutNovelNestedInput
    statistics?: NovelStatisticUncheckedUpdateManyWithoutNovelNestedInput
    readers?: ReadingUncheckedUpdateManyWithoutNovelNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutNovelNestedInput
    comments?: CommentUncheckedUpdateManyWithoutNovelNestedInput
  }

  export type NovelUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    genreId?: IntFieldUpdateOperationsInput | number
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadingUpdateWithoutUserInput = {
    lastRead?: DateTimeFieldUpdateOperationsInput | Date | string
    novel?: NovelUpdateOneRequiredWithoutReadersNestedInput
    chapter?: ChapterUpdateOneRequiredWithoutReadingNestedInput
  }

  export type ReadingUncheckedUpdateWithoutUserInput = {
    novelId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    lastRead?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadingUncheckedUpdateManyWithoutUserInput = {
    novelId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    lastRead?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    novel?: NovelUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteUncheckedUpdateWithoutUserInput = {
    novelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateManyWithoutUserInput = {
    novelId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReplyCommentUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneRequiredWithoutRepliesNestedInput
  }

  export type ReplyCommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReplyCommentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NovelCreateManyAuthorInput = {
    id?: number
    title: string
    originalTitle?: string | null
    createdById: number
    genreId: number
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status?: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount?: number
    totalChapters?: number
    publishedAt?: Date | string | null
    newChapterAt?: Date | string
    createdAt?: Date | string
  }

  export type NovelUpdateWithoutAuthorInput = {
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutAuthoredNovelsNestedInput
    genre?: GenreUpdateOneRequiredWithoutNovelsNestedInput
    chapters?: ChapterUpdateManyWithoutNovelNestedInput
    novelTags?: NovelTagUpdateManyWithoutNovelNestedInput
    reviews?: ReviewUpdateManyWithoutNovelNestedInput
    statistics?: NovelStatisticUpdateManyWithoutNovelNestedInput
    readers?: ReadingUpdateManyWithoutNovelNestedInput
    favorites?: FavoriteUpdateManyWithoutNovelNestedInput
    comments?: CommentUpdateManyWithoutNovelNestedInput
  }

  export type NovelUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: IntFieldUpdateOperationsInput | number
    genreId?: IntFieldUpdateOperationsInput | number
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutNovelNestedInput
    novelTags?: NovelTagUncheckedUpdateManyWithoutNovelNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutNovelNestedInput
    statistics?: NovelStatisticUncheckedUpdateManyWithoutNovelNestedInput
    readers?: ReadingUncheckedUpdateManyWithoutNovelNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutNovelNestedInput
    comments?: CommentUncheckedUpdateManyWithoutNovelNestedInput
  }

  export type NovelUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: IntFieldUpdateOperationsInput | number
    genreId?: IntFieldUpdateOperationsInput | number
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterCreateManyNovelInput = {
    id?: number
    chapterNumber: number
    title: string
    content: string
    isLocked?: boolean
    unlockCost?: number
    publishedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NovelTagCreateManyNovelInput = {
    tagId: number
  }

  export type ReviewCreateManyNovelInput = {
    id?: number
    rating: number
    content: string
    isSpoiler?: boolean
    userId: number
    createdAt?: Date | string
  }

  export type NovelStatisticCreateManyNovelInput = {
    id?: number
    dailyViews?: number
    totalViews?: number
    reviews?: number
    comments?: number
    date: Date | string
  }

  export type ReadingCreateManyNovelInput = {
    userId: number
    chapterId: number
    lastRead?: Date | string
  }

  export type FavoriteCreateManyNovelInput = {
    userId: number
    createdAt?: Date | string
  }

  export type CommentCreateManyNovelInput = {
    id?: number
    content: string
    likes?: number
    userId: number
    chapterId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChapterUpdateWithoutNovelInput = {
    chapterNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    unlockCost?: IntFieldUpdateOperationsInput | number
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutChapterNestedInput
    statistics?: ChapterStatisticUpdateManyWithoutChapterNestedInput
    reading?: ReadingUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateWithoutNovelInput = {
    id?: IntFieldUpdateOperationsInput | number
    chapterNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    unlockCost?: IntFieldUpdateOperationsInput | number
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutChapterNestedInput
    statistics?: ChapterStatisticUncheckedUpdateManyWithoutChapterNestedInput
    reading?: ReadingUncheckedUpdateManyWithoutChapterNestedInput
  }

  export type ChapterUncheckedUpdateManyWithoutNovelInput = {
    id?: IntFieldUpdateOperationsInput | number
    chapterNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    unlockCost?: IntFieldUpdateOperationsInput | number
    publishedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NovelTagUpdateWithoutNovelInput = {
    tag?: TagUpdateOneRequiredWithoutNovelsNestedInput
  }

  export type NovelTagUncheckedUpdateWithoutNovelInput = {
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type NovelTagUncheckedUpdateManyWithoutNovelInput = {
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewUpdateWithoutNovelInput = {
    rating?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isSpoiler?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutNovelInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isSpoiler?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutNovelInput = {
    id?: IntFieldUpdateOperationsInput | number
    rating?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    isSpoiler?: BoolFieldUpdateOperationsInput | boolean
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NovelStatisticUpdateWithoutNovelInput = {
    dailyViews?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    reviews?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NovelStatisticUncheckedUpdateWithoutNovelInput = {
    id?: IntFieldUpdateOperationsInput | number
    dailyViews?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    reviews?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NovelStatisticUncheckedUpdateManyWithoutNovelInput = {
    id?: IntFieldUpdateOperationsInput | number
    dailyViews?: IntFieldUpdateOperationsInput | number
    totalViews?: IntFieldUpdateOperationsInput | number
    reviews?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadingUpdateWithoutNovelInput = {
    lastRead?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReadingsNestedInput
    chapter?: ChapterUpdateOneRequiredWithoutReadingNestedInput
  }

  export type ReadingUncheckedUpdateWithoutNovelInput = {
    userId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    lastRead?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadingUncheckedUpdateManyWithoutNovelInput = {
    userId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    lastRead?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUpdateWithoutNovelInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFavoritesNestedInput
  }

  export type FavoriteUncheckedUpdateWithoutNovelInput = {
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FavoriteUncheckedUpdateManyWithoutNovelInput = {
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutNovelInput = {
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    chapter?: ChapterUpdateOneRequiredWithoutCommentsNestedInput
    replies?: ReplyCommentUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutNovelInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ReplyCommentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutNovelInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    chapterId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NovelCreateManyGenreInput = {
    id?: number
    title: string
    originalTitle?: string | null
    authorId?: number | null
    createdById: number
    kind: $Enums.NovelKind
    gender: $Enums.Gender
    status?: $Enums.NovelStatus
    synopsis: string
    coverImage: string
    wordCount?: number
    totalChapters?: number
    publishedAt?: Date | string | null
    newChapterAt?: Date | string
    createdAt?: Date | string
  }

  export type NovelUpdateWithoutGenreInput = {
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: AuthorUpdateOneWithoutNovelsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutAuthoredNovelsNestedInput
    chapters?: ChapterUpdateManyWithoutNovelNestedInput
    novelTags?: NovelTagUpdateManyWithoutNovelNestedInput
    reviews?: ReviewUpdateManyWithoutNovelNestedInput
    statistics?: NovelStatisticUpdateManyWithoutNovelNestedInput
    readers?: ReadingUpdateManyWithoutNovelNestedInput
    favorites?: FavoriteUpdateManyWithoutNovelNestedInput
    comments?: CommentUpdateManyWithoutNovelNestedInput
  }

  export type NovelUncheckedUpdateWithoutGenreInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chapters?: ChapterUncheckedUpdateManyWithoutNovelNestedInput
    novelTags?: NovelTagUncheckedUpdateManyWithoutNovelNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutNovelNestedInput
    statistics?: NovelStatisticUncheckedUpdateManyWithoutNovelNestedInput
    readers?: ReadingUncheckedUpdateManyWithoutNovelNestedInput
    favorites?: FavoriteUncheckedUpdateManyWithoutNovelNestedInput
    comments?: CommentUncheckedUpdateManyWithoutNovelNestedInput
  }

  export type NovelUncheckedUpdateManyWithoutGenreInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    originalTitle?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    createdById?: IntFieldUpdateOperationsInput | number
    kind?: EnumNovelKindFieldUpdateOperationsInput | $Enums.NovelKind
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    status?: EnumNovelStatusFieldUpdateOperationsInput | $Enums.NovelStatus
    synopsis?: StringFieldUpdateOperationsInput | string
    coverImage?: StringFieldUpdateOperationsInput | string
    wordCount?: IntFieldUpdateOperationsInput | number
    totalChapters?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    newChapterAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NovelTagCreateManyTagInput = {
    novelId: number
  }

  export type NovelTagUpdateWithoutTagInput = {
    novel?: NovelUpdateOneRequiredWithoutNovelTagsNestedInput
  }

  export type NovelTagUncheckedUpdateWithoutTagInput = {
    novelId?: IntFieldUpdateOperationsInput | number
  }

  export type NovelTagUncheckedUpdateManyWithoutTagInput = {
    novelId?: IntFieldUpdateOperationsInput | number
  }

  export type TagCreateManyTagGroupInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type TagUpdateWithoutTagGroupInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    novels?: NovelTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateWithoutTagGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    novels?: NovelTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateManyWithoutTagGroupInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CommentCreateManyChapterInput = {
    id?: number
    content: string
    likes?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    novelId?: number | null
  }

  export type ChapterStatisticCreateManyChapterInput = {
    id?: number
    views?: number
    date: Date | string
  }

  export type ReadingCreateManyChapterInput = {
    userId: number
    novelId: number
    lastRead?: Date | string
  }

  export type CommentUpdateWithoutChapterInput = {
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentsNestedInput
    replies?: ReplyCommentUpdateManyWithoutCommentNestedInput
    Novel?: NovelUpdateOneWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateWithoutChapterInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    novelId?: NullableIntFieldUpdateOperationsInput | number | null
    replies?: ReplyCommentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutChapterInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    novelId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ChapterStatisticUpdateWithoutChapterInput = {
    views?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterStatisticUncheckedUpdateWithoutChapterInput = {
    id?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChapterStatisticUncheckedUpdateManyWithoutChapterInput = {
    id?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadingUpdateWithoutChapterInput = {
    lastRead?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReadingsNestedInput
    novel?: NovelUpdateOneRequiredWithoutReadersNestedInput
  }

  export type ReadingUncheckedUpdateWithoutChapterInput = {
    userId?: IntFieldUpdateOperationsInput | number
    novelId?: IntFieldUpdateOperationsInput | number
    lastRead?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReadingUncheckedUpdateManyWithoutChapterInput = {
    userId?: IntFieldUpdateOperationsInput | number
    novelId?: IntFieldUpdateOperationsInput | number
    lastRead?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReplyCommentCreateManyCommentInput = {
    id?: number
    content: string
    likes?: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReplyCommentUpdateWithoutCommentInput = {
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRepliesNestedInput
  }

  export type ReplyCommentUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReplyCommentUncheckedUpdateManyWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}